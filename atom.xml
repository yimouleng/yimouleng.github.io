<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Yi'mouleng-即便世界与我为敌，只要心还透明，就能折射希望。]]></title>
  <subtitle><![CDATA[知止安能定,定而知静,静方可虑,虑而后能得。---iOS交流群67784110]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yimouleng.com/"/>
  <updated>2015-12-15T09:59:45.000Z</updated>
  <id>http://yimouleng.com/</id>
  
  <author>
    <name><![CDATA[Yi'mouleng]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[js(javascript)与OC(Objective-C)交互]]></title>
    <link href="http://yimouleng.com/2015/11/05/ios-javascript-OC/"/>
    <id>http://yimouleng.com/2015/11/05/ios-javascript-OC/</id>
    <published>2015-11-04T16:00:00.000Z</published>
    <updated>2015-12-15T09:59:45.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>  实质上oc与js的通信交互就是发送消息，也即函数调用,iOS7以后官方公布JavaScriptCore framework中很方便我们对他们之间的相互调用。在以前我们只能通过UIWebView的UIWebViewDelegate协议来实现.</p>
  <figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="pp">- <span class="params">(<span class="variable">BOOL</span>)</span>webView:<span class="params">(<span class="variable">UIWebView</span> *)</span>webView shouldStartLoadWithRequest:<span class="params">(<span class="variable">NSURLRequest</span> *)</span>request navigationType:<span class="params">(<span class="variable">UIWebViewNavigationType</span>)</span>navigationType;</span></span><br></pre></td></tr></table></figure>
<p>  或者</p>
  <figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="pp">- <span class="params">(void)</span>webViewDidStartLoad:<span class="params">(<span class="variable">UIWebView</span> *)</span>webView;</span></span><br></pre></td></tr></table></figure>
  <a id="more"></a>
<blockquote>
<ul>
<li>oc–&gt;js  stringByEvaluatingJavaScriptFromString,其参数是一NSString 字符串内容是js代码（这又可以是一个js函数、一句js代码或他们的组合），当js函数有返回值或一句js代码有值返回可通过stringByEvaluatingJavaScriptFromString的返回值获取</li>
<li>js–&gt;oc 利用webView的重定向原理（即重新在js中指定document.location的值，此为一url），只要在这个url字符串中按自定义的规则指定好所需调用oc中的函数和参数，然后通过OC中的shouldStartLoadWithRequest函数去捕获处理请求。</li>
</ul>
</blockquote>
<h3 id="u4E00_JS_u8C03_u7528OC"><a href="#u4E00_JS_u8C03_u7528OC" class="headerlink" title="一 JS调用OC"></a>一 JS调用OC</h3><h4 id="js_u4EE3_u7801_u5982_u4E0B"><a href="#js_u4EE3_u7801_u5982_u4E0B" class="headerlink" title="js代码如下"></a>js代码如下</h4><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function <span class="type">CallNative</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (native)</span><br><span class="line">    &#123;</span><br><span class="line">        //将消息组装成对象发给<span class="type">OC</span></span><br><span class="line">        <span class="keyword">var</span> parameter = &#123;'message':'<span class="type">Hello</span>,<span class="type">Objective</span>-C!'&#125;;</span><br><span class="line">        <span class="keyword">var</span> <span class="literal">result</span> = native.ocMethod(parameter);</span><br><span class="line">        </span><br><span class="line">        //显示<span class="type">OC</span>返回的结果</span><br><span class="line">        alert(<span class="literal">result</span>['message']);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="OC_u4EE3_u7801"><a href="#OC_u4EE3_u7801" class="headerlink" title="OC代码"></a>OC代码</h4><p>  <strong>js调用iOS分两种情况</strong></p>
<blockquote>
<p>js里面直接调用方法</p>
<p>js里面通过对象调用方法</p>
</blockquote>
<h5 id="js_u91CC_u9762_u76F4_u63A5_u8C03_u7528_u65B9_u6CD5"><a href="#js_u91CC_u9762_u76F4_u63A5_u8C03_u7528_u65B9_u6CD5" class="headerlink" title="js里面直接调用方法"></a>js里面直接调用方法</h5><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)webViewDidStartLoad:(<span class="type">UIWebView</span> *)webView&#123;</span><br><span class="line"></span><br><span class="line">    //首先创建<span class="type">JSContext</span> 对象（此处通过当前webView的键获取到jscontext）</span><br><span class="line">    <span class="type">JSContext</span> *context=[webView valueForKeyPath:@<span class="string">"documentView.webView.mainFrame.javaScriptContext"</span>];</span><br><span class="line">     //其中getCurrentUser就是js的方法名称，赋给是一个<span class="keyword">block</span> 里面是iOS代码</span><br><span class="line">    context[@<span class="string">"getCurrentUser"</span>] = ^() &#123;</span><br><span class="line">    //在<span class="keyword">block</span>中写<span class="type">OC</span>代码</span><br><span class="line">        <span class="keyword">return</span> [[<span class="type">NSUserDefaults</span> standardUserDefaults]objectForKey:@<span class="string">"MYJSANDOC"</span>];</span><br><span class="line">    &#125;;</span><br><span class="line">    context[@<span class="string">"encodeParam"</span>] = ^() &#123;</span><br><span class="line">        <span class="type">NSArray</span> *args = [<span class="type">JSContext</span> currentArguments];</span><br><span class="line">        <span class="type">NSString</span> *param = [<span class="type">NSString</span> stringWithFormat:@<span class="string">"%@"</span>,args[<span class="number">0</span>]];</span><br><span class="line">        <span class="type">NSString</span> *<span class="literal">result</span> = [[[<span class="type">YXBaseRequestManager</span> alloc]init]encryptUseAES:param key:@<span class="string">"1%7jhs#Zjasd&amp;tr*"</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="js_u91CC_u9762_u901A_u8FC7_u5BF9_u8C61_u8C03_u7528_u65B9_u6CD5"><a href="#js_u91CC_u9762_u901A_u8FC7_u5BF9_u8C61_u8C03_u7528_u65B9_u6CD5" class="headerlink" title="js里面通过对象调用方法"></a>js里面通过对象调用方法</h5><p>  在这个方法中我们需要使用到 <code>JSExport</code><br>  <code>JSExport</code>是一个协议，自定义协议后，里面的声明变量等会对JS开放，我们即可调用。</p>
<p>  首先我们要自定义一个协议，添加头文件<code>#import &lt;JavaScriptCore/JavaScriptCore.h&gt;</code>，继承自<code>NSObject</code></p>
  <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">  <span class="preprocessor">#import <span class="title">&lt;Foundation/Foundation.h&gt;</span>  </span></span><br><span class="line"><span class="preprocessor">#import <span class="title">&lt;JavaScriptCore/JavaScriptCore.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//首先创建一个实现了JSExport协议的协议  </span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">JSObjectText</span> &lt;<span class="title">JSExport</span>&gt;  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//此处我们测试几种参数的情况  </span></span><br><span class="line">-(<span class="keyword">void</span>)JSObjectTextPush;   </span><br><span class="line">  </span><br><span class="line"><span class="keyword">@end</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//让我们创建的类实现上边的协议  </span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">JSObject</span> : <span class="title">NSObject</span>&lt;<span class="title">JSObjectText</span>&gt;  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>  在.m中实现</p>
  <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  <span class="preprocessor">#import <span class="title">"JSObjectText.h"</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">JSObjectText</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//本地储存Key,调用之后， 检查key是否存在则说明是否条用了原生方法</span></span><br><span class="line">-(<span class="keyword">void</span>)JSObjectTextPush  </span><br><span class="line">&#123;  </span><br><span class="line">    [[<span class="built_in">NSUserDefaults</span> standardUserDefaults]objectForKey:<span class="string">@"MYJSANDOC"</span>];</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>  在weibview加载完成之后调用</p>
  <figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  -(<span class="typename">void</span>)<span class="string">webViewDidFinishLoad:</span>(UIWebView *)webView  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="comment">//网页加载完成调用此方法  </span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">//首先创建JSContext 对象（此处通过当前webView的键获取到jscontext）  </span></span><br><span class="line">    JSContext *context=[webView <span class="string">valueForKeyPath:</span>@<span class="string">"documentView.webView.mainFrame.javaScriptContext"</span>];  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">//第二种情况，js是通过对象调用的，我们假设js里面有一个对象 testobject 在调用方法  </span></span><br><span class="line">    <span class="comment">//首先创建我们新建类的对象，将他赋值给js的对象  </span></span><br><span class="line">      </span><br><span class="line">    JSObjectText *text=[JSObjectText <span class="keyword">new</span>];  </span><br><span class="line">    context[@<span class="string">"testobject"</span>]=text;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">//同样我们也用刚才的方式模拟一下js调用方法  </span></span><br><span class="line">    NSString *jsStr=@<span class="string">"testobject.JSObjectTextPush()"</span>;  </span><br><span class="line">    [context <span class="string">evaluateScript:</span>jsStr];  </span><br><span class="line"> </span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u4E8C_OC_u8C03_u7528JS"><a href="#u4E8C_OC_u8C03_u7528JS" class="headerlink" title="二 OC调用JS"></a>二 OC调用JS</h3><p>方法很简单，在加载webview后，通过点击事件，或者 返回值，调用<code>stringByEvaluatingJavaScriptFromString</code>来实现调用JS代码</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/<span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span> 点击事件</span><br><span class="line"> <span class="keyword">*</span> 调用javaScript的方法postStr()并取得返回值</span><br><span class="line"> <span class="keyword">*</span> 输出返回值到控制台</span><br><span class="line"> <span class="keyword">*</span>/</span><br><span class="line">-(void)ocFromJs:(id)sender</span><br><span class="line">&#123;</span><br><span class="line">    NSString <span class="keyword">*</span>str = [self.webview stringByEvaluatingJavaScriptFromString:<span class="comment">@"postStr();"];</span></span><br><span class="line">    NSLog(<span class="comment">@"JS返回值：%@",str);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>  实质上oc与js的通信交互就是发送消息，也即函数调用,iOS7以后官方公布JavaScriptCore framework中很方便我们对他们之间的相互调用。在以前我们只能通过UIWebView的UIWebViewDelegate协议来实现.</p>
  <figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="pp">- <span class="params">(<span class="variable">BOOL</span>)</span>webView:<span class="params">(<span class="variable">UIWebView</span> *)</span>webView shouldStartLoadWithRequest:<span class="params">(<span class="variable">NSURLRequest</span> *)</span>request navigationType:<span class="params">(<span class="variable">UIWebViewNavigationType</span>)</span>navigationType;</span></span><br></pre></td></tr></table></figure>
<p>  或者</p>
  <figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="pp">- <span class="params">(void)</span>webViewDidStartLoad:<span class="params">(<span class="variable">UIWebView</span> *)</span>webView;</span></span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="javascript" scheme="http://yimouleng.com/tags/javascript/"/>
    
      <category term="js" scheme="http://yimouleng.com/tags/js/"/>
    
      <category term="iOS开发" scheme="http://yimouleng.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS安全系列之一：IOS 9 - HTTPS]]></title>
    <link href="http://yimouleng.com/2015/11/04/IOS9-HTTPS/"/>
    <id>http://yimouleng.com/2015/11/04/IOS9-HTTPS/</id>
    <published>2015-11-03T16:00:00.000Z</published>
    <updated>2015-12-09T10:08:46.000Z</updated>
    <content type="html"><![CDATA[<p>如何打造一个安全的App？这是每一个移动开发者必须面对的问题。在移动App开发领域，开发工程师对于安全方面的考虑普遍比较欠缺，而由于iOS平台的封闭性，遭遇到的安全问题相比于Android来说要少得多，这就导致了许多iOS开发人员对于安全性方面没有太多的深入，但对于一个合格的软件开发者来说，安全知识是必备知识之一。</p><br><a id="more"></a><br><p>对于未越狱的iOS设备来说，由于强大的沙箱和授权机制，以及Apple自己掌控的App Store， 基本上杜绝了恶意软件的入侵（非越狱）。但除系统安全之外，我们还是面临很多的安全问题：网络安全、数据安全等，每一项涉及也非常广，安全是非常大的课题，本人并非专业的安全专家，只是从开发者的角度，分析我们常遇到的各项安全问题，并提出通常的解决方法，与各位同学交流学习。</p>

<p>每一个软件工程师都有义务保护用户数据的隐私和安全。</p>

<p><br><br></p>

<p>首先是网络安全，OSI模型各层都会面临相应的网络安全问题，涉及宽广，而网络安全也是安全领域发展最为繁荣的领域。本文我们只是从移动应用开发角度，以尽量简单的方式，讲解HTTPS核心概念知识，以及在iOS平台上的实现。建议现在还在使用HTTP的应用都升级到HTTPS。</p>

<p>引读：<a href="http://get.jobdeer.com/1607.get" target="_blank" rel="external">互联网全站HTTPS的时代已经到来</a></p>

<p><br></p>

<h1>1. <a href="http://en.wikipedia.org/wiki/HTTP_Secure" target="_blank" rel="external">HTTPS</a></h1>

<p>其实HTTPS从最终的数据解析的角度，与HTTP没有任何的区别，HTTPS就是将HTTP协议数据包放到SSL/TSL层加密后，在TCP/IP层组成IP数据报去传输，以此保证传输数据的安全；而对于接收端，在SSL/TSL将接收的数据包解密之后，将数据传给HTTP协议层，就是普通的HTTP数据。HTTP和SSL/TSL都处于OSI模型的应用层。从HTTP切换到HTTPS是一个非常简单的过程，在做具体的切换操作之前，我们需要了解几个概念：</p>

<p><br><br></p>

<h2><a href="http://en.wikipedia.org/wiki/Transport_Layer_Security" target="_blank" rel="external">SSL/TSL</a></h2>

<p>关于SSL/TSL，阮一峰的两篇博客文章做了很好的介绍：</p>

<ul><br><li><a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="external">SSL/TLS协议运行机制的概述</a></li><br><li><a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html" target="_blank" rel="external">图解SSL/TLS协议</a></li><br></ul>


<p>简单的来说，SSL/TSL通过四次握手，主要交换三个信息：</p>

<ol><br><li><strong>数字证书</strong>：该证书包含了公钥等信息，一般是由服务器发给客户端，接收方通过验证这个证书是不是由信赖的CA签发，或者与本地的证书相对比，来判断证书是否可信；假如需要双向验证，则服务器和客户端都需要发送数字证书给对方验证；</li><br><li><p><strong>三个随机数</strong>：这三个随机数构成了后续通信过程中用来对数据进行对称加密解密的<strong>“对话密钥”</strong>。</p><br><br><p> 首先客户端先发第一个随机数N1，然后服务器回了第二个随机数N2（这个过程同时把之前提到的证书发给客户端），这两个随机数都是明文的；而第三个随机数N3（这个随机数被称为Premaster secret），客户端用数字证书的公钥进行非对称加密，发给服务器；而服务器用只有自己知道的私钥来解密，获取第三个随机数。这样，服务端和客户端都有了三个随机数N1+N2+N3，然后两端就使用这三个随机数来生成“对话密钥”，在此之后的通信都是使用这个“对话密钥”来进行对称加密解密。因为这个过程中，服务端的私钥只用来解密第三个随机数，从来没有在网络中传输过，这样的话，只要私钥没有被泄露，那么数据就是安全的。</p></li><br><li><p><strong>加密通信协议</strong>：就是双方商量使用哪一种加密方式，假如两者支持的加密方式不匹配，则无法进行通信；</p></li><br></ol>


<p>有个常见的问题，关于随机数为什么要三个？只最后一个随机数N3不可以么？</p>

<p>这是由于SSL/TLS设计，就假设服务器不相信所有的客户端都能够提供完全随机数，假如某个客户端提供的随机数不随机的话，就大大增加了“对话密钥”被破解的风险，所以由三组随机数组成最后的随机数，保证了随机数的随机性，以此来保证每次生成的“对话密钥”安全性。</p>

<p><br><br></p>

<h2><a href="http://en.wikipedia.org/wiki/Public_key_certificate" target="_blank" rel="external">数字证书</a></h2>

<p>数字证书是一个电子文档，其中包含了持有者的信息、公钥以及证明该证书有效的数字签名。而数字证书以及相关的公钥管理和验证等技术组成了<a href="http://en.wikipedia.org/wiki/Public-key_infrastructure" target="_blank" rel="external">PKI</a>（公钥基础设施）规范体系。一般来说，数字证书是由数字证书认证机构(Certificate authority，即CA)来负责签发和管理，并承担PKI体系中公钥合法性的检验责任；数字证书的类型有很多，而HTTPS使用的是SSL证书。</p>

<p>怎么来验证数字证书是由CA签发的，而不是第三方伪造的呢？<br>在回答这个问题前，我们需要先了解CA的组织结构。首先，CA组织结构中，最顶层的就是根CA，根CA下可以授权给多个二级CA，而二级CA又可以授权多个三级CA，所以CA的组织结构是一个树结构。对于SSL证书市场来说，主要被Symantec(旗下有VeriSign和GeoTrust)、Comodo SSL、Go Daddy 和 GlobalSign 瓜分。<br>了解了CA的组织结构后，来看看数字证书的签发流程：</p>

<p><br><br><img src="/image/ios91.png" alt="数字证书的签发流程"><br><br></p>

<p>数字证书的签发机构CA，在接收到申请者的资料后进行核对并确定信息的真实有效，然后就会制作一份符合<a href="http://tools.ietf.org/html/rfc5280" target="_blank" rel="external">X.509</a>标准的文件。证书中的证书内容包含的持有者信息和公钥等都是由申请者提供的，而数字签名则是CA机构对证书内容进行hash加密后得到的，而这个数字签名就是我们验证证书是否是有可信CA签发的数据。</p>

<p><br><br><img src="/image/ios92.png" alt="数字证书的验证流程"><br><br></p>

<p>假设上图证书是由证书签发机构CA1签发的。</p>

<p>1）接收端接到一份数字证书Cer1后，对证书的内容做Hash得到H1；</p>

<p>2）从签发该证书的机构CA1的数字证书中找到公钥，对证书上数字签名进行解密，得到证书Cer1签名的Hash摘要H2；</p>

<p>3）对比H1和H2，如相等，则表示证书没有被篡改。</p>

<p>4）但这个时候还是不知道CA是否是合法的，我们看到上图中有CA机构的数字证书，这个证书是公开的，所有人都可以获取到。而这个证书中的数字签名是上一级生成的，所以可以这样一直递归验证下去，直到根CA。根CA是自验证的，即他的数字签名是由自己的私钥来生成的。合法的根CA会被浏览器和操作系统加入到权威信任CA列表中，这样就完成了最终的验证。所以，一定要保护好自己环境（浏览器/操作系统）中根CA信任列表，信任了根CA就表示信任所有根CA下所有子级CA所签发的证书，不要随便添加根CA证书。</p>

<p>一般操作系统和浏览器只包含根CA机构的证书，而在配置Web服务器的HTTPS时，也会将配置整个证书链，所以整个校验流程是从最后的叶子节点证书开始，用父节点校验子节点，一层层校验整个证书链的可信性。</p>

<p>打个比喻：父（根CA数字证书）-子（CA数字证书）-孙（数字证书）三代人，假设父没有其他兄弟（相当于根CA机构是唯一的），假如子与父进行DNA亲子鉴定，检测DNA位点（即证书签名）相同，那就基本确定子是由父所生；孙与子一样。这样就能够确定孙肯定是源于父一脉，是父（根CA数字证书）的合法继承人。数字证书的验证就是基于同样的原理。</p>

<p><br><br></p>

<h2><a href="https://tools.ietf.org/html/rfc5280#section-4.2.1.9" target="_blank" rel="external">Basic Constraint</a>校验漏洞</h2>

<p>那是否不管多少层都可以这样一直信任下去呢？理论上是可行的，但会遇到一个问题。假设我从可信CA机构购买了一张证书，使用这张证书签发的证书是否也会被操作系统和浏览器信任呢？明显是不应该相信的，因为我并不是CA机构，假如我签发的证书也被信任的话，那我完全可以自己签发任何域名的证书来进行伪造攻击。这就是著名的<a href="https://tools.ietf.org/html/rfc5280#section-4.2.1.9" target="_blank" rel="external">Basic Constraint</a>校验漏洞，X.509证书中的Basic Constraint包含了这是不是一个CA机构，以及有效证书路径的最大深度（即，这个CA还能否继续签发CA机构证书及其签发子CA证书的路径深度）。但在几年前，包括微软和Apple都爆出了没有正确校验这些信息的漏洞。</p>

<p>Basic Constraint信息请看下图：</p>

<p><br><br><img src="/image/ios93.png" alt="Google Internet Authority G2"></p>

<p>上图是Google Internet Authority G2的证书，该证书是个CA机构证书；路径深度为0，表示该证书无法再签发CA证书，只能签发客户证书(client certificate)。</p>

<p><br><br><img src="/image/ios94.png" alt="google.com"></p>

<p>上图是google.com的证书，这是个客户证书(client certificate)，不可再签发子证书，所以由该证书签发的子证书是不会被信任的。</p>

<p>了解了上面关于SSL/TSL通信加密策略以及数字证书的概念之后，对HTTPS的安全机制就有了个初步的了解，下面我们看如何在iOS上实现对HTTPS的支持。</p>

<p><br><br></p>

<h1>2. 实现支持HTTPS</h1>

<p>首先，需要明确你使用HTTP/HTTPS的用途，因为OSX和iOS平台提供了多种API，来支持不同的用途，官方文档<a href="https://developer.apple.com/library/ios/documentation/NetworkingInternetWeb/Conceptual/NetworkingOverview/WorkingWithHTTPAndHTTPSRequests/WorkingWithHTTPAndHTTPSRequests.html" target="_blank" rel="external">《Making HTTP and HTTPS Requests》</a>有详细的说明，而文档<a href="https://developer.apple.com/library/ios/technotes/tn2232/_index.html" target="_blank" rel="external">《HTTPS Server Trust Evaluation》</a>则详细讲解了HTTPS验证相关知识，这里就不多说了。本文主要讲解我们最常用的NSURLConnection支持HTTPS的实现（NSURLSession的实现方法类似，只是要求授权证明的回调不一样而已），以及怎么样使用AFNetworking这个非常流行的第三方库来支持HTTPS。本文假设你对HTTP以及NSURLConnection的接口有了足够的了解。</p>

<p><br></p>

<h2>验证证书的API</h2>

<p>相关的Api在<a href="https://developer.apple.com/library/ios/documentation/Security/Reference/SecurityFrameworkReference/_index.html" target="_blank" rel="external">Security Framework</a>中，验证流程如下：</p>

<p>1). 第一步，先获取需要验证的信任对象(Trust Object)。这个Trust Object在不同的应用场景下获取的方式都不一样，对于NSURLConnection来说，是从delegate方法<code>-connection:willSendRequestForAuthenticationChallenge:</code>回调回来的参数challenge中获取(<code>[challenge.protectionSpace serverTrust]</code>)。</p>

<p>2). 使用系统默认验证方式验证Trust Object。<a href="https://developer.apple.com/library/ios/documentation/Security/Reference/certifkeytrustservices/#//apple_ref/c/func/SecTrustEvaluate" target="_blank" rel="external"><code>SecTrustEvaluate</code></a>会根据Trust Object的验证策略，一级一级往上，验证证书链上每一级数字签名的有效性（上一部分有讲解），从而评估证书的有效性。</p>

<p>3). 如第二步验证通过了，一般的安全要求下，就可以直接验证通过，进入到下一步：使用Trust Object生成一份凭证(<code>[NSURLCredential credentialForTrust:serverTrust]</code>)，传入challenge的sender中(<code>[challenge.sender useCredential:cred forAuthenticationChallenge:challenge]</code>)处理，建立连接。</p>

<p>4). 假如有更强的安全要求，可以继续对Trust Object进行更严格的验证。常用的方式是在本地导入证书，验证Trust Object与导入的证书是否匹配。更多的方法可以查看<a href="https://developer.apple.com/library/ios/technotes/tn2232/_index.html#//apple_ref/doc/uid/DTS40012884-CH1-SECSTRICTER" target="_blank" rel="external">Enforcing Stricter Server Trust Evaluation</a>，这一部分在讲解AFNetworking源码中会讲解到。</p>

<p>5). 假如验证失败，取消此次<a href="http://en.wikipedia.org/wiki/Challenge%E2%80%93response_authentication" target="_blank" rel="external">Challenge-Response Authentication</a>验证流程，拒绝连接请求。</p>

<p>ps: 假如是自建证书的，则不使用第二步系统默认的验证方式，因为自建证书的根CA的数字签名未在操作系统的信任列表中。</p>

<p>iOS授权验证的API和流程大概了解了，下面，我们看看在NSURLConnection中的代码实现：</p>

<p><br></p>

<h2>使用NSURLConnection支持HTTPS的实现</h2>

<p><br></p>

<div class="highlight"><pre><code class="language-objective-c" data-lang="objective-c"><span class="c1">// Now start the connection</span><br><span class="bp">NSURL</span> <span class="o"><em></em></span> <span class="n">httpsURL</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSURL</span> <span class="nl">URLWithString</span><span class="p">:</span><span class="s">@&quot;<a href="https://www.google.com&amp;quot" target="_blank" rel="external">https://www.google.com&amp;quot</a>;</span><span class="p">];</span><br><span class="nb">self</span><span class="p">.</span><span class="n">connection</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSURLConnection</span> <span class="nl">connectionWithRequest</span><span class="p">:[</span><span class="bp">NSURLRequest</span> <span class="nl">requestWithURL</span><span class="p">:</span><span class="n">httpsURL</span><span class="p">]</span> <span class="nl">delegate</span><span class="p">:</span><span class="nb">self</span><span class="p">];</span><br><br><br><span class="c1">//回调</span><br><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">connection:</span><span class="p">(</span><span class="bp">NSURLConnection</span> <span class="o"></span><span class="p">)</span><span class="nv">connection</span> <span class="nf">willSendRequestForAuthenticationChallenge:</span><span class="p">(</span><span class="bp">NSURLAuthenticationChallenge</span> <span class="o"><em></em></span><span class="p">)</span><span class="nv">challenge</span> <span class="p">{</span><br>    <span class="c1">//1)获取trust object</span><br>    <span class="n">SecTrustRef</span> <span class="n">trust</span> <span class="o">=</span> <span class="n">challenge</span><span class="p">.</span><span class="n">protectionSpace</span><span class="p">.</span><span class="n">serverTrust</span><span class="p">;</span><br>    <span class="n">SecTrustResultType</span> <span class="n">result</span><span class="p">;</span><br><br>    <span class="c1">//2)SecTrustEvaluate对trust进行验证</span><br>    <span class="n">OSStatus</span> <span class="n">status</span> <span class="o">=</span> <span class="n">SecTrustEvaluate</span><span class="p">(</span><span class="n">trust</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">result</span><span class="p">);</span><br>    <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">errSecSuccess</span> <span class="o">&amp;&amp;</span><br>        <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">kSecTrustResultProceed</span> <span class="o">||</span><br>        <span class="n">result</span> <span class="o">==</span> <span class="n">kSecTrustResultUnspecified</span><span class="p">))</span> <span class="p">{</span><br><br>        <span class="c1">//3)验证成功，生成NSURLCredential凭证cred，告知challenge的sender使用这个凭证来继续连接</span><br>        <span class="bp">NSURLCredential</span> <span class="o"></span><span class="n">cred</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSURLCredential</span> <span class="nl">credentialForTrust</span><span class="p">:</span><span class="n">trust</span><span class="p">];</span><br>        <span class="p">[</span><span class="n">challenge</span><span class="p">.</span><span class="n">sender</span> <span class="nl">useCredential</span><span class="p">:</span><span class="n">cred</span> <span class="nl">forAuthenticationChallenge</span><span class="p">:</span><span class="n">challenge</span><span class="p">];</span><br><br>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span><br><br>        <span class="c1">//5)验证失败，取消这次验证流程</span><br>        <span class="p">[</span><span class="n">challenge</span><span class="p">.</span><span class="n">sender</span> <span class="nl">cancelAuthenticationChallenge</span><span class="p">:</span><span class="n">challenge</span><span class="p">];</span><br><br>  <span class="p">}</span><br><span class="p">}</span></code></pre></div>


<p><br></p>

<p>上面是代码是通过系统默认验证流程来验证证书的。假如我们是自建证书的呢？这样Trust Object里面服务器的证书因为不是可信任的CA签发的，所以直接使用<code>SecTrustEvaluate</code>进行验证是不会成功。又或者，即使服务器返回的证书是信任CA签发的，又如何确定这证书就是我们想要的特定证书？这就需要先在本地导入证书，设置成需要参与验证的<a href="https://en.wikipedia.org/wiki/Trust_anchor" target="_blank" rel="external">Anchor Certificate</a>（锚点证书，通过<code>SecTrustSetAnchorCertificates</code>设置了参与校验锚点证书之后，假如验证的数字证书是这个锚点证书的子节点，即验证的数字证书是由锚点证书对应CA或子CA签发的，或是该证书本身，则信任该证书），再调用<code>SecTrustEvaluate</code>来验证。代码如下</p>

<p><br></p>

<div class="highlight"><pre><code class="language-objective-c" data-lang="objective-c"><span class="c1">//先导入证书</span><br><span class="bp">NSString</span> <span class="o"><em></em></span> <span class="n">cerPath</span> <span class="o">=</span> <span class="p">…;</span> <span class="c1">//证书的路径</span><br><span class="bp">NSData</span> <span class="o"></span> <span class="n">cerData</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSData</span> <span class="nl">dataWithContentsOfFile</span><span class="p">:</span><span class="n">cerPath</span><span class="p">];</span><br><span class="n">SecCertificateRef</span> <span class="n">certificate</span> <span class="o">=</span> <span class="n">SecCertificateCreateWithData</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="p">(</span><span class="k"><strong>bridge</strong></span> <span class="n">CFDataRef</span><span class="p">)(</span><span class="n">cerData</span><span class="p">));</span><br><span class="nb">self</span><span class="p">.</span><span class="n">trustedCertificates</span> <span class="o">=</span> <span class="l">@[</span><span class="n">CFBridgingRelease</span><span class="p">(</span><span class="n">certificate</span><span class="p">)</span><span class="l">]</span><span class="p">;</span><br><br><span class="c1">//回调</span><br><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">connection:</span><span class="p">(</span><span class="bp">NSURLConnection</span> <span class="o"><em></em></span><span class="p">)</span><span class="nv">connection</span> <span class="nf">willSendRequestForAuthenticationChallenge:</span><span class="p">(</span><span class="bp">NSURLAuthenticationChallenge</span> <span class="o"></span><span class="p">)</span><span class="nv">challenge</span> <span class="p">{</span><br>    <span class="c1">//1)获取trust object</span><br>    <span class="n">SecTrustRef</span> <span class="n">trust</span> <span class="o">=</span> <span class="n">challenge</span><span class="p">.</span><span class="n">protectionSpace</span><span class="p">.</span><span class="n">serverTrust</span><span class="p">;</span><br>    <span class="n">SecTrustResultType</span> <span class="n">result</span><span class="p">;</span><br><br>    <span class="c1">//注意：这里将之前导入的证书设置成下面验证的Trust Object的anchor certificate</span><br>    <span class="n">SecTrustSetAnchorCertificates</span><span class="p">(</span><span class="n">trust</span><span class="p">,</span> <span class="p">(</span><span class="k">bridge</span> <span class="n">CFArrayRef</span><span class="p">)</span><span class="nb">self</span><span class="p">.</span><span class="n">trustedCertificates</span><span class="p">);</span><br><br>    <span class="c1">//2)SecTrustEvaluate会查找前面SecTrustSetAnchorCertificates设置的证书或者系统默认提供的证书，对trust进行验证</span><br>    <span class="n">OSStatus</span> <span class="n">status</span> <span class="o">=</span> <span class="n">SecTrustEvaluate</span><span class="p">(</span><span class="n">trust</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">result</span><span class="p">);</span><br>    <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">errSecSuccess</span> <span class="o">&amp;&amp;</span><br>        <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">kSecTrustResultProceed</span> <span class="o">||</span><br>        <span class="n">result</span> <span class="o">==</span> <span class="n">kSecTrustResultUnspecified</span><span class="p">))</span> <span class="p">{</span><br><br>        <span class="c1">//3)验证成功，生成NSURLCredential凭证cred，告知challenge的sender使用这个凭证来继续连接</span><br>        <span class="bp">NSURLCredential</span> <span class="o">*</span><span class="n">cred</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSURLCredential</span> <span class="nl">credentialForTrust</span><span class="p">:</span><span class="n">trust</span><span class="p">];</span><br>        <span class="p">[</span><span class="n">challenge</span><span class="p">.</span><span class="n">sender</span> <span class="nl">useCredential</span><span class="p">:</span><span class="n">cred</span> <span class="nl">forAuthenticationChallenge</span><span class="p">:</span><span class="n">challenge</span><span class="p">];</span><br><br>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span><br><br>        <span class="c1">//5)验证失败，取消这次验证流程</span><br>        <span class="p">[</span><span class="n">challenge</span><span class="p">.</span><span class="n">sender</span> <span class="nl">cancelAuthenticationChallenge</span><span class="p">:</span><span class="n">challenge</span><span class="p">];</span><br><br>  <span class="p">}</span><br><span class="p">}</span></code></pre></div>


<p><br></p>

<p>建议采用本地导入证书的方式验证证书，来保证足够的安全性。更多的验证方法，请查看官方文档<a href="https://developer.apple.com/library/ios/technotes/tn2232/_index.html" target="_blank" rel="external">《HTTPS Server Trust Evaluation》</a></p>

<p><br></p>

<h2>使用AFNetworking来支持HTTPS</h2>

<p><a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="external">AFNetworking</a>是iOS/OSX开发最流行的第三方开源库之一，其作者是非常著名的iOS/OSX开发者<a href="https://github.com/mattt" target="_blank" rel="external">Mattt Thompson</a>，其博客<a href="http://nshipster.com/" target="_blank" rel="external">NSHipster</a>也是iOS/OSX开发者学习和开阔技术视野的好地方。AFNetworking已经将上面的逻辑代码封装好，甚至更完善，在AFSecurityPolicy文件中，有兴趣可以阅读这个模块的代码；</p>

<p>AFNetworking上配置对HTTPS的支持非常简单：</p>

<p><br></p>

<div class="highlight"><pre><code class="language-objective-c" data-lang="objective-c"><span class="bp">NSURL</span> <span class="o"><em></em></span> <span class="n">url</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSURL</span> <span class="nl">URLWithString</span><span class="p">:</span><span class="s">@&quot;<a href="https://www.google.com&amp;quot" target="_blank" rel="external">https://www.google.com&amp;quot</a>;</span><span class="p">];</span><br><span class="n">AFHTTPRequestOperationManager</span> <span class="o"></span> <span class="n">requestOperationManager</span> <span class="o">=</span> <span class="p">[[</span><span class="n">AFHTTPRequestOperationManager</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithBaseURL</span><span class="p">:</span><span class="n">url</span><span class="p">];</span><br><span class="kt">dispatch_queue_t</span> <span class="n">requestQueue</span> <span class="o">=</span> <span class="n">dispatch_create_serial_queue_for_name</span><span class="p">(</span><span class="s">&quot;kRequestCompletionQueue&quot;</span><span class="p">);</span><br><span class="n">requestOperationManager</span><span class="p">.</span><span class="n">completionQueue</span> <span class="o">=</span> <span class="n">requestQueue</span><span class="p">;</span><br><br><span class="n">AFSecurityPolicy</span> <span class="o"><em></em></span> <span class="n">securityPolicy</span> <span class="o">=</span> <span class="p">[</span><span class="n">AFSecurityPolicy</span> <span class="nl">policyWithPinningMode</span><span class="p">:</span><span class="n">AFSSLPinningModeCertificate</span><span class="p">];</span><br><br><span class="c1">//allowInvalidCertificates 是否允许无效证书（也就是自建的证书），默认为NO</span><br><span class="c1">//如果是需要验证自建证书，需要设置为YES</span><br><span class="n">securityPolicy</span><span class="p">.</span><span class="n">allowInvalidCertificates</span> <span class="o">=</span> <span class="nb">YES</span><span class="p">;</span><br><br><span class="c1">//validatesDomainName 是否需要验证域名，默认为YES；</span><br><span class="c1">//假如证书的域名与你请求的域名不一致，需把该项设置为NO；如设成NO的话，即服务器使用其他可信任机构颁发的证书，也可以建立连接，这个非常危险，建议打开。</span><br><span class="c1">//置为NO，主要用于这种情况：客户端请求的是子域名，而证书上的是另外一个域名。因为SSL证书上的域名是独立的，假如证书上注册的域名是www.google.com，那么mail.google.com是无法验证通过的；当然，有钱可以注册通配符的域名.google.com，但这个还是比较贵的。</span><br><span class="c1">//如置为NO，建议自己添加对应域名的校验逻辑。</span><br><span class="n">securityPolicy</span><span class="p">.</span><span class="n">validatesDomainName</span> <span class="o">=</span> <span class="nb">YES</span><span class="p">;</span><br><br><span class="c1">//validatesCertificateChain 是否验证整个证书链，默认为YES</span><br><span class="c1">//设置为YES，会将服务器返回的Trust Object上的证书链与本地导入的证书进行对比，这就意味着，假如你的证书链是这样的：</span><br><span class="c1">//GeoTrust Global CA </span><br><span class="c1">//    Google Internet Authority G2</span><br><span class="c1">//        <em>.google.com</em></span><br><span class="c1">//那么，除了导入.google.com之外，还需要导入证书链上所有的CA证书（GeoTrust Global CA, Google Internet Authority G2）；</span><br><span class="c1">//如是自建证书的时候，可以设置为YES，增强安全性；假如是信任的CA所签发的证书，则建议关闭该验证，因为整个证书链一一比对是完全没有必要（请查看源代码）；</span><br><span class="n">securityPolicy</span><span class="p">.</span><span class="n">validatesCertificateChain</span> <span class="o">=</span> <span class="nb">NO</span><span class="p">;</span><br><br><span class="n">requestOperationManager</span><span class="p">.</span><span class="n">securityPolicy</span> <span class="o">=</span> <span class="n">securityPolicy</span><span class="p">;</span></code></pre></div>


<p><br></p>

<p>这就是AFNetworking的支持HTTPS的主要配置说明，AFHTTPSessionManager与之基本一致，就不重复了。</p>

<p><br><br></p>

<h1>3. 总结</h1>

<p>虽然HTTPS相比于HTTP来说，会有一定的性能上的劣势，但对于网络飞速发展，移动设备的性能成倍增长的今天，安全才是我们更应该去考虑的。全网HTTPS并不是那么遥远。</p>



<p><br><br></p>

<hr>

<p>本文转载自<a href="http://oncenote.com/" target="_blank" rel="external">Jaminzzhang</a>Blog</p>]]></content>
    <summary type="html">
    <![CDATA[<p>如何打造一个安全的App？这是每一个移动开发者必须面对的问题。在移动App开发领域，开发工程师对于安全方面的考虑普遍比较欠缺，而由于iOS平台的封闭性，遭遇到的安全问题相比于Android来说要少得多，这就导致了许多iOS开发人员对于安全性方面没有太多的深入，但对于一个合格的软件开发者来说，安全知识是必备知识之一。</p><br>]]>
    
    </summary>
    
      <category term="HTTPS" scheme="http://yimouleng.com/tags/HTTPS/"/>
    
      <category term="IOS 9" scheme="http://yimouleng.com/tags/IOS-9/"/>
    
      <category term="iOS开发" scheme="http://yimouleng.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS开发 - 开门/撕裂效果-基于PortalTransition修改撕裂动画]]></title>
    <link href="http://yimouleng.com/2015/09/30/ios-PortalTransition/"/>
    <id>http://yimouleng.com/2015/09/30/ios-PortalTransition/</id>
    <published>2015-09-29T16:00:00.000Z</published>
    <updated>2015-12-09T09:41:40.000Z</updated>
    <content type="html"><![CDATA[<h1 id="u6548_u679C_u8D77_u56E0"><a href="#u6548_u679C_u8D77_u56E0" class="headerlink" title="效果起因"></a>效果起因</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">公司项目， 因看到韩国的 <span class="number">29</span>cm APP，  其中的分享效果非常的漂亮，使用起来也是很方便， 便准备进行实现。</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="u6548_u679C_u4E00"><a href="#u6548_u679C_u4E00" class="headerlink" title="效果一"></a>效果一</h3><p>在网上有很多撕裂效果的demo， 其中找到一份并加以修改，<br>demo地址<a href="https://github.com/yimouleng/Door-effect-tear-effect" target="_blank" rel="external">https://github.com/yimouleng/Door-effect-tear-effect</a></p>
<p>但效果并不理想，虽然能够完成，但是动画等地方不完美，与29cm差别也很大，所以没有使用，但是有需要的同学可以下载看看。</p>
<h3 id="u6548_u679C_u4E8C"><a href="#u6548_u679C_u4E8C" class="headerlink" title="效果二"></a>效果二</h3><p>这是偶然在一篇文章里面看到的， 地址我忘了， 项目名称 <a href="https://github.com/machackx/PortalTransition" target="_blank" rel="external">PortalTransition</a><br>借鉴了苹果Keynote的动画，支持水平和垂直两个方向。</p>
<p>垂直方向：<br><img src="http://img.ceyang.me/portrait.gif" alt=""></p>
<p>水平方向：<br><img src="http://img.ceyang.me/landscape.gif" alt=""></p>
<p>效果比刚才的1中更贴近29cm中的效果，使用起来也会更加流畅。但是和我想要的效果还有些差距， 比如只是撕裂，没有合并。</p>
<h3 id="u6548_u679C_u4E09__uFF08_u6700_u7EC8_uFF09"><a href="#u6548_u679C_u4E09__uFF08_u6700_u7EC8_uFF09" class="headerlink" title="效果三 （最终）"></a>效果三 （最终）</h3><p>这是基于PortalTransition 所修改的 ，支持的闭合，  但是没有去掉撕裂时候的下面的投影，因为项目后背景是黑色并没有影响，若是需要请自行去掉，原项目支持横竖屏，修改后未测试是否依然支持。</p>
<p>项目地址： <a href="https://github.com/yimouleng/MTPortalTransition" target="_blank" rel="external">https://github.com/yimouleng/MTPortalTransition</a></p>
<p>效果图：<br><img src="https://raw.githubusercontent.com/yimouleng/MTPortalTransition/master/2015-11-05%2015_07_57.gif" alt=""></p>
<p>使用方法和PortalTransition是一样的， 请到<a href="https://github.com/machackx/PortalTransition" target="_blank" rel="external">PortalTransition</a>去看使用方法。<br>修改的地方若有问题，<a href="https://github.com/yimouleng" target="_blank" rel="external">请联系我</a>，若有更好的方法和修改，也希望同学们能够分享出来。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u6548_u679C_u8D77_u56E0"><a href="#u6548_u679C_u8D77_u56E0" class="headerlink" title="效果起因"></a>效果起因</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">公司项目， 因看到韩国的 <span class="number">29</span>cm APP，  其中的分享效果非常的漂亮，使用起来也是很方便， 便准备进行实现。</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="撕裂效果" scheme="http://yimouleng.com/tags/%E6%92%95%E8%A3%82%E6%95%88%E6%9E%9C/"/>
    
      <category term="iOS开发" scheme="http://yimouleng.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ASIHTTPRequest, AFNetworking, MKNetworkingKit网络框架get和post请求]]></title>
    <link href="http://yimouleng.com/2015/07/21/ASIHTTPRequest-AFNetworking-MKNetworkingKit/"/>
    <id>http://yimouleng.com/2015/07/21/ASIHTTPRequest-AFNetworking-MKNetworkingKit/</id>
    <published>2015-07-20T16:00:00.000Z</published>
    <updated>2015-12-09T11:26:19.000Z</updated>
    <content type="html"><![CDATA[<p>ASIHTTPRequest, AFNetworking, MKNetworkingKit网络框架get和post请求</p>
<a id="more"></a>
<p></p><h1>目录</h1><p></p>
<p></p><h3>一. 用第三方库实现get请求</h3><p></p>
<p></p><h6>1. ASI</h6><p></p>
<p></p><h6>2. AFNetworking</h6><p></p>
<p></p><h3>二. Post请求的实现</h3><p></p>
<p></p><h6>1. NSURLConnection</h6><p></p>
<p></p><h6>2. ASI</h6><p></p>
<p></p><h6>3. AFNetworking</h6><p></p>
<p></p><h3>三. 使用MKNetworkingKit实现get和Post</h3><p></p>
<p></p><h6>1. get请求</h6><p></p>
<p></p><h6>2. Post请求</h6><br><p></p>
<hr>

<p></p><h2>一. 用第三方库实现get请求</h2><p></p>
<p><blockquote></blockquote></p>
<p></p><p>ASI  </p><p></p>
<p><ol></ol></p>
<p><li>ASI是较老的第三方库, 功能非常强大, 可以实现get/post请求, 实现数据的缓存, 实现断点续传功能  </li></p>
<p><li>由于ASI不支持ARC, 并且ASI库的作者已经不再维护这个工程, 所有支持ARC的功能没有实现, 一般新的项目不推荐使用  </li></p>
<p><li>ASIHttpRequest: ASI最主要的一个类, 这个类是继承于NSOperation    </li><br></p>
<p></p><p>AFNetworking  </p><p></p>
<p><ol></ol></p>
<p><li>AFNetworking是iOS6之后的网络请求库, 能够实现get/post请求, 可以实现断点续传等功能  </li></p>
<p><li>AFNetworking使用简单, 支持ARC, 一般新的工程都会使用其进行</li><br><br></p>
<p></p><h5>1. ASI实现get请求的使用步骤</h5><p></p>
<p><blockquote><ol></ol></blockquote></p>
<p><li>导入ASI第三方库</li></p>
<p><li>设置为-fno-objc-arc</li></p>
<p><li>添加系统库文件<ol></ol></li></p>
<p><li>SystemConfiguration,</li></p>
<p><li>CFNetwork,</li></p>
<p><li>MobileCoreServices  </li></p>
<p><li>libz.1.1.3.dylib    </li><br><br></p>
<p><li>导入头文件使用   <pre><code>1. 创建ASIHttpRequest对象  </code></pre></li></p>
<ol>
<li>设置代理, 遵守协议  </li>
<li><p>发送请求(异步请求)<br></p></li><br></ol><br><ol><br><li><br><p>代码         </p><br><pre><code>    ASIHTTPRequest *request = [ASIHTTPRequest requestWithURL:[NSURL URLWithString:@”<a href="http://api.chengmi.com/shindex?passdate=20150108&amp;curlng=121.5093155189223&amp;curlat=31.27483773025054" target="_blank" rel="external">http://api.chengmi.com/shindex?passdate=20150108&amp;curlng=121.5093155189223&amp;curlat=31.27483773025054</a>“]];<br> request. delegate = self;<br> [request startAsynchronous];</code></pre><br></li><br><li><br><p>ASIHttpRequest代理方法    </p><br><pre><code> // 下载失败时调用<p></p>
<ul>
<li>(void)requestFailed:(ASIHTTPRequest *)request<br>{<br>NSLog(@”%s”, <strong>func</strong>);<br>}</li>
</ul>
<p>// 下载结束后调用</p>
<ul>
<li><p>(void)requestFinished:(ASIHTTPRequest *)request<br>{<br>// request.responseData存储下载回来的二进制数据</p>
<p>// JSON解析<br>id result = [NSJSONSerialization JSONObjectWithData:request.responseData options:NSJSONReadingMutableContainers error:nil];  </p>
</li>
</ul>
<p>…………………………………………………………………………………………<br>}</p></code></pre><br></li><br><li><br><p>常规流程: 创建数据源和表格视图, 实现表格视图代理方法    </p><br></li><br></ol><br><hr><br><h5>2. AFNetworking</h5><br><blockquote><ol><br><li>导入AFNetworking库文件</li><br><li>导入头文件使用<ol><br><li>创建”AFHTTPRequestOperationManager”类型的对象</li><br><li>设置返回值的解析方式(二进制)<br>manager.responseSerializer = [AFHTTPResponseSerializer serializer];</li><br><li>发送请求<br>第一个参数: 请求的url字符串<br>第二个参数: 附加的参数(传nil)<br>第三个参数: 请求成功返回时调用的代码块(block)<br>第四个参数: 请求失败时调用的代码块</li><br></ol><br></li><br><li>注意的两点<ol><br><li>block代码块的执行是异步的</li><br><li>block里面的变量通常会拷贝, 所以里面使用self指向的视图控制器对象时, 通常使用弱引用, 否则会有内存泄露</li><br></ol><br></li><br></ol></blockquote><br><ol><br><li><br><p>用AFNetworking实现get请求  </p><br><pre><code> - (void)downloadData<br>{<br>  // 1. 导入AFNetworking库文件<br>  // 2. 导入头文件使用<br>  // 1) 创建”AFHTTPRequestOperationManager”类型的对象<br>  AFHTTPRequestOperationManager *manager = [[AFHTTPRequestOperationManager alloc] init];<p></p>
<p>  // 2) 设置返回值的解析方式(二进制)<br>  manager.responseSerializer = [AFHTTPResponseSerializer serializer];</p>
<p>  // 3) 发送请求<br>  /<em><br>   第一个参数: 请求的url字符串<br>   第二个参数: 附加的参数(传nil)<br>   第三个参数: 请求成功返回时调用的代码块(block)<br>   第四个参数: 请求失败时调用的代码块
   </em>/</p>
<p>  // 4) 注意的两点<br>  // 1. block代码块的执行是异步的<br>  // 2. block里面的变量通常会拷贝, 所以里面使用self指向的视图控制器对象时, 通常使用弱引用, 否则会有内存泄露</p>
<p>   __weak ViewController <em>weakSelf = self;<br>  [manager GET:@”<a href="http://api.chengmi.com/shindex?passdate=20150108&amp;curlng=121.5093155189223&amp;curlat=31.27483773025054" target="_blank" rel="external">http://api.chengmi.com/shindex?passdate=20150108&amp;curlng=121.5093155189223&amp;curlat=31.27483773025054</a>“ parameters:nil success:^(AFHTTPRequestOperation </em>operation, id responseObject) {</p>
<pre><code>// responseObject 存储了下载回来的数据
// JSON解析
id result = [NSJSONSerialization JSONObjectWithData:responseObject options:NSJSONReadingMutableContainers error:nil];
if ([result isKindOfClass:[NSDictionary class]]) {
    NSDictionary *dict = result;
    for (NSDictionary *sectionDict in dict[@&quot;sectioninfo&quot;]) {
        DataModel *model = [[DataModel alloc] init];
        [model setValuesForKeysWithDictionary:sectionDict];
        [weakSelf.dataArray addObject:model];
    }
    [weakSelf.tableView reloadData];
}
</code></pre><p>  } failure:^(AFHTTPRequestOperation <em>operation, NSError </em>error) {</p>
<pre><code>NSLog(@&quot;error:%@&quot;, error);
</code></pre><p>  }];<br>}</p></code></pre><br></li><br><li><br><p>常规流程: 创建数据源和表格视图, 调用下载数据方法, 实现表格视图代理方法     </p><br></li><br></ol><br><hr><br><h2>二. Post请求的实现</h2><br><blockquote><p>post请求: 参数不放在url字符串里面, 而是放在请求体里面, 安全性比较高, 而且传递的参数数据量会比较大<br>post请求不能直接在浏览器访问  </p></blockquote><br><h5>1. 使用系统的NSURLConnection完成Post请求</h5><br><blockquote><ol><br><li>创建NSURL类型对象  </li><br><li>创建NSMutableURLRequest类型对象, 设置对象的属性  <ol><br><li>设置请求体    </li><br><li>设置请求方式  </li><br><li>设置请求参数的大小  </li><br></ol><br></li><br><li>发送请求</li><br></ol></blockquote><br><ol><br><li><br><p>downloadData方法  </p><br><pre><code> - (void)downloadData<br>{<p></p>
<pre><code>// 1. 创建NSURL类型对象
</code></pre><p>  NSURL <em>url = [NSURL URLWithString:@”<a href="http://services.xingshulin.com/ApricotForestWirelessServiceForLiterature/LiteratureDataServlet" target="_blank" rel="external">http://services.xingshulin.com/ApricotForestWirelessServiceForLiterature/LiteratureDataServlet</a>“];<br>  // 2. 创建NSMutableURLRequest类型对象<br>  NSMutableURLRequest </em>request = [[NSMutableURLRequest alloc] initWithURL:url];<br>  NSString <em>param = @”sessionKey=7B63373363386530373034366164393262633633373039326138356238366366307D2C7B336464363563386338626263653130663531623832616632343963363832323065363964656161627D2C7B66616C73657D2C7B307D2C7B307D2C7B66373539333863642D326162352D346232342D616336622D3132386538626434663366397D2C7B37363033396665333533326461623034656561353162363734643131636532617D2C7B323031352D30332D30372031313A31383A33337D2C7B312E382E367D2C7B696F736C6974657261747572657D2C7B494F536C6974657261747572655F312E382E365F696F73382E312E335F6950686F6E65352D327D&amp;pageSize=10&amp;rtype=2&amp;pageIndex=0&amp;m=getLiteraturegroupBySpecialty”;<br>  // 转化为二进制数据<br>  NSData </em>paramData = [param dataUsingEncoding:NSUTF8StringEncoding];</p>
<p>  // 1) 设置请求体<br>  [request setHTTPBody:paramData];</p>
<p>  // 2) 设置请求方式<br>  [request setHTTPMethod:@”post”];</p>
<p>  // 3) 设置请求参数的大小<br>  NSString *lengthStr = [NSString stringWithFormat:@”%ld”, paramData.length];<br>  [request setValue:lengthStr forHTTPHeaderField:@”content-length”];</p>
<p>  // 4) 设置类型<br>  [request setValue:@”application/x-www-form-urlencoded” forHTTPHeaderField:@”content-type”];</p>
<p>  // 3.发送请求<br>  _connection = [[NSURLConnection alloc] initWithRequest:request delegate:self];<br>}</p></code></pre><br></li><br><li><br><p>创建数据源和表格视图, 实现NSURLConnection代理方法和表格视图代理方法</p><br></li><br></ol><br><hr><br><h5>2. 使用第三方库ASI完成Post请求</h5><br><ol><br><li><br><p>使用ASI进行Post请求</p><br><pre><code> - (void)downloadData<br>{<br>  // 1. 导入ASI第三方库<br>  // 2. 添加编译属性-fno-objc-arc<br>  // 3. 添加系统库<br>  // 4. 导入头文件<br>  // 1)<br>  ASIFormDataRequest <em>request = [ASIFormDataRequest requestWithURL:[NSURL URLWithString:@”<a href="http://services.xingshulin.com/ApricotForestWirelessServiceForLiterature/LiteratureDataServlet" target="_blank" rel="external">http://services.xingshulin.com/ApricotForestWirelessServiceForLiterature/LiteratureDataServlet</a>“]];<br>  // 2) 设置代理<br>  request.delegate = self;<br>  // 3) 请求方式<br>  request.requestMethod = @”POST”;<br>  // 4)<br>  [request setPostValue:@”7B63373363386530373034366164393262633633373039326138356238366366307D2C7B336464363563386338626263653130663531623832616632343963363832323065363964656161627D2C7B66616C73657D2C7B307D2C7B307D2C7B66373539333863642D326162352D346232342D616336622D3132386538626434663366397D2C7B37363033396665333533326461623034656561353162363734643131636532617D2C7B323031352D30332D30372031313A31383A33337D2C7B312E382E367D2C7B696F736C6974657261747572657D2C7B494F536C6974657261747572655F312E382E365F696F73382E312E335F6950686F6E65352D327D” forKey:@”sessionKey”];<br>  [request setPostValue:@”10” forKey:@”pageSize”];<br>  [request setPostValue:@”2” forKey:@”rtype”];<br>  [request setPostValue:@”0” forKey:@”pageIndex”];<br>  [request setPostValue:@”getLiteraturegroupBySpecialty” forKey:@”m”];<br>  // 5) 发送请求(异步请求)<br>  [request startAsynchronous];<br>}</em></code></pre><br></li><br><li><br><p>创建数据源和表格视图, 实现ASIHttpRequest代理方法和表格视图代理方法  </p><br></li><br><li><br><p>ASI可以上传文件或图片(代码写在发送请求之前)    </p><br><pre><code> // 上传文件<br>// 第一个参数: 文件的路径<br>// 第二个参数: key值<br>// request setFile:&lt;#(NSString )#&gt; forKey:&lt;#(NSString *)#&gt;<p></p>
<p>// 上传图片<br>// 第一个参数: 文件的路径<br>// 第二个参数: 文件的名字<br>// 第三个参数: 文件的类型(image/png)<br>// 第四个参数: key<br>// request setFile:&lt;#(NSString <em>)#&gt; withFileName:&lt;#(NSString </em>)#&gt; andContentType:&lt;#(NSString <em>)#&gt; forKey:&lt;#(NSString </em>)#&gt;</p></code></pre><br></li><br></ol><br><hr><br><h5>3. 使用AFNetworking完成Post请求</h5><br><ol><br><li><br><p>AFNetworking进行Post请求  </p><br><pre><code> - (void)downloadData<br>{<br>  // 1. 导入AFnetworking库文件<br>  // 2. 导入头文件使用<p></p>
<p>  // 1) 创建AFHTTPRequestOperationManager<br>  AFHTTPRequestOperationManager *manager = [[AFHTTPRequestOperationManager alloc] init];</p>
<p>  // 2) 设置返回值为二进制类型<br>  manager.responseSerializer = [AFHTTPResponseSerializer serializer];</p>
<p>  // 3) 请求数据<br>  /<em><br>   第一个参数: url地址<br>   第二个参数: Post请求的参数, 放在一个字典中<br>   第三个参数: 请求成功返回调用的代码块<br>   第四个参数: 请求失败调用的代码块
   </em>/</p>
<p>  // 请求参数放到一个字典里面<br>  NSMutableDictionary *parameterDict = [NSMutableDictionary dictionary];<br>  [parameterDict setObject:@”7B63373363386530373034366164393262633633373039326138356238366366307D2C7B336464363563386338626263653130663531623832616632343963363832323065363964656161627D2C7B66616C73657D2C7B307D2C7B307D2C7B66373539333863642D326162352D346232342D616336622D3132386538626434663366397D2C7B37363033396665333533326461623034656561353162363734643131636532617D2C7B323031352D30332D30372031313A31383A33337D2C7B312E382E367D2C7B696F736C6974657261747572657D2C7B494F536C6974657261747572655F312E382E365F696F73382E312E335F6950686F6E65352D327D” forKey:@”sessionKey”];<br>  [parameterDict setObject:@”10” forKey:@”pageSize”];<br>  [parameterDict setObject:@”2” forKey:@”rtype”];<br>  [parameterDict setObject:@”0” forKey:@”pageIndex”];<br>  [parameterDict setObject:@”getLiteraturegroupBySpecialty” forKey:@”m”];</p>
<p>  // 4) 注意的两点<br>  // 1. block代码块的执行是异步的<br>  // 2. block里面的变量通常会拷贝, 所以里面使用self指向的视图控制器对象时, 通常使用弱引用, 否则会有内存泄露<br>  __weak ViewController <em>weakSelf = self;<br>  [manager POST:@”<a href="http://services.xingshulin.com/ApricotForestWirelessServiceForLiterature/LiteratureDataServlet" target="_blank" rel="external">http://services.xingshulin.com/ApricotForestWirelessServiceForLiterature/LiteratureDataServlet</a>“ parameters:parameterDict success:^(AFHTTPRequestOperation </em>operation, id responseObject) {</p>
<pre><code>// JSON数据
id result = [NSJSONSerialization JSONObjectWithData:responseObject options:NSJSONReadingMutableContainers error:nil];

if ([result isKindOfClass:[NSDictionary class]]) {
    NSDictionary *dict = result;
    NSLog(@&quot;%@&quot;, dict);

    for (NSDictionary *objDict in dict[@&quot;obj&quot;]) {
        DataModel *model = [[DataModel alloc] init];
        [model setValuesForKeysWithDictionary:objDict];
        [weakSelf.dataArray addObject:model];
    }
    [weakSelf.tableView reloadData];
}
</code></pre><p>  } failure:^(AFHTTPRequestOperation <em>operation, NSError </em>error) {</p>
<pre><code>NSLog(@&quot;error:%@&quot;, error);
</code></pre><p>  }];<br>}</p></code></pre><br></li><br><li><br><p>创建数据源和表格视图, 实现表格视图代理方法    </p><br></li><br><li><br><p>AFNetworking可以上传文件或图片  </p><br><pre><code> manager POST:(NSString *) parameters:(id) constructingBodyWithBlock:^(id&lt;AFMultipartFormData&gt; formData) {<p></p>
<p>  // 上传文件的时候会使用<br>  // formData appendPartWithFileURL:&lt;#(NSURL <em>)#&gt; name:&lt;#(NSString </em>)#&gt; error:&lt;#(NSError <em>__autoreleasing </em>)#&gt;</p>
<p>  // 上传图片<br>  // 第四个参数:@”image/png”<br>  // formData appendPartWithFileData:&lt;#(NSData <em>)#&gt; name:&lt;#(NSString </em>)#&gt; fileName:&lt;#(NSString <em>)#&gt; mimeType:&lt;#(NSString </em>)#&gt;</p>
<p>} success:&lt;#^(AFHTTPRequestOperation <em>operation, id responseObject)success#&gt; failure:&lt;#^(AFHTTPRequestOperation </em>operation, NSError *error)failure#&gt;</p></code></pre><br></li><br></ol><br><hr><br><h2>三. 使用MKNetworkingKit实现get和Post</h2><br><h5>1. get请求</h5><br><ol><br><li><br><p>下载数据方法   </p><br><pre><code> - (void)downloadData<br>{<br>  // 1. MKNetworkKit文件夹拖入项目，然后引入4个framework：<br>  //       CFNetwork.framework  , SystemConfiguration.framework  , Security.framework, ImageIO.framework<p></p>
<p>  // 2. 注意主机名HostName不能加”http://“, 程序会自动添加, 主机要指向一个目录, 不可以是一个具体文件, 如上类不可以是”www.<em>*</em>.net/json/conn.asp”</p>
<p>  MKNetworkEngine <em>engine = [[MKNetworkEngine alloc] initWithHostName:@”iappfree.candou.com:8080” customHeaderFields:nil];<br>  MKNetworkOperation </em>operation = [engine operationWithPath:@”/free/applications/limited?currency=rmb&amp;page=1” params:nil httpMethod:@”GET” ssl:NO];</p>
<p>  [operation addCompletionHandler:^(MKNetworkOperation *operation) {</p>
<pre><code>id result = [NSJSONSerialization JSONObjectWithData:operation.responseData options:NSJSONReadingMutableContainers error:nil];
if ([result isKindOfClass:[NSDictionary class]]) {
    NSDictionary *dict = result;
    for (NSDictionary *appDict in dict[@&quot;applications&quot;]) {
        DataModel *model = [[DataModel alloc] init];
        [model setValuesForKeysWithDictionary:appDict];
        [self.dataArray addObject:model];
    }
    [self.tableView reloadData];
}
</code></pre><p>  } errorHandler:^(MKNetworkOperation <em>errorOp, NSError</em> err) {</p>
<pre><code>NSLog(@&quot;MKNetwork request error : %@&quot;, [err localizedDescription]);
</code></pre><p>  }];</p>
<p>  [engine enqueueOperation:operation];<br>}</p></code></pre><br></li><br><li><br><p>创建数据源和表格视图, 实现表格视图代理方法    </p><br></li><br></ol><br><hr><br><h5>2. Post请求</h5><br><ol><br><li><br><p>下载数据方法  </p><br><pre><code> - (void)downloadData<br>{<br>  // 1. MKNetworkKit文件夹拖入项目，然后引入4个framework：<br>  // CFNetwork.Framework  , SystemConfiguration.framework  , Security.framework<p></p>
<p>  // 2. 注意主机名HostName不能加”http://“, 程序会自动添加, 主机要指向一个目录, 不可以是一个具体文件, 如上类不可以是”www.<em>*</em>.net/json/conn.asp”</p>
<p>  MKNetworkEngine *engine = [[MKNetworkEngine alloc] initWithHostName:@”services.xingshulin.com/ApricotForestWirelessServiceForLiterature/LiteratureDataServlet” customHeaderFields:nil];</p>
<p>  NSMutableDictionary *paramsDict = [NSMutableDictionary dictionary];<br>  [paramsDict setObject:@”7B63373363386530373034366164393262633633373039326138356238366366307D2C7B336464363563386338626263653130663531623832616632343963363832323065363964656161627D2C7B66616C73657D2C7B307D2C7B307D2C7B66373539333863642D326162352D346232342D616336622D3132386538626434663366397D2C7B37363033396665333533326461623034656561353162363734643131636532617D2C7B323031352D30332D30372031313A31383A33337D2C7B312E382E367D2C7B696F736C6974657261747572657D2C7B494F536C6974657261747572655F312E382E365F696F73382E312E335F6950686F6E65352D327D” forKey:@”sessionKey”];<br>  [paramsDict setObject:@”10” forKey:@”pageSize”];<br>  [paramsDict setObject:@”2” forKey:@”rtype”];<br>  [paramsDict setObject:@”0” forKey:@”pageIndex”];<br>  [paramsDict setObject:@”getLiteraturegroupBySpecialty” forKey:@”m”];</p>
<p>  MKNetworkOperation *operation = [engine operationWithPath:nil params:paramsDict httpMethod:@”POST”];</p>
<p>  [operation addCompletionHandler:^(MKNetworkOperation *operation) {</p>
<pre><code>id result = [NSJSONSerialization JSONObjectWithData:operation.responseData options:NSJSONReadingMutableContainers error:nil];

if ([result isKindOfClass:[NSDictionary class]]) {
    NSDictionary *dict = result;
    NSLog(@&quot;%@&quot;, dict);

    for (NSDictionary *objDict in dict[@&quot;obj&quot;]) {
        DataModel *model = [[DataModel alloc] init];
        [model setValuesForKeysWithDictionary:objDict];
        [_dataArray addObject:model];
    }
    [_tableView reloadData];
}
</code></pre><p>  } errorHandler:^(MKNetworkOperation <em>errorOp, NSError</em> err) {</p>
<pre><code>NSLog(@&quot;MKNetwork request error : %@&quot;, [err localizedDescription]);
</code></pre><p>  }];</p>
<p>  [engine enqueueOperation:operation];<br>}</p></code></pre><br></li><br><li><br><p>创建数据源和表格视图, 实现表格视图代理方法</p><br></li><br></ol><br><p></p>


]]></content>
    <summary type="html">
    <![CDATA[<p>ASIHTTPRequest, AFNetworking, MKNetworkingKit网络框架get和post请求</p>]]>
    
    </summary>
    
      <category term="AFNetworking" scheme="http://yimouleng.com/tags/AFNetworking/"/>
    
      <category term="ASIHTTPRequest" scheme="http://yimouleng.com/tags/ASIHTTPRequest/"/>
    
      <category term="MKNetworkingKit" scheme="http://yimouleng.com/tags/MKNetworkingKit/"/>
    
      <category term="网络框架" scheme="http://yimouleng.com/tags/%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6/"/>
    
      <category term="iOS开发" scheme="http://yimouleng.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[block的循环引用 ------ Weak-Strong Dance]]></title>
    <link href="http://yimouleng.com/2015/07/20/block-Weak-Strong/"/>
    <id>http://yimouleng.com/2015/07/20/block-Weak-Strong/</id>
    <published>2015-07-19T16:00:00.000Z</published>
    <updated>2015-12-09T09:20:52.000Z</updated>
    <content type="html"><![CDATA[<p>RAC设计模式在应用中大量使用了block，由于Objective-C语言的内存管理是基于引用计数的，为了避免循环引用问题，在block中如果要引用self，需要使用<code>@weakify(self)</code>和<code>@strongify(self)</code>来避免强引用。</p>
<a id="more"></a>
<h4 id="u4E00_u3001block_u7684_u5FAA_u73AF_u5F15_u7528_u95EE_u9898"><a href="#u4E00_u3001block_u7684_u5FAA_u73AF_u5F15_u7528_u95EE_u9898" class="headerlink" title="一、block的循环引用问题"></a>一、block的循环引用问题</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)loadView  </span><br><span class="line">&#123;  </span><br><span class="line">  [superloadView];  </span><br><span class="line">             </span><br><span class="line">  _observer = [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserverForName:<span class="string">@"testKey"</span>  </span><br><span class="line">                                                                object:<span class="literal">nil</span>  </span><br><span class="line">                                                                 queue:<span class="literal">nil</span>  </span><br><span class="line">                                                            usingBlock:^(<span class="built_in">NSNotification</span> *note) &#123;  </span><br><span class="line">      [<span class="keyword">self</span> dismissModalViewControllerAnimated:<span class="literal">YES</span>];    </span><br><span class="line">  &#125;];  </span><br><span class="line">&#125;  </span><br><span class="line">- (<span class="keyword">void</span>)dealloc  </span><br><span class="line">&#123;  </span><br><span class="line">  [[<span class="built_in">NSNotificationCenter</span> defaultCenter] removeObserver:_observer];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码分析：<br>在上面代码中，我们添加向通知中心注册了一个观察者，然后在 dealloc 时解除该注册，一切看起来正常。但这里有两个问题：</p>
<p>这段代码中涉及到的对象包括：<code>notificationcenter, _observer, block, self</code>.</p>
<p>a) 在消息通知 block 中引用到了 self，所以这里 self 对象被 block retain；而 _observer 又对该 block 进行retain，通知中心 notificationcentre 又持有 _observer。因此只要 _observer 对象还没有被解除注册，block 就会一直被持有，从而 self 就不会被释放，那么 dealloc 就不会被调用。而我们却又期望在 dealloc 中通过 removeObserver 来解除注册以消除通知中心 notificationcenter 对 _observer 的 retain。</p>
<p>小结：<code>notificationcenter --&gt; _observer --&gt; block --&gt; self</code> 只有在 self 释放，dealloc 调用的时候，notificationcenter 才会释放 _observer，显然其中存在循环引用。</p>
<p>b) 同时，_observer 是在 self 所在类中定义赋值，因此是被 self retain 的，这样就形成了循环引用。<br>小结：<strong> self –&gt; _observer –&gt; block –&gt; self 显然这也是一个循环引用</strong>。</p>
<h4 id="u4E8C_u3001Weak-Strong_Dance"><a href="#u4E8C_u3001Weak-Strong_Dance" class="headerlink" title="二、Weak-Strong Dance"></a>二、Weak-Strong Dance</h4><p>对于在block中的retain cycle，在2011 WWDC Session #322 (Objective-C Advancements in Depth)有一个解决方案weak-strong dance，很漂亮的名字。其实现如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)dealloc  </span><br><span class="line">&#123;  </span><br><span class="line">  [[<span class="built_in">NSNotificationCenter</span> defaultCenter] removeObserver:_observer];  </span><br><span class="line">&#125;  </span><br><span class="line">   </span><br><span class="line">- (<span class="keyword">void</span>)loadView  </span><br><span class="line">&#123;  </span><br><span class="line">  [superloadView];  </span><br><span class="line">             </span><br><span class="line">  __<span class="keyword">weak</span> TestViewController *wself = <span class="keyword">self</span>;  </span><br><span class="line">  _observer = [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserverForName:<span class="string">@"testKey"</span>  </span><br><span class="line">                                                                object:<span class="literal">nil</span>  </span><br><span class="line">                                                                 queue:<span class="literal">nil</span>  </span><br><span class="line">                                                            usingBlock:^(<span class="built_in">NSNotification</span> *note) &#123;  </span><br><span class="line">      TestViewController *sself = wself;  </span><br><span class="line">      [sself dismissModalViewControllerAnimated:<span class="literal">YES</span>];  </span><br><span class="line">  &#125;];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在 block 使用 self 之前先用 <strong>weak 修饰 self 创建一个 self 弱引用变量 ，然后在 block 中使用 self 之前先用 </strong>strong 修饰创建一个 对该弱引用 self 的强引用，防止 self 被提前释放。<br>这样的话就可以打破循环引用了。</p>
<p>当然，<strong>weak 和 </strong>strong 只在 ARC 情形下有效；对于非 ARC ，就需要用到 __block 了，效果相同，如下：</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="atom">void</span>)<span class="atom">dealloc</span>  </span><br><span class="line">&#123;  </span><br><span class="line">  [[<span class="name">NSNotificationCenter</span> <span class="atom">defaultCenter</span>] <span class="atom">removeObserver</span>:<span class="name">_observer</span>];  </span><br><span class="line">  [<span class="name">_observer</span> <span class="atom">release</span>];  </span><br><span class="line">   </span><br><span class="line">  [<span class="atom">superdealloc</span>];  </span><br><span class="line">&#125;  </span><br><span class="line">   </span><br><span class="line">- (<span class="atom">void</span>)<span class="atom">loadView</span>  </span><br><span class="line">&#123;  </span><br><span class="line">  [<span class="atom">superloadView</span>];  </span><br><span class="line">             </span><br><span class="line">  <span class="name">__block</span> <span class="name">TestViewController</span> *<span class="atom">bself</span> = <span class="atom">self</span>;  </span><br><span class="line">  <span class="name">_observer</span> = [[<span class="name">NSNotificationCenter</span> <span class="atom">defaultCenter</span>] <span class="atom">addObserverForName</span>:@<span class="string">"testKey"</span>  </span><br><span class="line">                                                                <span class="atom">object</span>:<span class="atom">nil</span>  </span><br><span class="line">                                                                 <span class="atom">queue</span>:<span class="atom">nil</span>  </span><br><span class="line">                                                               <span class="atom">ngBlock</span>:^(<span class="name">NSNotification</span> *<span class="atom">note</span>) &#123;  </span><br><span class="line">      [<span class="atom">bself</span> <span class="atom">retain</span>];  </span><br><span class="line">      [<span class="atom">bself</span> <span class="atom">dismissModalViewControllerAnimated</span>:<span class="name">YES</span>];  </span><br><span class="line">      [<span class="atom">bself</span> <span class="atom">release</span>];  </span><br><span class="line">  &#125;];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u4E09_u3001ReactiveCocoa_u4E2D_u7684Weak-Strong_Dance"><a href="#u4E09_u3001ReactiveCocoa_u4E2D_u7684Weak-Strong_Dance" class="headerlink" title="三、ReactiveCocoa中的Weak-Strong Dance"></a>三、ReactiveCocoa中的Weak-Strong Dance</h4><blockquote>
<p>例如：</p>
</blockquote>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@weakify</span>(<span class="keyword">self</span>);  </span><br><span class="line">[<span class="constant">RACObserve</span>(<span class="keyword">self</span>,photosArray) <span class="symbol">subscribeNext:</span>^(id x)&#123;  </span><br><span class="line">    <span class="variable">@strongify</span>(<span class="keyword">self</span>);  </span><br><span class="line">    [<span class="keyword">self</span>.collectionView reloadData];  </span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>RACObserver is a C macro that takes two parameters: an object and a key path on that object. It returns a signal whose values are sent whenever the key path’s value changes. A completion value is sent when the object, in this case self, is deallocated. –&gt; ? We subscribe to this signal in order to reload our collection view whenever our photosArray property is changed.</p>
</blockquote>
<p>译注：RACObserver 是一个宏定义，有两个参数：<code>an object and a key path on that object</code>。当 <code>object key path value</code> 变化时，就会返回一个 <code>signal</code>。</p>
<p>我们对这个 signal 进行订阅，一旦 <code>photoArray</code> 属性发送变化，返回signal，就可以 <code>reload collection view</code>。</p>
<blockquote>
<p>The weakify/strongify dance is all too common in Objective-C under ARC.Weakify creates a new, weak variable assigned to self. Strongify then creates a new, strong variable in its scope assigned to the weak self. When strongify does this, it’s using what’s called a “shadow variable” – so named because the new, strong variable is called self, replacing the former strong reference to self.</p>
<p>Basically, the subscribeNext: block is going to capture self in its lexical scope, causing a reference cycle between self and the block. The block is strongly referenced by the return value of subscribeNext:, a RACSubscriber instance. This is then captured by the RACObserver macro, which will be automatically deallocated once its first parameter, self is deallocated. Without the weakify/strongify invocations, self would never be deallocated.</p>
</blockquote>
<p>译注：分析一下其中可能存在的 block 循环引用问题。</p>
<p><code>self --&gt; RACObserver macro --&gt; RACSubscriber instance --&gt; block --&gt; self</code>. 假如不使用<code>weakify/strongify</code> 那么现实其中的循环引用导致 self 始终无法释放。</p>
<p>最后友情提示：在使用时应该注意block的嵌套层数，不恰当的滥用多层嵌套block可能给程序的可维护性带来灾难。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>RAC设计模式在应用中大量使用了block，由于Objective-C语言的内存管理是基于引用计数的，为了避免循环引用问题，在block中如果要引用self，需要使用<code>@weakify(self)</code>和<code>@strongify(self)</code>来避免强引用。</p>]]>
    
    </summary>
    
      <category term="block" scheme="http://yimouleng.com/tags/block/"/>
    
      <category term="iOS" scheme="http://yimouleng.com/tags/iOS/"/>
    
      <category term="iOS开发" scheme="http://yimouleng.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS开发 警告试图和日期选择器]]></title>
    <link href="http://yimouleng.com/2015/06/04/ios-UIAlertview-UIActionSheet/"/>
    <id>http://yimouleng.com/2015/06/04/ios-UIAlertview-UIActionSheet/</id>
    <published>2015-06-03T16:00:00.000Z</published>
    <updated>2015-12-09T09:34:21.000Z</updated>
    <content type="html"><![CDATA[<div id="cnblogs_post_body" class="cnblogs-markdown"><h2 id="uialertviewuiactionsheet">1. 警告框(UIAlertView)与UIActionSheet</h2><br><p>UIAlertView与UIActionSheet都是iOS系统自带的弹出式对话跨。两者的区别是：UIAlertView表现为显示在屏幕中央的弹出式警告框；UIActionSheet则表示为显示在底部的按钮列表。</p><br><a id="more"></a><br><h3 id="uialertview">1.1 UIAlertView的基本用法</h3><br><p>使用步骤：</p><br><ol><br><li>创建UIAlertView，创建该对象时可指定该警告框的标题、消息内容，以及该警告框包含的按钮。<br></li><br><li>调用UIAlertView显示出来。<br></li><br><li>如果需要监听用户点击了警告框的那个按钮，为委托对象实现<code>UIAlertViewDelegate</code>协议中的方法。</li><br></ol><br><h5>案例：点击按钮弹出警告框</h5><br><br><img src="/content/images/2015/09/222.png" alt=""><br><br><p>实现代码：</p><br><pre><code>- (IBAction)openAlert:(UIButton <em>)sender {<br>    //创建UIAlertView控件<br>    UIAlertView </em> alert = [[UIAlertView alloc]<br>                           initWithTitle:@&quot;提示&quot; //指示标题<br>                           message:@&quot;警告框的用法&quot; //指示消息<br>                           delegate:self //指定委托对象<br>                           cancelButtonTitle:@&quot;取消&quot; //为底部的取消按钮设置标题<br>                           //设置另外三个按钮<br>                           otherButtonTitles:@&quot;按钮一&quot;,@&quot;按钮二&quot;,@&quot;按钮三&quot;, nil];<br>    [alert show];<br>}<br><br>-(void) alertView:(UIAlertView <em>)alertView clickedButtonAtIndex:(NSInteger)buttonIndex<br>{<br>    NSString </em> msg = [NSString stringWithFormat:@&quot;您点击了第%ld个按钮&quot;,buttonIndex];<br>    //创建UIAlertView控件<br>    UIAlertView <em> alert = [[UIAlertView alloc]<br>                           initWithTitle:@&quot;提示&quot; message:msg delegate:nil cancelButtonTitle:@&quot;确定&quot; otherButtonTitles: nil];<br>    [alert show];<br>}</em></code></pre><br><p>UIAlertView控件的事件机制是交给委托对象负责处理。<code>UIAlertViewDelegate</code>协议中定义的常用方法：</p><br><ol><br><li><code>-(void)alertView:(UIAlertView)alertView clickedButtonAtIndex:(NSInteger)buttonIndex:</code> 用户单击该警告框中某个按钮是触发，buttonIndex代表用户单击的按钮的索引，从0开始<br></li><br><li><code>-(void)willPresentAlertView:（UIAlertView<em>）alertView</em></code> 警告框将要显示出来时触发。<br></li><br><li><code>-(void)didPresentAlertView:(UIAlertView)alertView</code> 警告框完全显示出来后将会触发。<br></li><br><li><code>-(BOOL)alertViewShouldEnableFirstOtherButton:(UIAlertView<em>)alert</em></code> 警告框中第一个非Cancel按钮被启用时触发。<br></li><br><li><code>-(void)alertView:(UIAlertView)alertView willDismissWithButtonIndex:(NSInteger)buttonIndex</code>单击某个按钮完全隐藏该警告框时触发<br></li><br><li><code>-(void)alertViewCancel:(UIAlertView<em>)alertView</em></code> 对话框被取消时触发。</li><br></ol><br><h3 id="uialertview">1.2 带输入框的UIAlertView</h3><br><p>UIAlertView支持一个<code>actionSheetStyle</code>属性，用于设置UIAlertView的风格，支持如下枚举值：</p><br><ol><br><li><code>UIAlertViewStyleDefault</code> 默认的警告框风格<br></li><br><li><code>UIAlertViewStyleSecureTextInput</code> 包含一个密码输入框<br></li><br><li><code>UIAlertViewStylePlainTextInput</code> 包含一个普通的输入框<br></li><br><li><code>UIAlertViewStyleLoginAndPasswordInput</code> 包含用户名、密码两个输入框</li><br></ol><br><p>获取警告框中的输入框：</p><br><p><code>-(UITextField)textFieldAtIndex:(NSInteger)textFieldIndex:</code> 获取textFieldIndex索引对应的文本框。第一个文本框的索引默认为0.</p><br><h5 id="uialertview">案例：带输入框的UIAlertView</h5><br><p>效果图：<br><img src="/content/images/2015/09/222-1.png" alt=""><br></p><p>实现代码：</p><br><p>1.绑定按钮点击事件</p><br><pre><code>- (IBAction)openTextAlert:(UIButton )sender {<br>    textAlert = [[UIAlertView alloc]<br>                 initWithTitle:@&quot;登录&quot; message:@&quot;请输入用户名和密码&quot; delegate:self cancelButtonTitle:@&quot;取消&quot; otherButtonTitles:@&quot;确定&quot;, nil];<br>    //设置该警告框显示为输入用户名和密码框<br>    textAlert.alertViewStyle = UIAlertViewStyleLoginAndPasswordInput;<br>    //设置第二个文本管理的键盘只是数字键盘<br>    [textAlert textFieldAtIndex:1].keyboardType = UIKeyboardTypeNumberPad;<br>    //显示UIAlertView<br>    [textAlert show];<br>}</code></pre><br><p>2.重写<code>alertView</code>中的逻辑</p><br><pre><code>//如果用户单击了第一个按钮<br>        if(buttonIndex == 1)<br>        {<br>            UITextField<em> nameField = [textAlert textFieldAtIndex:0];<br>            UITextField</em> passField = [textAlert textFieldAtIndex:1];<br>            NSString<em> msg = [NSString stringWithFormat:@&quot;输入的用户名和密码为：%@,%@&quot;,nameField.text,passField.text];<br>            UIAlertView </em> msgAlert = [[UIAlertView alloc]<br>                                      initWithTitle:@&quot;提示&quot; message:msg delegate:nil cancelButtonTitle:@&quot;确定&quot; otherButtonTitles: nil];<br>            [msgAlert show];<br>        }</code></pre><br><h3 id="uiactionsheet">1.3 UIActionSheet</h3><br><p>UIActionSheet表现为显示在底部的按钮列表。默认情况下，UIActionSheet支持一个标题和多个按钮，UIActionSheet会有两个固定的按钮和多个其他按钮：</p><br><ol><br><li>灰色背景的取消按钮<br></li><br><li>红色背景的销毁按钮</li><br></ol><br><p>UIActionSheet也可以通过<code>ActionSheetStyle</code> 属性来控制控件的风格：</p><br><ol><br><li><code>UIActionSheetStyleDefault</code> 默认风格，灰色背景上显示白色文字<br></li><br><li><code>UIActionSheetStyleBlackTranslucent</code> 在透明的黑色背景上显示白色文字<br></li><br><li><code>UIActionSheetStyleBlackOpaque</code> 在纯黑的背景上显示白色文字</li><br></ol><br><p>事件委托类是：<code>UIActionSheetDelegate</code></p><br><h2 id="uidatepicker">2. 日期选择器(UIDatePicker)</h2><br><p>UIDatePicker可以用来选择日期和事件，也可作为倒计时控件。继承了UIControl。</p><br><p>支持的属性如下：</p><br><ol><br><li>Mode 模式<br></li><br><li>Locale 国际化<br></li><br><li>Interval 设置两个事件的间隔<br></li><br><li>Constraints 设置最大时间和最小时间<br></li><br><li>Timer 采用Count Down Time模式有效，设置控件作为倒计时剩下的秒数</li><br></ol><br><h5 id="-">案例： 倒计时器</h5><br><br><img src="/content/images/2015/09/222-2.png" alt=""><br><br><pre><code>NSTimer <em> timer1;<br>NSInteger leftSeconds;<br><br>-(void) viewDidLoad<br>{<br>    [super viewDidLoad];<br>    self.countDown.datePickerMode = UIDatePickerModeCountDownTimer;<br>}<br><br><br><br>-(void) tickDown<br>{<br>    leftSeconds -= 60;<br>    self.countDown.countDownDuration = leftSeconds;<br>    if(leftSeconds &lt;=0)<br>    {<br>        [timer1 invalidate];<br>        self.countDown.enabled = YES;<br>        self.startBn1.enabled = YES;<br>    }<br><br>}<br>- (IBAction)click1:(UIButton </em>)sender {<br>    //获取倒计时器的剩余时间<br>    leftSeconds = self.countDown.countDownDuration;<br>    self.countDown.enabled = NO;<br>    [sender setEnabled:NO];<br>    NSString<em> message=[NSString stringWithFormat:@&quot;开始倒计时?还剩下【%d】秒&quot;,leftSeconds];<br>    UIAlertView</em> alert = [[UIAlertView alloc]<br>                          initWithTitle:@&quot;开始倒计时?&quot; message:message delegate:nil cancelButtonTitle:@&quot;确定&quot; otherButtonTitles: nil];<br>    [alert show];<br>    //启动计时器，每隔60秒执行一次tickDown方法<br><br>    timer1 = [NSTimer scheduledTimerWithTimeInterval:60 target:self selector:@selector(tickDown) userInfo:nil repeats:YES];<br><br>}<br></code></pre></div><div id="MySignature"></div><br><div class="clear"></div><br><div id="blog_post_info_block"><br><div id="BlogPostCategory"></div><br><div id="EntryTag"></div><br><div id="blog_post_info"><br></div><br><div class="clear"></div><br><div id="post_next_prev"></div><br></div>
]]></content>
    <summary type="html">
    <![CDATA[<div id="cnblogs_post_body" class="cnblogs-markdown"><h2 id="uialertviewuiactionsheet">1. 警告框(UIAlertView)与UIActionSheet</h2><br><p>UIAlertView与UIActionSheet都是iOS系统自带的弹出式对话跨。两者的区别是：UIAlertView表现为显示在屏幕中央的弹出式警告框；UIActionSheet则表示为显示在底部的按钮列表。</p><br>]]>
    
    </summary>
    
      <category term="UIActionSheet" scheme="http://yimouleng.com/tags/UIActionSheet/"/>
    
      <category term="UIAlertview" scheme="http://yimouleng.com/tags/UIAlertview/"/>
    
      <category term="iOS开发" scheme="http://yimouleng.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS开发 runtime理解]]></title>
    <link href="http://yimouleng.com/2015/05/28/ios-runtime/"/>
    <id>http://yimouleng.com/2015/05/28/ios-runtime/</id>
    <published>2015-05-27T16:00:00.000Z</published>
    <updated>2015-12-09T09:29:55.000Z</updated>
    <content type="html"><![CDATA[<p>本文详细整理了 Cocoa 的 Runtime 系统的知识，它使得 Objective-C 如虎添翼，具备了灵活的动态特性，使这门古老的语言焕发生机。主要内容如下： </p>
<a id="more"></a>
<p><ul></ul></p>
<p><li>引言</li></p>
<p><li>简介</li></p>
<p><li>与Runtime交互</li></p>
<p><li>Runtime术语</li></p>
<p><li>消息</li></p>
<p><li>动态方法解析</li></p>
<p><li>消息转发</li></p>
<p><li>健壮的实例变量(Non Fragile ivars)</li></p>
<p><li>Objective-C Associated Objects</li></p>
<p><li>Method Swizzling</li></p>
<p><li>总结</li><br><br><a id="more"></a>  </p>
<p></p><h2 id="引言">引言</h2><p>曾经觉得Objc特别方便上手，面对着 Cocoa 中大量 API，只知道简单的查文档和调用。还记得初学 Objective-C 时把<code>[receiver message]</code>当成简单的方法调用，而无视了<strong>“发送消息”</strong>这句话的深刻含义。其实<code>[receiver message]</code>会被编译器转化为：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend(receiver, selector)</span><br></pre></td></tr></table></figure></p><p></p>
<p>如果消息含有参数，则为：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">objc_msgSend</span><span class="params">(receiver, selector, arg1, arg2, …)</span></span></span><br></pre></td></tr></table></figure></p><br><p>如果消息的接收者能够找到对应的<code>selector</code>，那么就相当于直接执行了接收者这个对象的特定方法；否则，消息要么被转发，或是临时向接收者动态添加这个<code>selector</code>对应的实现内容，要么就干脆玩完崩溃掉。  </p><br><p>现在可以看出<code>[receiver message]</code>真的不是一个简简单单的方法调用。因为这只是在编译阶段确定了要向接收者发送<code>message</code>这条消息，而<code>receive</code>将要如何响应这条消息，那就要看运行时发生的情况来决定了。  </p><br><p>Objective-C 的 Runtime 铸就了它动态语言的特性，这些深层次的知识虽然平时写代码用的少一些，但是却是每个 Objc 程序员需要了解的。  </p><br><h2 id="简介">简介</h2><p>因为Objc是一门动态语言，所以它总是想办法把一些决定工作从编译连接推迟到运行时。也就是说只有编译器是不够的，还需要一个运行时系统 (runtime system) 来执行编译后的代码。这就是 Objective-C Runtime 系统存在的意义，它是整个Objc运行框架的一块基石。  </p><br><p>Runtime其实有两个版本:“modern”和 “legacy”。我们现在用的 Objective-C 2.0 采用的是现行(Modern)版的Runtime系统，只能运行在 iOS 和 OS X 10.5 之后的64位程序中。而OS X较老的32位程序仍采用 Objective-C 1中的（早期）Legacy 版本的 Runtime 系统。这两个版本最大的区别在于当你更改一个类的实例变量的布局时，在早期版本中你需要重新编译它的子类，而现行版就不需要。  </p><br><p>Runtime基本是用C和汇编写的，可见苹果为了动态系统的高效而作出的努力。你可以在<a href="http://www.opensource.apple.com/source/objc4/" target="_blank" rel="external">这里</a>下到苹果维护的开源代码。苹果和GNU各自维护一个开源的runtime版本，这两个版本之间都在努力的保持一致。   </p><br><h2 id="与Runtime交互">与Runtime交互</h2><p>Objc 从三种不同的层级上与 Runtime 系统进行交互，分别是通过 Objective-C 源代码，通过 Foundation 框架的<code>NSObject</code>类定义的方法，通过对 runtime 函数的直接调用。  </p><br><h3 id="Objective-C源代码">Objective-C源代码</h3><p>大部分情况下你就只管写你的Objc代码就行，runtime 系统自动在幕后辛勤劳作着。<br>还记得引言中举的例子吧，消息的执行会使用到一些编译器为实现动态语言特性而创建的数据结构和函数，Objc中的类、方法和协议等在 runtime 中都由一些数据结构来定义，这些内容在后面会讲到。（比如<code>objc_msgSend</code>函数及其参数列表中的<code>id</code>和<code>SEL</code>都是啥）</p><br><h3 id="NSObject的方法">NSObject的方法</h3><p>Cocoa 中大多数类都继承于<code>NSObject</code>类，也就自然继承了它的方法。最特殊的例外是<code>NSProxy</code>，它是个抽象超类，它实现了一些消息转发有关的方法，可以通过继承它来实现一个其他类的替身类或是虚拟出一个不存在的类，说白了就是领导把自己展现给大家风光无限，但是把活儿都交给幕后小弟去干。  </p><br><p>有的<code>NSObject</code>中的方法起到了抽象接口的作用，比如<code>description</code>方法需要你重载它并为你定义的类提供描述内容。<code>NSObject</code>还有些方法能在运行时获得类的信息，并检查一些特性，比如<code>class</code>返回对象的类；<code>isKindOfClass:</code>和<code>isMemberOfClass:</code>则检查对象是否在指定的类继承体系中；<code>respondsToSelector:</code>检查对象能否响应指定的消息；<code>conformsToProtocol:</code>检查对象是否实现了指定协议类的方法；<code>methodForSelector:</code>则返回指定方法实现的地址。   </p><br><h3 id="Runtime的函数">Runtime的函数</h3><p>Runtime 系统是一个由一系列函数和数据结构组成，具有公共接口的动态共享库。头文件存放于<code>/usr/include/objc</code>目录下。许多函数允许你用纯C代码来重复实现 Objc 中同样的功能。虽然有一些方法构成了<code>NSObject</code>类的基础，但是你在写 Objc 代码时一般不会直接用到这些函数的，除非是写一些 Objc 与其他语言的桥接或是底层的debug工作。在<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/index.html" target="_blank" rel="external">Objective-C Runtime Reference</a>中有对 Runtime 函数的详细文档。  </p><br><h2 id="Runtime术语">Runtime术语</h2><p>还记得引言中的<code>objc_msgSend:</code>方法吧，它的真身是这样的：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> objc_msgSend ( <span class="keyword">id</span> <span class="keyword">self</span>, SEL op, … );</span><br></pre></td></tr></table></figure></p><br><p>下面将会逐渐展开介绍一些术语，其实它们都对应着数据结构。  </p><br><h3 id="SEL">SEL</h3><p><code>objc_msgSend</code>函数第二个参数类型为<code>SEL</code>，它是<code>selector</code>在Objc中的表示类型（Swift中是<code>Selector</code>类）。<code>selector</code>是方法选择器，可以理解为区分方法的 ID，而这个 ID 的数据结构是<code>SEL</code>:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_selector <em>SEL;</em></span><br></pre></td></tr></table></figure></p><br><p>其实它就是个映射到方法的C字符串，你可以用 Objc 编译器命令<code>@selector()</code>或者 Runtime 系统的<code>sel_registerName</code>函数来获得一个<code>SEL</code>类型的方法选择器。  </p><br><p>不同类中相同名字的方法所对应的方法选择器是相同的，即使方法名字相同而变量类型不同也会导致它们具有相同的方法选择器，于是 Objc 中方法命名有时会带上参数类型(<code>NSNumber</code>一堆抽象工厂方法拿走不谢)，Cocoa 中有好多长长的方法哦。  </p><br><h3 id="id">id</h3><p><code>objc_msgSend</code>第一个参数类型为<code>id</code>，大家对它都不陌生，它是一个指向类实例的指针：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object <span class="keyword">id</span>;</span><br></pre></td></tr></table></figure></p><br><p>那<code>objc_object</code>又是啥呢：<br><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> </span>&#123; Class isa; &#125;;</span><br></pre></td></tr></table></figure></p><br><p><code>objc_object</code>结构体包含一个<code>isa</code>指针，根据<code>isa</code>指针就可以顺藤摸瓜找到对象所属的类。  </p><br><p>PS:<code>isa</code>指针不总是指向实例对象所属的类，不能依靠它来确定类型，而是应该用<code>class</code>方法来确定实例对象的类。因为KVO的实现机理就是将被观察对象的<code>isa</code>指针指向一个中间类而不是真实的类，这是一种叫做 <strong>isa-swizzling</strong> 的技术，详见<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOImplementation.html" target="_blank" rel="external">官方文档</a></p><br><h3 id="Class">Class</h3><p>之所以说<code>isa</code>是指针是因为<code>Class</code>其实是一个指向<code>objc_class</code>结构体的指针：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class <em>Class;</em></span><br></pre></td></tr></table></figure></p><br><p>而<code>objc_class</code>就是我们摸到的那个瓜，里面的东西多着呢：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_class &#123;</span><br><span class="line">    Class isa  OBJC<em>ISA</em><span class="built_in">AVAILABILITY</span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#if !<strong>OBJC2</strong></span></span><br><span class="line">    Class super_class                                        OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> name                                         OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">long</span> version                                             OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">long</span> info                                                OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">long</span> instance_size                                       OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">struct</span> objc_ivar_list <em>ivars                             OBJC2_UN<span class="built_in">AVAILABLE</span>;</em></span><br><span class="line">    <span class="keyword">struct</span> objc_method_list **methodLists                    OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">struct</span> objc_cache cache                                 OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">struct</span> objc_protocol_list <em>protocols                     OBJC2_UN<span class="built_in">AVAILABLE</span>;</em></span><br><span class="line"><span class="preprocessor">#endif</span></span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br></pre></td></tr></table></figure></p><br><p>可以看到运行时一个类还关联了它的超类指针，类名，成员变量，方法，缓存，还有附属的协议。  </p><br><p>PS:<code>OBJC2_UNAVAILABLE</code>之类的宏定义是苹果在  Objc  中对系统运行版本进行约束的黑魔法，为的是兼容非Objective-C 2.0的遗留逻辑，但我们仍能从中获得一些有价值的信息，有兴趣的可以查看源代码。  </p><br><p>Objective-C 2.0 的头文件虽然没暴露出<code>objc_class</code>结构体更详细的设计，我们依然可以从Objective-C 1.0 的定义中小窥端倪：  </p><br><p>在<code>objc_class</code>结构体中：<code>ivars</code>是<code>objc_ivar_list</code>指针；<code>methodLists</code>是指向<code>objc_method_list</code>指针的指针。也就是说可以动态修改<code>methodLists</code>的值来添加成员方法，这也是Category实现的原理，同样解释了Category不能添加属性的原因。关于二级指针，可以参考<a href="http://www.fenesky.com/blog/2014/07/03/pointers-to-pointers.html" target="_blank" rel="external">这篇文章</a>。<br>PS：任性的话可以在Category中添加<code>@dynamic</code>的属性，并利用运行期动态提供存取方法或干脆动态转发；或者干脆使用关联度对象（AssociatedObject）</p><br><p>其中<code>objc_ivar_list</code>和<code>objc_method_list</code>分别是成员变量列表和方法列表：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_ivar_list &#123;</span><br><span class="line">    <span class="keyword">int</span> ivar_count                                           OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line"><span class="preprocessor">#ifdef <strong>LP64</strong></span></span><br><span class="line">    <span class="keyword">int</span> space                                                OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line"><span class="preprocessor">#endif</span></span><br><span class="line">    <span class="comment">/<em> variable length structure </em>/</span></span><br><span class="line">    <span class="keyword">struct</span> objc_ivar ivar_list[<span class="number">1</span>]                            OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">&#125;                                                            OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> objc_method_list &#123;</span><br><span class="line">    <span class="keyword">struct</span> objc_method_list <em>obsolete                        OBJC2_UN<span class="built_in">AVAILABLE</span>;</em></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> method_count                                         OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line"><span class="preprocessor">#ifdef <strong>LP64</strong></span></span><br><span class="line">    <span class="keyword">int</span> space                                                OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line"><span class="preprocessor">#endif</span></span><br><span class="line">    <span class="comment">/ variable length structure <em>/</em></span></span><br><span class="line">    <span class="keyword">struct</span> objc_method method_list[<span class="number">1</span>]                        OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><br><p>如果你C语言不是特别好，可以直接理解为<code>objc_ivar_list</code>结构体存储着<code>objc_ivar</code>数组列表，而<code>objc_ivar</code>结构体存储了类的单个成员变量的信息；同理<code>objc_method_list</code>结构体存储着<code>objc_method</code>数组列表，而<code>objc_method</code>结构体存储了类的某个方法的信息。  </p><br><p>最后要提到的还有一个<code>objc_cache</code>，顾名思义它是缓存，它在<code>objc_class</code>的作用很重要，在后面会讲到。  </p><br><p>不知道你是否注意到了<code>objc_class</code>中也有一个<code>isa</code>对象，这是因为一个 ObjC 类本身同时也是一个对象，为了处理类和对象的关系，runtime 库创建了一种叫做元类 (Meta Class) 的东西，类对象所属类型就叫做元类，它用来表述类对象本身所具备的元数据。类方法就定义于此处，因为这些方法可以理解成类对象的实例方法。每个类仅有一个类对象，而每个类对象仅有一个与之相关的元类。当你发出一个类似<code>[NSObject alloc]</code>的消息时，你事实上是把这个消息发给了一个类对象 (Class Object) ，这个类对象必须是一个元类的实例，而这个元类同时也是一个根元类 (root meta class) 的实例。所有的元类最终都指向根元类为其超类。所有的元类的方法列表都有能够响应消息的类方法。所以当 <code>[NSObject alloc]</code> 这条消息发给类对象的时候，<code>objc_msgSend()</code>会去它的元类里面去查找能够响应消息的方法，如果找到了，然后对这个类对象执行方法调用。  </p><br><p><img src="http://cn.cocos2d-x.org/uploads/20141018/1413628797629491.png" alt="">  </p><br><p>上图实线是 <code>super_class</code> 指针，虚线是<code>isa</code>指针。 有趣的是根元类的超类是<code>NSObject</code>，而<code>isa</code>指向了自己，而<code>NSObject</code>的超类为<code>nil</code>，也就是它没有超类。  </p><br><h4 id="Method">Method</h4><p><code>Method</code>是一种代表类中的某个方法的类型。<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_method <span class="function"><span class="keyword">Method</span>;</span></span><br></pre></td></tr></table></figure></p><br><p>而<code>objc_method</code>在上面的方法列表中提到过，它存储了方法名，方法类型和方法实现：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_method &#123;</span><br><span class="line">    SEL method_name                                          OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">char</span> <em>method_types                                       OBJC2_UN<span class="built_in">AVAILABLE</span>;</em></span><br><span class="line">    IMP method_imp                                           OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">&#125;                                                            OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br></pre></td></tr></table></figure></p><br><ul><br><li>方法名类型为<code>SEL</code>，前面提到过相同名字的方法即使在不同类中定义，它们的方法选择器也相同。  </li><br><li>方法类型<code>method_types</code>是个<code>char</code>指针，其实存储着方法的参数类型和返回值类型。</li><br><li><code>method_imp</code>指向了方法的实现，本质上是一个函数指针，后面会详细讲到。  </li><br></ul><br><h4 id="Ivar">Ivar</h4><p><code>Ivar</code>是一种代表类中实例变量的类型。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_ivar Ivar;</span><br></pre></td></tr></table></figure></p><br><p>而<code>objc_ivar</code>在上面的成员变量列表中也提到过：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_ivar &#123;</span><br><span class="line">    <span class="keyword">char</span> <em>ivar_name                                          OBJC2_UN<span class="built_in">AVAILABLE</span>;</em></span><br><span class="line">    <span class="keyword">char</span> ivar_type                                          OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">int</span> ivar_offset                                          OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line"><span class="preprocessor">#ifdef <strong>LP64</strong></span></span><br><span class="line">    <span class="keyword">int</span> space                                                OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line"><span class="preprocessor">#endif</span></span><br><span class="line">&#125;                                                            OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br></pre></td></tr></table></figure></p><br><h3 id="IMP">IMP</h3><p><code>IMP</code>在<code>objc.h</code>中的定义是：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef id <span class="list">(<span class="keyword"><em>IMP</em></span>)</span><span class="list">(<span class="keyword">id</span>, SEL, …)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p><br><p>它就是一个<a href="http://yulingtianxia.com/blog/2014/04/17/han-shu-zhi-zhen-yu-zhi-zhen-han-shu/" target="_blank" rel="external">函数指针</a>，这是由编译器生成的。当你发起一个 ObjC 消息之后，最终它会执行的那段代码，就是由这个函数指针指定的。而 <code>IMP</code> 这个函数指针就指向了这个方法的实现。既然得到了执行某个实例某个方法的入口，我们就可以绕开消息传递阶段，直接执行方法，这在后面会提到。  </p><br><p>你会发现<code>IMP</code>指向的方法与<code>objc_msgSend</code>函数类型相同，参数都包含<code>id</code>和<code>SEL</code>类型。每个方法名都对应一个<code>SEL</code>类型的方法选择器，而每个实例对象中的<code>SEL</code>对应的方法实现肯定是唯一的，通过一组<code>id</code>和<code>SEL</code>参数就能确定唯一的方法实现地址；反之亦然。  </p><br><h3 id="Cache">Cache</h3><p>在<code>runtime.h</code>中Cache的定义如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_cache Cache</span><br></pre></td></tr></table></figure></p><br><p>还记得之前<code>objc_class</code>结构体中有一个<code>struct objc_cache <em>cache</em></code>吧，它到底是缓存啥的呢，先看看<code>objc_cache</code>的实现：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_cache &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> mask <span class="comment">/ total = mask + 1 <em>/</em></span>                 OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> occupied                                    OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    Method buckets[<span class="number">1</span>]                                        OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><br><p><code>Cache</code>为方法调用的性能进行优化，通俗地讲，每当实例对象接收到一个消息时，它不会直接在<code>isa</code>指向的类的方法列表中遍历查找能够响应消息的方法，因为这样效率太低了，而是优先在<code>Cache</code>中查找。Runtime 系统会把被调用的方法存到<code>Cache</code>中（理论上讲一个方法如果被调用，那么它有可能今后还会被调用），下次查找的时候效率更高。这根计算机组成原理中学过的 CPU 绕过主存先访问<code>Cache</code>的道理挺像，而我猜苹果为提高<code>Cache</code>命中率应该也做了努力吧。  </p><br><h3 id="Property">Property</h3><p><code>@property</code>标记了类中的属性，这个不必多说大家都很熟悉，它是一个指向<code>objc_property</code>结构体的指针：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_property Property;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_property <em><span class="keyword">objc_property_t</span>;<span class="comment">//这个更常用</span></em></span><br></pre></td></tr></table></figure></p><br><p>可以通过<code>class_copyPropertyList</code> 和 <code>protocol_copyPropertyList</code>方法来获取类和协议中的属性：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">objc_property_t</span> class_copyPropertyList(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> <em>outCount)</em></span><br><span class="line"><span class="keyword">objc_property_t</span> protocol_copyPropertyList(Protocol <em>proto, <span class="keyword">unsigned</span> <span class="keyword">int</span> </em>outCount)</span><br></pre></td></tr></table></figure></p><br><p>返回类型为指向指针的指针，哈哈，因为属性列表是个数组，每个元素内容都是一个<code>objc_property_t</code>指针，而这两个函数返回的值是指向这个数组的指针。  </p><br><p>举个栗子，先声明一个类：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@interface</span> <span class="string">Lender :</span> NSObject &#123;</span><br><span class="line">    <span class="typename">float</span> alone;</span><br><span class="line">&#125;</span><br><span class="line"><span class="annotation">@property</span> <span class="typename">float</span> alone;</span><br><span class="line"><span class="annotation">@end</span></span><br></pre></td></tr></table></figure></p><br><p>你可以用下面的代码获取属性列表：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id LenderClass = objc_getClass<span class="list">(<span class="string">“Lender”</span>)</span><span class="comment">;</span></span><br><span class="line">unsigned int outCount<span class="comment">;</span></span><br><span class="line">objc_property_t <em>properties = class_copyPropertyList<span class="list">(<span class="keyword">LenderClass</span>, <span class="keyword">&amp;outCount</span>)</span><span class="comment">;</span></em></span><br></pre></td></tr></table></figure></p><br><p>你可以用<code>property_getName</code>函数来查找属性名称：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> property_getName(<span class="keyword">objc_property_t</span> property)</span><br></pre></td></tr></table></figure></p><br><p>你可以用<code>class_getProperty</code> 和 <code>protocol_getProperty</code>通过给出的名称来在类和协议中获取属性的引用：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">objc_property_t</span> class_getProperty(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> <em>name)</em></span><br><span class="line"><span class="keyword">objc_property_t</span> protocol_getProperty(Protocol proto, <span class="keyword">const</span> <span class="keyword">char</span> <em>name, BOOL isRequiredProperty, BOOL isInstanceProperty)</em></span><br></pre></td></tr></table></figure></p><br><p>你可以用<code>property_getAttributes</code>函数来发掘属性的名称和<code>@encode</code>类型字符串：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> property_getAttributes(<span class="keyword">objc_property_t</span> property)</span><br></pre></td></tr></table></figure></p><br><p>把上面的代码放一起，你就能从一个类中获取它的属性啦：<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">id LenderClass = objc_getClass<span class="params">(<span class="string">“Lender”</span>)</span>;</span><br><span class="line">unsigned int outCount, i;</span><br><span class="line">objc_property_t <span class="built_in"><em></em></span>properties = class_copyPropertyList<span class="params">(LenderClass, &amp;outCount)</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="params">(i = <span class="number">0</span>; i &lt; outCount; i++)</span> &#123;</span><br><span class="line">    objc_property_t property = properties[i];</span><br><span class="line">    fprintf<span class="params">(stdout, <span class="string">“%s %s\n”</span>, property_getName<span class="params">(property)</span>, property_getAttributes<span class="params">(property)</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><br><h2 id="消息">消息</h2><p>前面做了这么多铺垫，现在终于说到了消息了。Objc 中发送消息是用中括号（<code>[]</code>）把接收者和消息括起来，而直到运行时才会把消息与方法实现绑定。  </p><br><h3 id="objc_msgSend函数">objc_msgSend函数</h3><p>在引言中已经对<code>objc_msgSend</code>进行了一点介绍，看起来像是<code>objc_msgSend</code>返回了数据，其实<code>objc_msgSend</code>从不返回数据而是你的方法被调用后返回了数据。下面详细叙述下消息发送步骤： </p><br><ol><br><li>检测这个 <code>selector</code> 是不是要忽略的。比如 Mac OS X 开发，有了垃圾回收就不理会 <code>retain</code>, <code>release</code> 这些函数了。</li><br><li>检测这个 target 是不是 <code>nil</code> 对象。ObjC 的特性是允许对一个 <code>nil</code> 对象执行任何一个方法不会 Crash，因为会被忽略掉。</li><br><li>如果上面两个都过了，那就开始查找这个类的 <code>IMP</code>，先从 <code>cache</code> 里面找，完了找得到就跳到对应的函数去执行。</li><br><li>如果 <code>cache</code> 找不到就找一下方法分发表。</li><br><li>如果分发表找不到就到超类的分发表去找，一直找，直到找到<code>NSObject</code>类为止。  </li><br><li>如果还找不到就要开始进入<strong>动态方法</strong>解析了，后面会提到。  </li><br></ol><br><p>PS:这里说的分发表其实就是<code>Class</code>中的方法列表，它将方法选择器和方法实现地址联系起来。  </p><br><p><img src="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Art/messaging1.gif" alt="">  </p><br><p>其实编译器会根据情况在<code>objc_msgSend</code>, <code>objc_msgSend_stret</code>, <code>objc_msgSendSuper</code>, 或 <code>objc_msgSendSuper_stret</code>四个方法中选择一个来调用。如果消息是传递给超类，那么会调用名字带有”Super”的函数；如果消息返回值是数据结构而不是简单值时，那么会调用名字带有”stret”的函数。排列组合正好四个方法。  </p><br><p>值得一提的是在 i386 平台处理返回类型为浮点数的消息时，需要用到<code>objc_msgSend_fpret</code>函数来进行处理，这是因为返回类型为浮点数的函数对应的 ABI(Application Binary Interface) 与返回整型的函数的 ABI 不兼容。此时<code>objc_msgSend</code>不再适用，于是<code>objc_msgSend_fpret</code>被派上用场，它会对浮点数寄存器做特殊处理。不过在 PPC 或 PPC64 平台是不需要麻烦它的。   </p><br><p>PS：有木有发现这些函数的命名规律哦？带“Super”的是消息传递给超类；“stret”可分为“st”+“ret”两部分，分别代表“struct”和“return”；“fpret”就是“fp”+“ret”，分别代表“floating-point”和“return”。  </p><br><h3 id="方法中的隐藏参数">方法中的隐藏参数</h3><p>我们经常在方法中使用<code>self</code>关键字来引用实例本身，但从没有想过为什么<code>self</code>就能取到调用当前方法的对象吧。其实<code>self</code>的内容是在方法运行时被偷偷的动态传入的。  </p><br><p>当<code>objc_msgSend</code>找到方法对应的实现时，它将直接调用该方法实现，并将消息中所有的参数都传递给方法实现,同时,它还将传递两个隐藏的参数:  </p><br><ul><br><li>接收消息的对象（也就是<code>self</code>指向的内容）</li><br><li>方法选择器（<code>_cmd</code>指向的内容） </li><br></ul><br><p>之所以说它们是隐藏的是因为在源代码方法的定义中并没有声明这两个参数。它们是在代码被编译时被插入实现中的。尽管这些参数没有被明确声明，在源代码中我们仍然可以引用它们。在下面的例子中，<code>self</code>引用了接收者对象，而<code>_cmd</code>引用了方法本身的选择器：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- strange</span><br><span class="line">&#123;</span><br><span class="line">    id  target = getTheReceiver();</span><br><span class="line">    <span class="type">SEL</span> <span class="keyword">method</span> = getTheMethod();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> ( target == self || <span class="keyword">method</span> == _cmd )</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">nil</span>;</span><br><span class="line">    <span class="keyword">return</span> [target performSelector:<span class="keyword">method</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><br><p>在这两个参数中，<code>self</code> 更有用。实际上,它是在方法实现中访问消息接收者对象的实例变量的途径。  </p><br><p>而当方法中的<code>super</code>关键字接收到消息时，编译器会创建一个<code>objc_super</code>结构体：<br><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_super</span> </span>&#123; id receiver; Class class; &#125;;</span><br></pre></td></tr></table></figure></p><br><p>这个结构体指明了消息应该被传递给特定超类的定义。但<code>receiver</code>仍然是<code>self</code>本身，这点需要注意，因为当我们想通过<code>[super class]</code>获取超类时，编译器只是将指向<code>self</code>的<code>id</code>指针和<code>class</code>的SEL传递给了<code>objc_msgSendSuper</code>函数，因为只有在<code>NSObject</code>类才能找到<code>class</code>方法，然后<code>class</code>方法调用<code>object_getClass()</code>，接着调用<code>objc_msgSend(objc_super-&gt;receiver, @selector(class))</code>，传入的第一个参数是指向<code>self</code>的<code>id</code>指针，与调用<code>[self class]</code>相同，所以我们得到的永远都是<code>self</code>的类型。    </p><br><h3 id="获取方法地址">获取方法地址</h3><p>在<code>IMP</code>那节提到过可以避开消息绑定而直接获取方法的地址并调用方法。这种做法很少用，除非是需要持续大量重复调用某方法的极端情况，避开消息发送泛滥而直接调用该方法会更高效。  </p><br><p><code>NSObject</code>类中有个<code>methodForSelector:</code>实例方法，你可以用它来获取某个方法选择器对应的<code>IMP</code>，举个栗子：<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void <span class="comment">(setter)(id, SEL, BOOL);</span><br><span class="line">int i;</span><br><span class="line"> </span><br><span class="line">setter = (void (<em>)</em></span>(id, SEL, BOOL))[target</span><br><span class="line">    methodForSelector:@<span class="keyword">selector</span>(setFilled:)];</span><br><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span> ; i &lt; <span class="number">1000</span> ; i++ )</span><br><span class="line">    setter(targetList[i], @<span class="keyword">selector</span>(setFilled:), YES);</span><br></pre></td></tr></table></figure></p><br><p>当方法被当做函数调用时，上节提到的两个隐藏参数就需要我们明确给出了。上面的例子调用了1000次函数，你可以试试直接给<code>target</code>发送1000次<code>setFilled:</code>消息会花多久。  </p><br><p>PS：<code>methodForSelector:</code>方法是由 Cocoa 的 Runtime 系统提供的，而不是 Objc 自身的特性。  </p><br><h2 id="动态方法解析">动态方法解析</h2><p>你可以动态地提供一个方法的实现。例如我们可以用<code>@dynamic</code>关键字在类的实现文件中修饰一个属性：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="at_rule">@<span class="keyword">dynamic</span> propertyName</span>;</span><br></pre></td></tr></table></figure></p><br><p>这表明我们会为这个属性动态提供存取方法，也就是说编译器不会再默认为我们生成<code>setPropertyName:</code>和<code>propertyName</code>方法，而需要我们动态提供。我们可以通过分别重载<code>resolveInstanceMethod:</code>和<code>resolveClassMethod:</code>方法分别添加实例方法实现和类方法实现。因为当 Runtime 系统在<code>Cache</code>和方法分发表中（包括超类）找不到要执行的方法时，Runtime会调用<code>resolveInstanceMethod:</code>或<code>resolveClassMethod:</code>来给程序员一次动态添加方法实现的机会。我们需要用<code>class_addMethod</code>函数完成向特定类添加特定方法实现的操作：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> dynamicMethodIMP(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd) &#123;</span><br><span class="line">    <span class="comment">// implementation ….</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span></span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)aSEL</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (aSEL == <span class="keyword">@selector</span>(resolveThisMethodDynamically)) &#123;</span><br><span class="line">          class_addMethod([<span class="keyword">self</span> class], aSEL, (IMP) dynamicMethodIMP, <span class="string">“v@:”</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:aSEL];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><br><p>上面的例子为<code>resolveThisMethodDynamically</code>方法添加了实现内容，也就是<code>dynamicMethodIMP</code>方法中的代码。其中 “<code>v@:</code>” 表示返回值和参数，这个符号涉及 <a href="https://developer.apple.com/library/mac/DOCUMENTATION/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html" target="_blank" rel="external">Type Encoding</a>   </p><br><p>PS：动态方法解析会在消息转发机制浸入前执行。如果 <code>respondsToSelector:</code> 或 <code>instancesRespondToSelector:</code>方法被执行，动态方法解析器将会被首先给予一个提供该方法选择器对应的<code>IMP</code>的机会。如果你想让该方法选择器被传送到转发机制，那么就让<code>resolveInstanceMethod:</code>返回<code>NO</code>。  </p><br><h2 id="消息转发">消息转发</h2><p><img src="http://7ni3rk.com1.z0.glb.clouddn.com/QQ20141113-1@2x.png?imageView2/2/w/800/q/75|watermark/2/text/eXVsaW5ndGlhbnhpYQ==/font/Y29taWMgc2FucyBtcw==/fontsize/500/fill/I0VGRUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10" alt="">  </p><br><h3 id="重定向">重定向</h3><p>在消息转发机制执行前，Runtime 系统会再给我们一次偷梁换柱的机会，即通过重载<code>- (id)forwardingTargetForSelector:(SEL)aSelector</code>方法替换消息的接受者为其他对象：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (id)<span class="string">forwardingTargetForSelector:</span>(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(aSelector == <span class="annotation">@selector</span>(<span class="string">mysteriousMethod:</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> alternateObject;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> <span class="string">forwardingTargetForSelector:</span>aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><br><p>毕竟消息转发要耗费更多时间，抓住这次机会将消息重定向给别人是个不错的选择，<del>不过千万别返回<code>self</code>，因为那样会死循环。</del> 如果此方法返回nil或self,则会进入消息转发机制(<code>forwardInvocation:</code>);否则将向返回的对象重新发送消息。  </p><br><h3 id="转发">转发</h3><p>当动态方法解析不作处理返回<code>NO</code>时，消息转发机制会被触发。在这时<code>forwardInvocation:</code>方法会被执行，我们可以重写这个方法来定义我们的转发逻辑：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="typename">void</span>)<span class="string">forwardInvocation:</span>(NSInvocation )anInvocation</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ([someOtherObject <span class="string">respondsToSelector:</span></span><br><span class="line">            [anInvocation selector]])</span><br><span class="line">        [anInvocation <span class="string">invokeWithTarget:</span>someOtherObject];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        [<span class="keyword">super</span> <span class="string">forwardInvocation:</span>anInvocation];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><br><p>该消息的唯一参数是个<code>NSInvocation</code>类型的对象——该对象封装了原始的消息和消息的参数。我们可以实现<code>forwardInvocation:</code>方法来对不能处理的消息做一些默认的处理，也可以将消息转发给其他对象来处理，而不抛出错误。  </p><br><p>这里需要注意的是参数<code>anInvocation</code>是从哪的来的呢？其实在<code>forwardInvocation:</code>消息发送前，Runtime系统会向对象发送<code>methodSignatureForSelector:</code>消息，并取到返回的方法签名用于生成<code>NSInvocation</code>对象。所以我们在重写<code>forwardInvocation:</code>的同时也要重写<code>methodSignatureForSelector:</code>方法，否则会抛异常。  </p><br><p>当一个对象由于没有相应的方法实现而无法响应某消息时，运行时系统将通过<code>forwardInvocation:</code>消息通知该对象。每个对象都从<code>NSObject</code>类中继承了<code>forwardInvocation:</code>方法。然而，<code>NSObject</code>中的方法实现只是简单地调用了<code>doesNotRecognizeSelector:</code>。通过实现我们自己的<code>forwardInvocation:</code>方法，我们可以在该方法实现中将消息转发给其它对象。  </p><br><p><code>forwardInvocation:</code>方法就像一个不能识别的消息的分发中心，将这些消息转发给不同接收对象。或者它也可以象一个运输站将所有的消息都发送给同一个接收对象。它可以将一个消息翻译成另外一个消息，或者简单的”吃掉“某些消息，因此没有响应也没有错误。<code>forwardInvocation:</code>方法也可以对不同的消息提供同样的响应，这一切都取决于方法的具体实现。该方法所提供是将不同的对象链接到消息链的能力。  </p><br><p>注意： <code>forwardInvocation:</code>方法只有在消息接收对象中无法正常响应消息时才会被调用。 所以，如果我们希望一个对象将<code>negotiate</code>消息转发给其它对象，则这个对象不能有<code>negotiate</code>方法。否则，<code>forwardInvocation:</code>将不可能会被调用。  </p><br><h3 id="转发和多继承">转发和多继承</h3><p>转发和继承相似，可以用于为Objc编程添加一些多继承的效果。就像下图那样，一个对象把消息转发出去，就好似它把另一个对象中的方法借过来或是“继承”过来一样。    </p><br><p><img src="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Art/forwarding.gif" alt="">  </p><br><p>这使得不同继承体系分支下的两个类可以“继承”对方的方法，在上图中<code>Warrior</code>和<code>Diplomat</code>没有继承关系，但是<code>Warrior</code>将<code>negotiate</code>消息转发给了<code>Diplomat</code>后，就好似<code>Diplomat</code>是<code>Warrior</code>的超类一样。  </p><br><p>消息转发弥补了 Objc 不支持多继承的性质，也避免了因为多继承导致单个类变得臃肿复杂。它将问题分解得很细，只针对想要借鉴的方法才转发，而且转发机制是透明的。  </p><br><h3 id="替代者对象(Surrogate_Objects)">替代者对象(Surrogate Objects)</h3><p>转发不仅能模拟多继承，也能使轻量级对象代表重量级对象。弱小的女人背后是强大的男人，毕竟女人遇到难题都把它们转发给男人来做了。这里有一些适用案例，可以参看<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtForwarding.html#//apple_ref/doc/uid/TP40008048-CH105-SW11" target="_blank" rel="external">官方文档</a>。  </p><br><h3 id="转发与继承">转发与继承</h3><p>尽管转发很像继承，但是<code>NSObject</code>类不会将两者混淆。像<code>respondsToSelector:</code> 和 <code>isKindOfClass:</code>这类方法只会考虑继承体系，不会考虑转发链。比如上图中一个<code>Warrior</code>对象如果被问到是否能响应<code>negotiate</code>消息：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( [aWarrior respondsToSelector:@<span class="function"><span class="title">selector</span><span class="params">(negotiate)</span></span>] )</span><br><span class="line">    …</span><br></pre></td></tr></table></figure></p><br><p>结果是<code>NO</code>，尽管它能够接受<code>negotiate</code>消息而不报错，因为它靠转发消息给<code>Diplomat</code>类来响应消息。  </p><br><p>如果你为了某些意图偏要“弄虚作假”让别人以为<code>Warrior</code>继承到了<code>Diplomat</code>的<code>negotiate</code>方法，你得重新实现 <code>respondsToSelector:</code> 和 <code>isKindOfClass:</code>来加入你的转发算法：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)respondsToSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( [super respondsToSelector:aSelector] )</span><br><span class="line"><span class="command">        return</span> YES;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        /<em> Here, test whether <span class="keyword">the</span> aSelector message can     </em></span><br><span class="line">         <em> be forwarded <span class="keyword">to</span> another object <span class="keyword">and</span> whether <span class="keyword">that</span>  </em></span><br><span class="line">         <em> object can respond <span class="keyword">to</span> <span class="keyword">it</span>. Return YES <span class="keyword">if</span> <span class="keyword">it</span> can.  </em>/</span><br><span class="line">    &#125;</span><br><span class="line"><span class="command">    return</span> NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><br><p>除了<code>respondsToSelector:</code> 和 <code>isKindOfClass:</code>之外，<code>instancesRespondToSelector:</code>中也应该写一份转发算法。如果使用了协议，<code>conformsToProtocol:</code>同样也要加入到这一行列中。类似地，如果一个对象转发它接受的任何远程消息，它得给出一个<code>methodSignatureForSelector:</code>来返回准确的方法描述，这个方法会最终响应被转发的消息。比如一个对象能给它的替代者对象转发消息，它需要像下面这样实现<code>methodSignatureForSelector:</code>：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (NSMethodSignature<em>)<span class="string">methodSignatureForSelector:</span>(SEL)selector</em></span><br><span class="line">&#123;</span><br><span class="line">    NSMethodSignature signature = [<span class="keyword">super</span> <span class="string">methodSignatureForSelector:</span>selector];</span><br><span class="line">    <span class="keyword">if</span> (!signature) &#123;</span><br><span class="line">       signature = [surrogate <span class="string">methodSignatureForSelector:</span>selector];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> signature;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><br><h2 id="健壮的实例变量(Non_Fragile_ivars)">健壮的实例变量(Non Fragile ivars)</h2><p>在 Runtime 的现行版本中，最大的特点就是健壮的实例变量。当一个类被编译时，实例变量的布局也就形成了，它表明访问类的实例变量的位置。从对象头部开始，实例变量依次根据自己所占空间而产生位移：  </p><br><p><img src="http://7ni3rk.com1.z0.glb.clouddn.com/nf1.png" alt="">  </p><br><p>上图左边是<code>NSObject</code>类的实例变量布局，右边是我们写的类的布局，也就是在超类后面加上我们自己类的实例变量，看起来不错。但试想如果哪天苹果更新了<code>NSObject</code>类，发布新版本的系统的话，那就悲剧了：  </p><br><p><img src="http://7ni3rk.com1.z0.glb.clouddn.com/nf2.png" alt="">  </p><br><p>我们自定义的类被划了两道线，那是因为那块区域跟超类重叠了。唯有苹果将超类改为以前的布局才能拯救我们，但这样也导致它们不能再拓展它们的框架了，因为成员变量布局被死死地固定了。在脆弱的实例变量(Fragile ivars) 环境下我们需要重新编译继承自 Apple 的类来恢复兼容性。那么在健壮的实例变量下会发生什么呢？  </p><br><p><img src="http://7ni3rk.com1.z0.glb.clouddn.com/nf3.png" alt="">  </p><br><p>在健壮的实例变量下编译器生成的实例变量布局跟以前一样，但是当 runtime 系统检测到与超类有部分重叠时它会调整你新添加的实例变量的位移，那样你在子类中新添加的成员就被保护起来了。  </p><br><p>需要注意的是在健壮的实例变量下，不要使用<code>sizeof(SomeClass)</code>，而是用<code>class_getInstanceSize([SomeClass class])</code>代替；也不要使用<code>offsetof(SomeClass, SomeIvar)</code>，而要用<code>ivar_getOffset(class_getInstanceVariable([SomeClass class], &quot;SomeIvar&quot;))</code>来代替。</p><br><h2 id="Objective-C_Associated_Objects">Objective-C Associated Objects</h2><p>在 OS X 10.6 之后，Runtime系统让Objc支持向对象动态添加变量。涉及到的函数有以下三个：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_setAssociatedObject</span> (<span class="params"> id <span class="keyword">object</span>, <span class="keyword">const</span> <span class="keyword">void</span> <em>key, id <span class="keyword">value</span>, objc_AssociationPolicy policy </em></span>)</span>;</span><br><span class="line"><span class="function">id <span class="title">objc_getAssociatedObject</span> (<span class="params"> id <span class="keyword">object</span>, <span class="keyword">const</span> <span class="keyword">void</span> key </span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_removeAssociatedObjects</span> (<span class="params"> id <span class="keyword">object</span> </span>)</span>;</span><br></pre></td></tr></table></figure></p><br><p>这些方法以键值对的形式动态地向对象添加、获取或删除关联值。其中关联政策是一组枚举常量：<br><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line"><span class="constant">   OBJC_ASSOCIATION_ASSIGN</span>  = <span class="number">0</span>,</span><br><span class="line"><span class="constant">   OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>  = <span class="number">1</span>,</span><br><span class="line"><span class="constant">   OBJC_ASSOCIATION_COPY_NONATOMIC</span>  = <span class="number">3</span>,</span><br><span class="line"><span class="constant">   OBJC_ASSOCIATION_RETAIN</span>  = <span class="number">01401</span>,</span><br><span class="line"><span class="constant">   OBJC_ASSOCIATION_COPY</span>  = <span class="number">01403</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><br><p>这些常量对应着引用关联值的政策，也就是 Objc 内存管理的引用计数机制。  </p><br><h2 id="Method_Swizzling">Method Swizzling</h2><p>之前所说的消息转发虽然功能强大，但需要我们了解并且能更改对应类的源代码，因为我们需要实现自己的转发逻辑。当我们无法触碰到某个类的源代码，却想更改这个类某个方法的实现时，该怎么办呢？可能继承类并重写方法是一种想法，但是有时无法达到目的。这里介绍的是 Method Swizzling ，它通过重新映射方法对应的实现来达到“偷天换日”的目的。跟消息转发相比，Method Swizzling 的做法更为隐蔽，甚至有些冒险，也增大了debug的难度。  </p><br><p>这里摘抄一个 NSHipster 的例子：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;objc/runtime.h&gt;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIViewController</span> (<span class="title">Tracking</span>) </span></span><br><span class="line"> </span><br><span class="line">+ (<span class="keyword">void</span>)load &#123; </span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken; </span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123; </span><br><span class="line">        Class aClass = [<span class="keyword">self</span> class]; </span><br><span class="line"> </span><br><span class="line">        SEL originalSelector = <span class="keyword">@selector</span>(viewWillAppear:); </span><br><span class="line">        SEL swizzledSelector = <span class="keyword">@selector</span>(xxx_viewWillAppear:); </span><br><span class="line"> </span><br><span class="line">        Method originalMethod = class_getInstanceMethod(aClass, originalSelector); </span><br><span class="line">        Method swizzledMethod = class_getInstanceMethod(aClass, swizzledSelector); </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// When swizzling a class method, use the following:</span></span><br><span class="line">        <span class="comment">// Class aClass = object_getClass((id)self);</span></span><br><span class="line">        <span class="comment">// …</span></span><br><span class="line">        <span class="comment">// Method originalMethod = class_getClassMethod(aClass, originalSelector);</span></span><br><span class="line">        <span class="comment">// Method swizzledMethod = class_getClassMethod(aClass, swizzledSelector);</span></span><br><span class="line"> </span><br><span class="line">        <span class="built_in">BOOL</span> didAddMethod = </span><br><span class="line">            class_addMethod(aClass, </span><br><span class="line">                originalSelector, </span><br><span class="line">                method_getImplementation(swizzledMethod), </span><br><span class="line">                method_getTypeEncoding(swizzledMethod)); </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (didAddMethod) &#123; </span><br><span class="line">            class_replaceMethod(aClass, </span><br><span class="line">                swizzledSelector, </span><br><span class="line">                method_getImplementation(originalMethod), </span><br><span class="line">                method_getTypeEncoding(originalMethod)); </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            method_exchangeImplementations(originalMethod, swizzledMethod); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="preprocessor">#pragma mark - Method Swizzling </span></span><br><span class="line"> </span><br><span class="line">- (<span class="keyword">void</span>)xxx_viewWillAppear:(<span class="built_in">BOOL</span>)animated &#123; </span><br><span class="line">    [<span class="keyword">self</span> xxx_viewWillAppear:animated]; </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@”viewWillAppear: %@”</span>, <span class="keyword">self</span>); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><br><p>上面的代码通过添加一个<code>Tracking</code>类别到<code>UIViewController</code>类中，将<code>UIViewController</code>类的<code>viewWillAppear:</code>方法和<code>Tracking</code>类别中<code>xxx_viewWillAppear:</code>方法的实现相互调换。Swizzling 应该在<code>+load</code>方法中实现，因为<code>+load</code>是在一个类最开始加载时调用。<code>dispatch_once</code>是GCD中的一个方法，它保证了代码块只执行一次，并让其为一个原子操作，线程安全是很重要的。  </p><br><p>如果类中不存在要替换的方法，那就先用<code>class_addMethod</code>和<code>class_replaceMethod</code>函数添加和替换两个方法的实现；如果类中已经有了想要替换的方法，那么就调用<code>method_exchangeImplementations</code>函数交换了两个方法的 <code>IMP</code>，这是苹果提供给我们用于实现 Method Swizzling 的便捷方法。  </p><br><p>可能有人注意到了这行:</p><br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// <span class="type">When</span> swizzling a class <span class="keyword">method</span>, use the following:</span><br><span class="line">// <span class="type">Class</span> aClass = object_getClass((id)self);</span><br><span class="line">// …</span><br><span class="line">// <span class="type">Method</span> originalMethod = class_getClassMethod(aClass, originalSelector);</span><br><span class="line">// <span class="type">Method</span> swizzledMethod = class_getClassMethod(aClass, swizzledSelector);</span><br></pre></td></tr></table></figure><br><p><code>object_getClass((id)self)</code> 与 <code>[self class]</code> 返回的结果类型都是 <code>Class</code>,但前者为元类,后者为其本身,因为此时 <code>self</code> 为 <code>Class</code> 而不是实例.更多讨论可参考<a href="http://stackoverflow.com/questions/15906130/object-getclassobj-and-obj-class-give-different-results" target="_blank" rel="external">这里</a>.</p><br><p>PS:如果类中没有想被替换实现的原方法时，<code>class_replaceMethod</code>相当于直接调用<code>class_addMethod</code>向类中添加该方法的实现；否则调用<code>method_setImplementation</code>方法，<code>types</code>参数会被忽略。<code>method_exchangeImplementations</code>方法做的事情与如下的原子操作等价：  </p><br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IMP imp1 = method_getImplementation<span class="list">(<span class="keyword">m1</span>)</span><span class="comment">;</span></span><br><span class="line">IMP imp2 = method_getImplementation<span class="list">(<span class="keyword">m2</span>)</span><span class="comment">;</span></span><br><span class="line">method_setImplementation<span class="list">(<span class="keyword">m1</span>, imp2)</span><span class="comment">;</span></span><br><span class="line">method_setImplementation<span class="list">(<span class="keyword">m2</span>, imp1)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><br><p>最后<code>xxx_viewWillAppear:</code>方法的定义看似是递归调用引发死循环，其实不会的。因为<code>[self xxx_viewWillAppear:animated]</code>消息会动态找到<code>xxx_viewWillAppear:</code>方法的实现，而它的实现已经被我们与<code>viewWillAppear:</code>方法实现进行了互换，所以这段代码不仅不会死循环，如果你把<code>[self xxx_viewWillAppear:animated]</code>换成<code>[self viewWillAppear:animated]</code>反而会引发死循环。  </p><br><p>看到有人说<code>+load</code>方法本身就是线程安全的，因为它在程序刚开始就被调用，很少会碰到并发问题，于是 stackoverflow 上也有大神给出了另一个 Method Swizzling 的实现：<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>replacementReceiveMessage:<span class="params">(const struct BInstantMessage *)</span>arg1 &#123;</span><br><span class="line">    NSLog<span class="params">(@<span class="string">“arg1 is %@”</span>, arg1)</span>;</span><br><span class="line">    [self replacementReceiveMessage:arg1];</span><br><span class="line">&#125;</span><br><span class="line">+ <span class="params">(void)</span>load &#123;</span><br><span class="line">    SEL originalSelector = @selector<span class="params">(ReceiveMessage:)</span>;</span><br><span class="line">    SEL overrideSelector = @selector<span class="params">(replacementReceiveMessage:)</span>;</span><br><span class="line">    Method originalMethod = class_getInstanceMethod<span class="params">(self, originalSelector)</span>;</span><br><span class="line">    Method overrideMethod = class_getInstanceMethod<span class="params">(self, overrideSelector)</span>;</span><br><span class="line">    <span class="keyword">if</span> <span class="params">(class_addMethod<span class="params">(self, originalSelector, method_getImplementation<span class="params">(overrideMethod)</span>, method_getTypeEncoding<span class="params">(overrideMethod)</span>)</span>)</span> &#123;</span><br><span class="line">            class_replaceMethod<span class="params">(self, overrideSelector, method_getImplementation<span class="params">(originalMethod)</span>, method_getTypeEncoding<span class="params">(originalMethod)</span>)</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            method_exchangeImplementations<span class="params">(originalMethod, overrideMethod)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><br><p>上面的代码同样要添加在某个类的类别中，相比第一个种实现，只是去掉了<code>dispatch_once</code>部分。<br>Method Swizzling 的确是一个值得深入研究的话题，Method Swizzling 的最佳实现是什么呢？小弟才疏学浅理解的不深刻，找了几篇不错的资源推荐给大家：  </p><br><ul><br><li><a href="http://blog.csdn.net/yiyaaixuexi/article/details/9374411" target="_blank" rel="external">Objective-C的hook方案（一）:  Method Swizzling</a></li><br><li><a href="http://nshipster.com/method-swizzling/" target="_blank" rel="external">Method Swizzling</a>  </li><br><li><a href="http://stackoverflow.com/questions/5371601/how-do-i-implement-method-swizzling" target="_blank" rel="external">How do I implement method swizzling?</a></li><br><li><a href="http://stackoverflow.com/questions/5339276/what-are-the-dangers-of-method-swizzling-in-objective-c" target="_blank" rel="external">What are the Dangers of Method Swizzling in Objective C?</a></li><br><li><a href="https://github.com/rentzsch/jrswizzle" target="_blank" rel="external">JRSwizzle</a></li><br></ul><br><p>在用 SpriteKit 写游戏的时候,因为 API 本身有一些缺陷(增删节点时不考虑父节点是否存在啊,很容易崩溃啊有木有!),我在 Swift 上使用 Method Swizzling弥补这个缺陷:  </p><br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SKNode</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">yxy_swizzleAddChild</span>() </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> cls = <span class="type">SKNode</span>.<span class="keyword">self</span></span><br><span class="line">        <span class="keyword">let</span> originalSelector = <span class="type">Selector</span>(<span class="string">“addChild:”</span>)</span><br><span class="line">        <span class="keyword">let</span> swizzledSelector = <span class="type">Selector</span>(<span class="string">“yxy_addChild:”</span>)</span><br><span class="line">        <span class="keyword">let</span> originalMethod = class_getInstanceMethod(cls, originalSelector)</span><br><span class="line">        <span class="keyword">let</span> swizzledMethod = class_getInstanceMethod(cls, swizzledSelector)</span><br><span class="line">        method_exchangeImplementations(originalMethod, swizzledMethod)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">yxy_swizzleRemoveFromParent</span>() </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> cls = <span class="type">SKNode</span>.<span class="keyword">self</span></span><br><span class="line">        <span class="keyword">let</span> originalSelector = <span class="type">Selector</span>(<span class="string">“removeFromParent”</span>)</span><br><span class="line">        <span class="keyword">let</span> swizzledSelector = <span class="type">Selector</span>(<span class="string">“yxy_removeFromParent”</span>)</span><br><span class="line">        <span class="keyword">let</span> originalMethod = class_getInstanceMethod(cls, originalSelector)</span><br><span class="line">        <span class="keyword">let</span> swizzledMethod = class_getInstanceMethod(cls, swizzledSelector)</span><br><span class="line">        method_exchangeImplementations(originalMethod, swizzledMethod)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">yxy_addChild</span><span class="params">(node: SKNode)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> node.parent == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.yxy_addChild(node)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println</span>(<span class="string">“This node has already a parent!<span class="subst">(node.name)</span>“</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">yxy_removeFromParent</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> parent != <span class="literal">nil</span> &#123;</span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">self</span>.yxy_removeFromParent()</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println</span>(<span class="string">“This node has no parent!<span class="subst">(name)</span>“</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>然后其他地方调用那两个类方法:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SKNode.<span class="function"><span class="title">yxy_swizzleAddChild</span><span class="params">()</span></span></span><br><span class="line">SKNode.<span class="function"><span class="title">yxy_swizzleRemoveFromParent</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></p><br><p>因为 Swift 中的 extension 的特殊性,最好在某个类的<code>load()</code> 方法中调用上面的两个方法.我是在AppDelegate 中调用的,于是保证了应用启动时能够执行上面两个方法.</p><br><h2 id="总结">总结</h2><p>我们之所以让自己的类继承<code>NSObject</code>不仅仅因为苹果帮我们完成了复杂的内存分配问题，更是因为这使得我们能够用上 Runtime 系统带来的便利。可能我们平时写代码时可能很少会考虑一句简单的<code>[receiver message]</code>背后发生了什么，而只是当做方法或函数调用。深入理解 Runtime 系统的细节更有利于我们利用消息机制写出功能更强大的代码，比如 Method Swizzling 等。</p>

<p>文章转载自<br><a href="http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/" target="_blank" rel="external">玉令天下博客的Objective-C Runtime</a>,感谢作者，写的很不错。</p>
<p>下面发一些关于runtime的链接，全看完后，相信会对runtime有很深的理解。</p>
<p><a href="http://quotation.github.io/objc/2015/05/21/objc-runtime-ivar-access.html" target="_blank" rel="external">Objective-C类成员变量深度剖析</a></p>
<p><a href="http://www.jianshu.com/p/425a39d43d16?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=writer_share&amp;utm_source=weibo" target="_blank" rel="external">IMP指针的作用</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&amp;mid=208927760&amp;idx=1&amp;sn=30b9caecba709553e463d719668454ae&amp;scene=2&amp;from=timeline&amp;isappinstalled=0#rd" target="_blank" rel="external">NSInvocation动态调用任意block</a></p>
<p><a href="http://www.cocoachina.com/ios/20150901/13173.html?utm_source=tuicool" target="_blank" rel="external">学习runtime的理解和心得</a></p>
<p><a href="http://www.cocoachina.com/ios/20150907/13336.html?utm_source=tuicool" target="_blank" rel="external">Objective-C 与 Runtime：为什么是这样？</a></p>
<p><a href="http://hechen.info/2015/09/07/Understanding-the-Objective-C-Runtime/?utm_source=tuicool" target="_blank" rel="external">理解Objective-C运行时</a></p>
<p><a href="http://www.tuicool.com/articles/MvM3ie?plg_nld=1&amp;plg_uin=1&amp;plg_auth=1&amp;plg_nld=1&amp;plg_usr=1&amp;plg_vkey=1&amp;plg_dev=1" target="_blank" rel="external">Runtime 隐藏Status Bar背景</a></p>
<p><a href="http://www.tuicool.com/articles/uyaAZjM?plg_nld=1&amp;plg_uin=1&amp;plg_auth=1&amp;plg_nld=1&amp;plg_usr=1&amp;plg_vkey=1&amp;plg_dev=1" target="_blank" rel="external">使用Runtime给Model类赋值</a></p>
<p><a href="http://www.cocoachina.com/ios/20150824/13104.html?utm_source=tuicool" target="_blank" rel="external">iOS 万能跳转界面方法 (runtime实用篇一)</a></p>
<p><a href="http://www.cocoachina.com/cms/wap.php?plg_nld=1&amp;action=article&amp;id=12540&amp;plg_auth=1&amp;plg_uin=1&amp;plg_dev=1&amp;plg_nld=1&amp;plg_usr=1&amp;plg_vkey=1" target="_blank" rel="external">Objective-C特性：Runtime</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文详细整理了 Cocoa 的 Runtime 系统的知识，它使得 Objective-C 如虎添翼，具备了灵活的动态特性，使这门古老的语言焕发生机。主要内容如下： </p>]]>
    
    </summary>
    
      <category term="ios" scheme="http://yimouleng.com/tags/ios/"/>
    
      <category term="runtime" scheme="http://yimouleng.com/tags/runtime/"/>
    
      <category term="iOS开发" scheme="http://yimouleng.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS开发 -- 小数float四舍五入]]></title>
    <link href="http://yimouleng.com/2015/04/23/ios-float-sishewuru/"/>
    <id>http://yimouleng.com/2015/04/23/ios-float-sishewuru/</id>
    <published>2015-04-22T16:00:00.000Z</published>
    <updated>2015-12-09T09:27:56.000Z</updated>
    <content type="html"><![CDATA[<h3 id="float__u56DB_u820D_u4E94_u5165"><a href="#float__u56DB_u820D_u4E94_u5165" class="headerlink" title="float 四舍五入"></a>float 四舍五入</h3><ul>
<li>项目需要一个四舍五入的小功能</li>
<li>简单的说一下，经常用到的方法和问题</li>
</ul>
<a id="more"></a>
<p>先定义一个浮点数类型num</p>
<p><code>float num = 5.672;</code></p>
<p>#####方法一<br>也是最直接的方法  </p>
<p>强制转换为int类型  <code>（int）num</code> 或者<code>[num intValue]</code>,这种方法的问题在于， 它直接去掉了小数点后面的数字 打印结果为 <code>5</code>，不会帮你四舍五入。</p>
<p>#####方法二</p>
<p>网上常用的方法之一， 先定义一个方法。 </p>
<p>//number:需要处理的数字， position：保留小数点第几位，四舍五入</p>
<p><code>+(NSString *)roundUp:(float)number afterPoint:(int)position;</code></p>
<p>在.m文件中实现方法 </p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+(<span class="built_in">NSString</span> *)roundUp:(<span class="keyword">float</span>)number afterPoint:(<span class="keyword">int</span>)position&#123;</span><br><span class="line">    <span class="built_in">NSDecimalNumberHandler</span>* roundingBehavior = [<span class="built_in">NSDecimalNumberHandler</span> decimalNumberHandlerWithRoundingMode:<span class="built_in">NSRoundUp</span> scale:position raiseOnExactness:<span class="literal">NO</span> raiseOnOverflow:<span class="literal">NO</span> raiseOnUnderflow:<span class="literal">NO</span> raiseOnDivideByZero:<span class="literal">NO</span>];</span><br><span class="line">    <span class="built_in">NSDecimalNumber</span> *ouncesDecimal;</span><br><span class="line">    <span class="built_in">NSDecimalNumber</span> *roundedOunces;</span><br><span class="line">    ouncesDecimal = [[<span class="built_in">NSDecimalNumber</span> alloc] initWithFloat:number];</span><br><span class="line">    roundedOunces = [ouncesDecimal decimalNumberByRoundingAccordingToBehavior:roundingBehavior];</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@"</span>,roundedOunces];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用方法<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    NSString *<span class="keyword">sv</span> = [self notRoundin<span class="variable">g:num</span> afterPoin<span class="variable">t:2</span>];</span><br><span class="line">    NSLog(@<span class="string">"sv = %@"</span>,<span class="keyword">sv</span>);</span><br><span class="line">输出结果为：<span class="keyword">sv</span> = <span class="number">5.67</span></span><br></pre></td></tr></table></figure></p>
<p>这种方法同样一夜游一个问题， 在将==position==设置位0的时候， 他也不会四舍五入， 只会向上晋级  打印结果为  <code>6</code></p>
<p>#####方法三(推荐)</p>
<p>也是最简单的方法，系统自带的round函数，直接调用它<code>(int)roundf(float或者double类型的数据)</code></p>
<p><code>(int)roundf(num)</code>输出结果为 <code>5.67</code>,将num改为5.678  输出结果则是<code>5.68</code></p>
<p>严格的说四舍五入的话还是应该用round，不过上面两种方法，在其他特殊的时候也可以尝试使用，比如只需要前边整数，或者需要晋级的数。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="float__u56DB_u820D_u4E94_u5165"><a href="#float__u56DB_u820D_u4E94_u5165" class="headerlink" title="float 四舍五入"></a>float 四舍五入</h3><ul>
<li>项目需要一个四舍五入的小功能</li>
<li>简单的说一下，经常用到的方法和问题</li>
</ul>]]>
    
    </summary>
    
      <category term="四舍五入" scheme="http://yimouleng.com/tags/%E5%9B%9B%E8%88%8D%E4%BA%94%E5%85%A5/"/>
    
      <category term="iOS开发" scheme="http://yimouleng.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS封装 LLPictureShow - 本地/网络图片浏览支持滚动视图]]></title>
    <link href="http://yimouleng.com/2015/03/20/ios-LLPictureShow/"/>
    <id>http://yimouleng.com/2015/03/20/ios-LLPictureShow/</id>
    <published>2015-03-19T16:00:00.000Z</published>
    <updated>2015-12-09T09:25:05.000Z</updated>
    <content type="html"><![CDATA[<h1 id="LLPictureShow"><a href="#LLPictureShow" class="headerlink" title="LLPictureShow"></a>LLPictureShow</h1><p>因公司项目需要，便基于VI修改后封装了一个图片浏览滚动视图，一句话调用。</p>
<h4 id="Github_u5730_u5740"><a href="#Github_u5730_u5740" class="headerlink" title="Github地址"></a>Github地址</h4><p>下载地址<br><a href="https://github.com/yimouleng/LLPictureShow" target="_blank" rel="external">LLPictureShow</a></p>
<a id="more"></a>
<h3 id="u6EDA_u52A8_u89C6_u56FE_u56FE_u7247_u6D4F_u89C8"><a href="#u6EDA_u52A8_u89C6_u56FE_u56FE_u7247_u6D4F_u89C8" class="headerlink" title="滚动视图图片浏览"></a>滚动视图图片浏览</h3><pre><code>1.可以将浏览页面单独使用，也可以直接使用滚动浏览
2.单独页面浏览基于Vi项目修改，加以简化， 可以加载网络图片，本地图片。
3.页面可以高度自定义，浏览模式仿照微信图片浏览
</code></pre><h3 id="u6548_u679C_u56FE"><a href="#u6548_u679C_u56FE" class="headerlink" title="效果图"></a>效果图</h3><pre><code>图片经过压缩，会很模糊，具体效果请下载DEMO自行观看
</code></pre><p><img src="https://raw.githubusercontent.com/yimouleng/LLPictureShow/master/123.gif" alt=""></p>
<h3 id="u4F7F_u7528_u65B9_u6CD5"><a href="#u4F7F_u7528_u65B9_u6CD5" class="headerlink" title="使用方法"></a>使用方法</h3><pre><code>1.单独使用浏览页面   
   直接添加头文件 LLPhotoView.h     
        调用-  (id)initWithFrame:(CGRect)frame andImage:(NSString *)imageStr;方法创建
2.使用滚动试图浏览
    添加头文件 LLPhotoScv.h
        调用 - (id)initWithFrame:(CGRect)frame andImage:(NSArray *)imageArr; 方法创建

3. 具体使用请下载DEMO。
</code></pre><h3 id="u5DF2_u77E5BUG"><a href="#u5DF2_u77E5BUG" class="headerlink" title="已知BUG"></a>已知BUG</h3><p>  暂无。若有发现请及时联系我，同时欢迎各路朋友优化代码。喜欢的可以标星，还不算最终版本，以后会封装优化的更彻底</p>
<h3 id="Blog"><a href="#Blog" class="headerlink" title="Blog"></a>Blog</h3><pre><code>http://yimouleng.com/     
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="LLPictureShow"><a href="#LLPictureShow" class="headerlink" title="LLPictureShow"></a>LLPictureShow</h1><p>因公司项目需要，便基于VI修改后封装了一个图片浏览滚动视图，一句话调用。</p>
<h4 id="Github_u5730_u5740"><a href="#Github_u5730_u5740" class="headerlink" title="Github地址"></a>Github地址</h4><p>下载地址<br><a href="https://github.com/yimouleng/LLPictureShow">LLPictureShow</a></p>]]>
    
    </summary>
    
      <category term="LLPictureShow" scheme="http://yimouleng.com/tags/LLPictureShow/"/>
    
      <category term="scrollView" scheme="http://yimouleng.com/tags/scrollView/"/>
    
      <category term="iOS开发" scheme="http://yimouleng.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS开发 KVC和KVO]]></title>
    <link href="http://yimouleng.com/2015/02/20/kvc-kvo/"/>
    <id>http://yimouleng.com/2015/02/20/kvc-kvo/</id>
    <published>2015-02-19T16:00:00.000Z</published>
    <updated>2015-12-09T09:22:04.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u4E00-KVC_u7684_u4F7F_u7528_u4E0E_u6982_u8FF0"><a href="#u4E00-KVC_u7684_u4F7F_u7528_u4E0E_u6982_u8FF0" class="headerlink" title="一.KVC的使用与概述"></a>一.KVC的使用与概述</h2><p>KVC,即:Key-value coding,它是一种使用字符串标识符，间接访问对象属性的机制，它是很多技术的基础。<br>主要的方法就两个,<code>setValue:forKey</code>，<code>valueForKey</code><br>在Programming Guide中说，使用KVC可以简化代码，但事实上使用起来，还是要看具体情况。</p>
<a id="more"></a>
<p>代码实例：</p>
<p>1.首先定义两个DataModel，这种DataModel定义是无法访问属性的</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">BookData</span> : <span class="title">NSObject</span> </span>&#123;  </span><br><span class="line">    <span class="built_in">NSString</span> * bookName;  </span><br><span class="line">    <span class="keyword">float</span> price;  </span><br><span class="line">    AuthorData * author;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">@end</span>  </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">BookData</span>  </span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AuthorData</span> : <span class="title">NSObject</span> </span>&#123;  </span><br><span class="line">    <span class="built_in">NSString</span> * name;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">@end</span>  </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AuthorData</span>  </span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>2.使用KVC</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="name">BookData</span> * <span class="atom">book1</span> = [[<span class="name">BookData</span> <span class="atom">alloc</span>] <span class="atom">init</span>];  </span><br><span class="line">[<span class="atom">book1</span> <span class="atom">setValue</span>:@<span class="string">"english"</span> <span class="atom">forKey</span>:@<span class="string">"bookName"</span>];  </span><br><span class="line">[<span class="atom">book1</span> <span class="atom">setValue</span>:@<span class="string">"20.0"</span> <span class="atom">forKey</span>:@<span class="string">"price"</span>];  </span><br><span class="line"><span class="name">AuthorData</span> * <span class="atom">author1</span> = [[<span class="name">AuthorData</span> <span class="atom">alloc</span>] <span class="atom">init</span>];  </span><br><span class="line">[<span class="atom">author1</span> <span class="atom">setValue</span>:@<span class="string">"tom"</span> <span class="atom">forKey</span>:@<span class="string">"name"</span>];  </span><br><span class="line">[<span class="atom">book1</span> <span class="atom">setValue</span>:<span class="atom">author1</span> <span class="atom">forKey</span>:@<span class="string">"author"</span>];  </span><br><span class="line">  </span><br><span class="line"><span class="name">NSLog</span>(@<span class="string">"value=%@"</span>,[<span class="atom">book1</span> <span class="atom">valueForKey</span>:@<span class="string">"bookName"</span>]);  </span><br><span class="line"><span class="name">NSLog</span>(@<span class="string">"price=%f"</span>,[[<span class="atom">book1</span> <span class="atom">valueForKey</span>:@<span class="string">"price"</span>] <span class="atom">floatValue</span>]);  </span><br><span class="line"><span class="name">NSLog</span>(@<span class="string">"author=%@"</span>,[<span class="atom">book1</span> <span class="atom">valueForKeyPath</span>:@<span class="string">"author.name"</span>]);  </span><br><span class="line">[<span class="atom">book1</span> <span class="atom">release</span>];</span><br></pre></td></tr></table></figure>
<p>3.注意事项，在使用的时候，Key值不能写错，也就是属性的名字不能写错，大小写也是敏感的。<br>4.回到了最初的问题，应该什么时候使用KVC呢？<br>像上面的这种DataModel定义的方法，从程序员的角度讲，我感觉是不够规范的，起码应该保证正常访问，不管是用系统的get/set方式，或者是自己定义接口(getBookPrice,名字看起来友好一些的)。<br>在官方的Key-Value Observing Programming Guide中有段代码，演示如何简化代码了，有兴趣的朋友可以看看。</p>
<h2 id="u4E8C-KVO_u7684_u4F7F_u7528_u548C_u6982_u8FF0"><a href="#u4E8C-KVO_u7684_u4F7F_u7528_u548C_u6982_u8FF0" class="headerlink" title="二.KVO的使用和概述"></a>二.KVO的使用和概述</h2><p>KVO,即：Key-Value Observing，它提供一种机制，当指定的对象的属性被修改后，则对象就会接受到通知。简单的说就是每次指定的被观察的对象的属性被修改后，KVO就会自动通知相应的观察者了。</p>
<p>系统框架已经支持KVO，所以程序员在使用的时候非常简单。</p>
<ol>
<li>注册，指定被观察者的属性，</li>
<li>实现回调方法</li>
<li>移除观察</li>
</ol>
<p>假设一个场景,股票的价格显示在当前屏幕上，当股票价格更改的时候，实时显示更新其价格。</p>
<p>1.定义DataModel，</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">StockData</span> : <span class="title">NSObject</span> </span>&#123;  </span><br><span class="line">    <span class="built_in">NSString</span> * stockName;  </span><br><span class="line">    <span class="keyword">float</span> price;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">@end</span>  </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">StockData</span>  </span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>2.定义此model为Controller的属性，实例化它，监听它的属性，并显示在当前的View里边</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="typename">void</span>)viewDidLoad  </span><br><span class="line">&#123;  </span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];  </span><br><span class="line">  </span><br><span class="line">    stockForKVO = [[StockData alloc] init];  </span><br><span class="line">    [stockForKVO <span class="string">setValue:</span>@<span class="string">"searph"</span> <span class="string">forKey:</span>@<span class="string">"stockName"</span>];  </span><br><span class="line">    [stockForKVO <span class="string">setValue:</span>@<span class="string">"10.0"</span> <span class="string">forKey:</span>@<span class="string">"price"</span>];      </span><br><span class="line">    [stockForKVO <span class="string">addObserver:</span>self <span class="string">forKeyPath:</span>@<span class="string">"price"</span> <span class="string">options:</span>NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld <span class="string">context:</span>NULL];  </span><br><span class="line">  </span><br><span class="line">    myLabel = [[UILabel alloc]<span class="string">initWithFrame:</span>CGRectMake(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">30</span> )];  </span><br><span class="line">    myLabel.textColor = [UIColor redColor];  </span><br><span class="line">    myLabel.text = [stockForKVO <span class="string">valueForKey:</span>@<span class="string">"price"</span>];  </span><br><span class="line">    [self.view <span class="string">addSubview:</span>myLabel];  </span><br><span class="line">     </span><br><span class="line">    UIButton * b = [UIButton <span class="string">buttonWithType:</span>UIButtonTypeRoundedRect];  </span><br><span class="line">    b.frame = CGRectMake(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">30</span>);  </span><br><span class="line">    [b <span class="string">addTarget:</span>self <span class="string">action:</span><span class="annotation">@selector</span>(buttonAction) <span class="string">forControlEvents:</span>UIControlEventTouchUpInside];  </span><br><span class="line">    [self.view <span class="string">addSubview:</span>b];  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.当点击button的时候，调用buttonAction方法，修改对象的属性</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="typename">void</span>) buttonAction  </span><br><span class="line">&#123;  </span><br><span class="line">    [stockForKVO <span class="string">setValue:</span>@<span class="string">"20.0"</span> <span class="string">forKey:</span>@<span class="string">"price"</span>];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>实现回调方法</li>
</ol>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="typename">void</span>)<span class="string">observeValueForKeyPath:</span>(NSString *)keyPath <span class="string">ofObject:</span>(id)object <span class="string">change:</span>(NSDictionary *)change <span class="string">context:</span>(<span class="typename">void</span> *)context  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">if</span>([keyPath <span class="string">isEqualToString:</span>@<span class="string">"price"</span>])  </span><br><span class="line">    &#123;  </span><br><span class="line">        myLabel.text = [stockForKVO <span class="string">valueForKey:</span>@<span class="string">"price"</span>];  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5.增加观察与取消观察是成对出现的，所以需要在最后的时候，移除观察者</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span> (void)<span class="tag">dealloc</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="attr_selector">[super dealloc]</span>;  </span><br><span class="line">    <span class="attr_selector">[stockForKVO removeObserver:self forKeyPath:@"price"]</span>;  </span><br><span class="line">    <span class="attr_selector">[stockForKVO release]</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>KVO这种编码方式使用起来很简单，很适用与datamodel修改后，引发的UIVIew的变化这种情况，就像上边的例子那样，当更改属性的值后，监听对象会立即得到通知。</p>
<h3 id="u4E09-KVO_u548CKVC_u5B9E_u73B0_u673A_u7406_u5206_u6790"><a href="#u4E09-KVO_u548CKVC_u5B9E_u73B0_u673A_u7406_u5206_u6790" class="headerlink" title="三.KVO和KVC实现机理分析"></a>三.KVO和KVC实现机理分析</h3><p>iPhone程序开发KVO/KVC实现机理分析是本文要介绍的内容，不多说，直接进入话题。我们来看详细内容。<br>Objective-C里面的Key-Value Observing (KVO)机制，非常不错，可以很好的减少浇水代码。关于KVO的学习，可以参考文章：《Key-Value Observing快速入门》：<a href="http://www.cocoadev.cn/Objective-C/Key-Value-Observing-Quick-Start-cn.asp" target="_blank" rel="external">http://www.cocoadev.cn/Objective-C/Key-Value-Observing-Quick-Start-cn.asp</a></p>
<h4 id="Key-Value_Coding_uFF08KVC_uFF09_u5B9E_u73B0_u5206_u6790"><a href="#Key-Value_Coding_uFF08KVC_uFF09_u5B9E_u73B0_u5206_u6790" class="headerlink" title="Key-Value Coding（KVC）实现分析"></a>Key-Value Coding（KVC）实现分析</h4><p>KVC运用了一个isa-swizzling技术。isa-swizzling就是类型混合指针机制。KVC主要通过isa-swizzling，来实现其内部查找定位的。isa指针，如其名称所指，（就是is a kind of的意思），指向维护分发表的对象的类。该分发表实际上包含了指向实现类中的方法的指针，和其它数据。</p>
<p>比如说如下的一行KVC的代码：</p>
<p><code>[site setValue:@&quot;sitename&quot; forKey:@&quot;name&quot;];</code></p>
<p>就会被编译器处理成：</p>
<p>1.SEL sel = sel_get_uid (“setValue:forKey:”);<br>2.IMP method = objc_msg_lookup (site-&gt;isa,sel);<br>3.method(site, sel, @”sitename”, @”name”); </p>
<p>首先介绍两个基本概念：</p>
<p>（1）SEL数据类型：它是编译器运行Objective-C里的方法的环境参数。<br>（2）IMP数据类型：他其实就是一个 编译器内部实现时候的函数指针。当Objective-C编译器去处理实现一个方法的时候，就会指向一个IMP对象，这个对象是C语言表述的类型（事实上，在Objective-C的编译器处理的时候，基本上都是C语言的）。<br>关于如何找到实现函数的指针，可参考文章：《Objective-C如何避免动态绑定，而获得方法地址》：<a href="http://www.cocoadev.cn/Objective-C/Get-method-address.asp" target="_blank" rel="external">http://www.cocoadev.cn/Objective-C/Get-method-address.asp</a></p>
<p>这下KVC内部的实现就很清楚的清楚了：一个对象在调用setValue的时候，（1）首先根据方法名找到运行方法的时候所需要的环境参数。（2）他会从自己isa指针结合环境参数，找到具体的方法实现的接口。（3）再直接查找得来的具体的方法实现。</p>
<h4 id="Key-Value_Observing_uFF08KVO_uFF09_u5B9E_u73B0"><a href="#Key-Value_Observing_uFF08KVO_uFF09_u5B9E_u73B0" class="headerlink" title="Key-Value Observing（KVO）实现"></a>Key-Value Observing（KVO）实现</h4><p>在上面所介绍的KVC机制上加上KVO的自动观察消息通知机制就水到渠成了。<br>当观察者为一个对象的属性进行了注册，被观察对象的isa指针被修改的时候，isa指针就会指向一个中间类，而不是真实的类。所以isa指针其实不需要指向实例对象真实的类。所以我们的程序最好不要依赖于isa指针。在调用类的方法的时候，最好要明确对象实例的类名。<br>熟悉KVO的朋友都知道，只有当我们调用KVC去访问key值的时候KVO才会起作用。所以肯定确定的是，KVO是基于KVC实现的。其实看了上面我们的分析以后，关系KVO的架构的构思也就水到渠成了。<br>因为KVC的实现机制，可以很容易看到某个KVC操作的Key，而后也很容易的跟观察者注册表中的Key进行匹对。假如访问的Key是被观察的Key，那么我们在内部就可以很容易的到观察者注册表中去找到观察者对象，而后给他发送消息。</p>
<p>小结：iPhone程序开发 KVO/KVC实现机理分析的内容介绍完了，希望本文对你有所帮助。</p>
<p>KVC和KVO的使用原则：</p>
<p>一、KVC(key-value-coding)</p>
<p>1、只针对类属性，设置键值对<br>2、设置<code>setValue: forKey:</code>，即<code>forKey</code>只能为类属性<br>3、取值<code>valueForKey</code></p>
<p>二、KVO(key-value-observing)被观察者的属性发生改变时，通知观察者</p>
<p>1、利用KVC对类属性进行设置<br>2、注册observing对象<code>addObserver:forKeyPath:options:context:</code><br>3、观察者类必须重写方法<code>observeValueForKeyPath:ofObject:change:context:</code><br>4、应用，MVC模型中，数据库（dataModal）发生变化时，引起view改变，用这种方式实现非常方便</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u4E00-KVC_u7684_u4F7F_u7528_u4E0E_u6982_u8FF0"><a href="#u4E00-KVC_u7684_u4F7F_u7528_u4E0E_u6982_u8FF0" class="headerlink" title="一.KVC的使用与概述"></a>一.KVC的使用与概述</h2><p>KVC,即:Key-value coding,它是一种使用字符串标识符，间接访问对象属性的机制，它是很多技术的基础。<br>主要的方法就两个,<code>setValue:forKey</code>，<code>valueForKey</code><br>在Programming Guide中说，使用KVC可以简化代码，但事实上使用起来，还是要看具体情况。</p>]]>
    
    </summary>
    
      <category term="KVC" scheme="http://yimouleng.com/tags/KVC/"/>
    
      <category term="KVO" scheme="http://yimouleng.com/tags/KVO/"/>
    
      <category term="iOS开发" scheme="http://yimouleng.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS开发 Socket - AsyncSocket]]></title>
    <link href="http://yimouleng.com/2015/02/04/Socket-AsyncSocket/"/>
    <id>http://yimouleng.com/2015/02/04/Socket-AsyncSocket/</id>
    <published>2015-02-03T16:00:00.000Z</published>
    <updated>2015-12-09T11:27:18.000Z</updated>
    <content type="html"><![CDATA[<p></p><p>一、前言</p><p></p>
<p></p><p><span style="font-size: 12px;">公司的项目用到了Socket编程，之前在学习的过程当中，用到的更多的还是http请求的方式。但是既然用到了就必须学习一下，所以就在网上找一些例子，然后想自己写一个demo。可是发现很多写iOS Socket的博客并没有很详细的说明，也可能是大神们觉得其他东西都浅显易懂。</span></p><br><a id="more"></a><p></p>
<p></p><p><span style="font-size: 12px;">自己专研了一下，将自己的一些理解总结出来，一方面整理自己的学习思路，另一方面，为一些和我有同样困惑的小伙伴们，稍做指引。</span></p><p></p>
<p><hr></p>
<p></p><p>&nbsp;<span style="font-size: 12px;"><span style="font-size: 13px;">二、</span></span>AsyncSocket介绍</p><p></p>
<p></p><p><span style="font-size: 12px;">1⃣️iOS中Socket编程的方式有哪些？</span></p><p></p>
<p></p><p><span style="font-size: 12px;">－BSD Socket</span></p><p></p>
<p></p><p><span style="font-size: 12px;">BSD Socket 是UNIX系统中通用的网络接口，它不仅支持各种不同的网络类型，而且也是一种内部进程之间的通信机制。而iOS系统其实本质就是UNIX，所以可以用，但是比较复杂。</span></p><p></p>
<p></p><p><span style="font-size: 12px;">－CFSocket</span></p><p></p>
<p></p><p><span style="font-size: 12px;">CFSocket是苹果提供给我们的使用Socket的方式，但是用起来还是会不太顺手。当然想使用的话，可以细细研究一下。</span></p><p></p>
<p></p><p><span style="font-size: 12px;">－AsyncSocket</span></p><p></p>
<p></p><p><span style="font-size: 12px;">这次博客的主讲内容，也是我们在开发项目中经常会用到的。</span></p><p></p>
<p></p><p><span style="font-size: 12px;">2⃣️为什么选择AsyncSocket？</span></p><p></p>
<p></p><p><span style="font-size: 12px;">iphone的CFNetwork编程比较艰深。使用AsyncSocket开源库来开发相对较简单，帮助我们封装了很多东西。</span></p><p></p>
<p><hr></p>
<p></p><p><span style="font-size: 14px;">三、AsyncSocket详解</span></p><p></p>
<p></p><p><span style="font-size: 12px;">&nbsp;1⃣️说明</span></p><p></p>
<p></p><p><span style="font-size: 12px;">在我们开发当中，我们主要的任务是开发客户端。所以详解里主要将客户端的整个连接建立过程，以及在说明时候回调哪些函数。在后面的示例代码中，也会给出服务器端的简单开发。</span></p><p></p>
<p></p><p><span style="font-size: 12px;">2⃣️过程详解</span></p><p></p>
<p></p><p><span style="font-size: 12px;">1.建立连接</span></p><p></p>
<p></p><p><span style="font-size: 12px;">- (int)connectServer:(NSString *)hostIP port:(int)hostPort</span></p><p></p>
<p></p><p><span style="font-size: 12px;">2.连接成功后，会回调的函数</span></p><p></p>
<p></p><p><span style="font-size: 12px;">- (void)onSocket:(AsyncSocket <em>)sock didConnectToHost:(NSString </em>)host port:(UInt16)port</span></p><p></p>
<p></p><p><span style="font-size: 12px;">3.发送数据</span></p><p></p>
<p></p><p><span style="font-size: 12px;">- (void)writeData:(NSData *)data withTimeout:(NSTimeInterval)timeout tag:(long)tag;</span></p><p></p>
<p></p><p><span style="font-size: 12px;">4.接受数据</span></p><p></p>
<p></p><p><span style="font-size: 12px;">-(void)onSocket:(AsyncSocket <em>)sock didReadData:(NSData </em>)data withTag:(long)tag</span></p><p></p>
<p></p><p><span style="font-size: 12px;">5.断开连接</span></p><p></p>
<p></p><p><span style="font-size: 12px;">- (void)onSocket:(AsyncSocket <em>)sock willDisconnectWithError:(NSError </em>)err</span></p><p></p>
<p></p><p><span style="font-size: 12px;">- (void)onSocketDidDisconnect:(AsyncSocket *)sock</span></p><p></p>
<p></p><p><span style="font-size: 12px;">主要就是上述的几个方法，只是说在真正开发当中，很可能我们在收发数据的时候，我们收发的数据并不仅仅是一个字符串包装成NSData即可，我们很可能会发送结构体等类型，这个时候我们就需要和服务器端的人员协作来开发：定义怎样的结构体。</span></p><p></p>
<p><hr></p>
<p></p><p>四、AsyncSocket示例</p><p></p>
<p></p><p>客户端代码</p><p></p>
<div class="cnblogs_code"><br><pre><span style="color: #0000ff;">#import</span> <span style="color: #800000;">“</span><span style="color: #800000;">ViewController.h</span><span style="color: #800000;">“</span><br><br><span style="color: #0000ff;">#define</span> SRV_CONNECTED 0<br><span style="color: #0000ff;">#define</span> SRV_CONNECT_SUC 1<br><span style="color: #0000ff;">#define</span> SRV_CONNECT_FAIL 2<br><span style="color: #0000ff;">#define</span> HOST_IP @”192.168.83.40”<br><span style="color: #0000ff;">#define</span> HOST_PORT 8008<br><br><span style="color: #0000ff;">@interface</span><span style="color: #000000;"> ViewController ()<br>{<br>    NSString </span><em><span style="color: #000000;">_content;<br>}<br></span>-(<span style="color: #0000ff;">int</span>) connectServer: (NSString </em>) hostIP port:(<span style="color: #0000ff;">int</span><span style="color: #000000;">) hostPort;<br></span>-(<span style="color: #0000ff;">void</span>)showMessage:(NSString <em><span style="color: #000000;">) msg;<br></span><span style="color: #0000ff;">@end</span><br><br><span style="color: #0000ff;">@implementation</span><span style="color: #000000;"> ViewController<br><br></span><span style="color: #0000ff;">@synthesize</span><span style="color: #000000;"> clientSocket,tbInputMsg,lblOutputMsg;<br><br></span><span style="color: #0000ff;">#pragma</span> mark - view lifecycle<br>- (<span style="color: #0000ff;">void</span><span style="color: #000000;">)viewDidLoad<br>{<br>    [super viewDidLoad];<br><br>    [self connectServer:HOST_IP port:HOST_PORT];<br>}<br></span>- (<span style="color: #0000ff;">void</span><span style="color: #000000;">)viewDidUnload<br>{<br>    [super viewDidUnload];<br>    [clientSocket release], clientSocket </span>=<span style="color: #000000;"> nil;<br>    [tbInputMsg release], tbInputMsg </span>=<span style="color: #000000;"> nil;<br>    [lblOutputMsg release], lblOutputMsg </span>=<span style="color: #000000;"> nil;<br>}<br><br></span>- (<span style="color: #0000ff;">int</span>)connectServer:(NSString </em>)hostIP port:(<span style="color: #0000ff;">int</span><span style="color: #000000;">)hostPort<br>{<br>    </span><span style="color: #0000ff;">if</span> (clientSocket ==<span style="color: #000000;"> nil)<br>    {<br>        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 在需要联接地方使用connectToHost联接服务器</span><br>        clientSocket =<span style="color: #000000;"> [[AsyncSocket alloc] initWithDelegate:self];<br>        NSError </span><em>err =<span style="color: #000000;"> nil;<br>        </span><span style="color: #0000ff;">if</span> (![clientSocket connectToHost:hostIP onPort:hostPort error:&amp;<span style="color: #000000;">err])<br>        {<br>            NSLog(</span><span style="color: #800000;">@”</span><span style="color: #800000;">Error %d:%@</span><span style="color: #800000;">“</span><span style="color: #000000;">, err.code, [err localizedDescription]);<br><br>            UIAlertView </span></em>alert = [[UIAlertView alloc] initWithTitle:[<span style="color: #800000;">@”</span><span style="color: #800000;">Connection failed to host</span><span style="color: #800000;">“</span> stringByAppendingString:hostIP] message:[NSString stringWithFormat:<span style="color: #800000;">@”</span><span style="color: #800000;">%d:%@</span><span style="color: #800000;">“</span>,err.code,err.localizedDescription] <span style="color: #0000ff;">delegate</span>:self cancelButtonTitle:<span style="color: #800000;">@”</span><span style="color: #800000;">OK</span><span style="color: #800000;">“</span><span style="color: #000000;"> otherButtonTitles:nil];<br>            [alert show];<br>            [alert release];<br>            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> SRV_CONNECT_FAIL;<br>        } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {<br>            NSLog(</span><span style="color: #800000;">@”</span><span style="color: #800000;">Connected!</span><span style="color: #800000;">“</span><span style="color: #000000;">);<br>            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> SRV_CONNECT_SUC;<br>        }<br>    }<br>    </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {<br>        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> SRV_CONNECTED;<br>    }<br>}<br><br></span><span style="color: #0000ff;">#pragma</span> mark - IBAction<br><span style="color: #008000;">//</span><span style="color: #008000;"> 发送数据</span><br>- (IBAction) sendMsg:(<span style="color: #0000ff;">id</span><span style="color: #000000;">)sender<br>{<br>    NSString </span><em>inputMsgStr =<span style="color: #000000;"> tbInputMsg.text;<br>    NSString </span></em> content = [inputMsgStr stringByAppendingString:<span style="color: #800000;">@”</span><span style="color: #800000;">\r\n</span><span style="color: #800000;">“</span><span style="color: #000000;">];<br>    NSLog(</span><span style="color: #800000;">@”</span><span style="color: #800000;">%@</span><span style="color: #800000;">“</span><span style="color: #000000;">,content);<br>    NSData </span><em>data =<span style="color: #000000;"> [content dataUsingEncoding:NSUTF8StringEncoding];<br>    </span><span style="color: #008000;">//</span><span style="color: #008000;"> NSData </span></em>data = [content dataUsingEncoding:NSISOLatin1StringEncoding];<br>    [clientSocket writeData:data withTimeout:-<span style="color: #800080;">1</span> tag:<span style="color: #800080;">0</span><span style="color: #000000;">];<br>}<br></span><span style="color: #008000;">//</span><span style="color: #008000;"> 连接/重新连接</span><br>- (IBAction) reconnect:(<span style="color: #0000ff;">id</span><span style="color: #000000;">)sender<br>{<br>    </span><span style="color: #0000ff;">int</span> stat =<span style="color: #000000;"> [self connectServer:HOST_IP port:HOST_PORT];<br>    </span><span style="color: #0000ff;">switch</span><span style="color: #000000;"> (stat) {<br>        </span><span style="color: #0000ff;">case</span><span style="color: #000000;"> SRV_CONNECT_SUC:<br>            [self showMessage:</span><span style="color: #800000;">@”</span><span style="color: #800000;">connect success</span><span style="color: #800000;">“</span><span style="color: #000000;">];<br>            </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;<br>        </span><span style="color: #0000ff;">case</span><span style="color: #000000;"> SRV_CONNECTED:<br>            [self showMessage:</span><span style="color: #800000;">@”</span><span style="color: #800000;">It’s connected,don’t agian</span><span style="color: #800000;">“</span><span style="color: #000000;">];<br>            </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;<br>        </span><span style="color: #0000ff;">default</span><span style="color: #000000;">:<br>            </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;<br>    }<br>}<br></span>- (<span style="color: #0000ff;">void</span>)showMessage:(NSString <em><span style="color: #000000;">)msg<br>{<br>    UIAlertView </span></em> alert = [[UIAlertView alloc]initWithTitle:<span style="color: #800000;">@”</span><span style="color: #800000;">Alert!</span><span style="color: #800000;">“</span><span style="color: #000000;"><br>                                                    message:msg<br>                                                   </span><span style="color: #0000ff;">delegate</span><span style="color: #000000;">:nil<br>                                          cancelButtonTitle:</span><span style="color: #800000;">@”</span><span style="color: #800000;">OK</span><span style="color: #800000;">“</span><span style="color: #000000;"><br>                                          otherButtonTitles:nil];<br>    [alert show];<br>    [alert release];<br>}<br></span>- (IBAction)textFieldDoneEditing:(<span style="color: #0000ff;">id</span><span style="color: #000000;">)sender<br>{<br>    [tbInputMsg resignFirstResponder];<br>}<br></span>- (IBAction)backgroundTouch:(<span style="color: #0000ff;">id</span><span style="color: #000000;">)sender<br>{<br>    [tbInputMsg resignFirstResponder];<br>}<br><br></span><span style="color: #0000ff;">#pragma</span> mark socket delegate<br>- (<span style="color: #0000ff;">void</span>)onSocket:(AsyncSocket <em>)sock didConnectToHost:(NSString </em><span style="color: #000000;">)host port:(UInt16)port<br>{<br>    [clientSocket readDataWithTimeout:</span>-<span style="color: #800080;">1</span> tag:<span style="color: #800080;">0</span><span style="color: #000000;">];<br>}<br><br></span>- (<span style="color: #0000ff;">void</span>)onSocket:(AsyncSocket <em>)sock willDisconnectWithError:(NSError </em><span style="color: #000000;">)err<br>{<br>    NSLog(</span><span style="color: #800000;">@”</span><span style="color: #800000;">Error</span><span style="color: #800000;">“</span><span style="color: #000000;">);<br>}<br><br></span>- (<span style="color: #0000ff;">void</span>)onSocketDidDisconnect:(AsyncSocket <em><span style="color: #000000;">)sock<br>{<br>    NSString </span></em>msg = <span style="color: #800000;">@”</span><span style="color: #800000;">Sorry this connect is failure</span><span style="color: #800000;">“</span><span style="color: #000000;">;<br>    [self showMessage:msg];<br>    [msg release];<br>    clientSocket </span>=<span style="color: #000000;"> nil;<br>}<br><br></span>- (<span style="color: #0000ff;">void</span>)onSocketDidSecure:(AsyncSocket <em><span style="color: #000000;">)sock<br>{<br>}<br><br></span><span style="color: #008000;">//</span><span style="color: #008000;"> 接收到数据（可以通过tag区分）</span><br>-(<span style="color: #0000ff;">void</span>)onSocket:(AsyncSocket </em>)sock didReadData:(NSData <em>)data withTag:(<span style="color: #0000ff;">long</span><span style="color: #000000;">)tag<br>{<br>    NSString</span></em> aStr =<span style="color: #000000;"> [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];<br>    _content </span>=<span style="color: #000000;"> lblOutputMsg.text;<br>    NSLog(</span><span style="color: #800000;">@”</span><span style="color: #800000;">Hava received datas is :%@</span><span style="color: #800000;">“</span><span style="color: #000000;">,aStr);<br>    NSString </span><em>newStr = [NSString stringWithFormat:<span style="color: #800000;">@”</span><span style="color: #800000;">\n%@</span><span style="color: #800000;">“</span><span style="color: #000000;">, aStr];<br>    lblOutputMsg.text </span>=<span style="color: #000000;"> [_content stringByAppendingString:newStr];<br>    [aStr release];<br>    [clientSocket readDataWithTimeout:</span>-<span style="color: #800080;">1</span> tag:<span style="color: #800080;">0</span><span style="color: #000000;">];<br>}<br><br></span><span style="color: #0000ff;">@end</span></em></pre><br></div><br><p>服务器端代码</p><br><div class="cnblogs_code"><br><pre><span style="color: #0000ff;">#import</span> <span style="color: #800000;">“</span><span style="color: #800000;">SocketView.h</span><span style="color: #800000;">“</span><br><span style="color: #0000ff;">#import</span> <span style="color: #800000;">“</span><span style="color: #800000;">AsyncSocket.h</span><span style="color: #800000;">“</span><br><br><span style="color: #0000ff;">#define</span> WELCOME_MSG  0<br><span style="color: #0000ff;">#define</span> ECHO_MSG     1<br><br><span style="color: #0000ff;">#define</span> FORMAT(format, …) [NSString stringWithFormat:(format), ##<strong>VA_ARGS</strong>]<br><br><span style="color: #0000ff;">@interface</span><span style="color: #000000;"> SocketView (PrivateAPI)<br></span>- (<span style="color: #0000ff;">void</span>)logError:(NSString <span style="color: #000000;">)msg;<br></span>- (<span style="color: #0000ff;">void</span>)logInfo:(NSString <em><span style="color: #000000;">)msg;<br></span>- (<span style="color: #0000ff;">void</span>)logMessage:(NSString </em><span style="color: #000000;">)msg;<br></span><span style="color: #0000ff;">@end</span><br><br><span style="color: #0000ff;">@implementation</span><span style="color: #000000;"> SocketView<br><br></span><span style="color: #008000;">//</span><span style="color: #008000;"> 初始化</span><br>- (<span style="color: #0000ff;">void</span><span style="color: #000000;">)awakeFromNib<br>{<br>    listenSocket </span>=<span style="color: #000000;"> [[AsyncSocket alloc] initWithDelegate:self];<br>    [listenSocket setRunLoopModes:[NSArray arrayWithObject:NSRunLoopCommonModes]];<br><br>    connectedSockets </span>= [[NSMutableArray alloc] initWithCapacity:<span style="color: #800080;">1</span><span style="color: #000000;">];<br>    isRunning </span>=<span style="color: #000000;"> NO;<br><br>    [logView setString:</span><span style="color: #800000;">@””</span><span style="color: #000000;">];<br>    </span><span style="color: #008000;">//</span><span style="color: #008000;"> [portField setString:@”8080”];</span><br><span style="color: #000000;">}<br><br></span>- (IBAction)startStop:(<span style="color: #0000ff;">id</span><span style="color: #000000;">)sender<br>{<br>    </span><span style="color: #0000ff;">if</span>(!<span style="color: #000000;">isRunning)<br>    {<br>        </span><span style="color: #0000ff;">int</span> port =<span style="color: #000000;"> [portField intValue];<br><br>        </span><span style="color: #0000ff;">if</span>(port &lt; <span style="color: #800080;">0</span> || port &gt; <span style="color: #800080;">65535</span><span style="color: #000000;">)<br>        {<br>            port </span>= <span style="color: #800080;">0</span>; <span style="color: #008000;">//</span><span style="color: #008000;"> 会随即取端口</span><br><span style="color: #000000;">        }<br><br>        NSError </span><em>error =<span style="color: #000000;"> nil;<br>        </span><span style="color: #0000ff;">if</span>(![listenSocket acceptOnPort:port error:&amp;<span style="color: #000000;">error])<br>        {<br>            [self logError:FORMAT(</span><span style="color: #800000;">@”</span><span style="color: #800000;">Error starting server: %@</span><span style="color: #800000;">“</span><span style="color: #000000;">, error)];<br>            </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;<br>        }<br><br>        [self logInfo:FORMAT(</span><span style="color: #800000;">@”</span><span style="color: #800000;">Echo server started on port %hu</span><span style="color: #800000;">“</span><span style="color: #000000;">, [listenSocket localPort])];<br>        isRunning </span>=<span style="color: #000000;"> YES;<br><br>        [portField setEnabled:NO];<br>        [startStopButton setTitle:</span><span style="color: #800000;">@”</span><span style="color: #800000;">Stop</span><span style="color: #800000;">“</span><span style="color: #000000;">];<br>    }<br>    </span><span style="color: #0000ff;">else</span><span style="color: #000000;"><br>    {<br>        </span><span style="color: #008000;">//</span><span style="color: #008000;"> Stop accepting connections</span><br><span style="color: #000000;">        [listenSocket disconnect];<br><br>        </span><span style="color: #008000;">//</span><span style="color: #008000;"> Stop any client connections</span><br>        <span style="color: #0000ff;">int</span><span style="color: #000000;"> i;<br>        </span><span style="color: #0000ff;">for</span>(i = <span style="color: #800080;">0</span>; i &lt; [connectedSockets count]; i++<span style="color: #000000;">)<br>        {<br>            </span><span style="color: #008000;">//</span><span style="color: #008000;"> Call disconnect on the socket,<br>            </span><span style="color: #008000;">//</span><span style="color: #008000;"> which will invoke the onSocketDidDisconnect: method,<br>            </span><span style="color: #008000;">//</span><span style="color: #008000;"> which will remove the socket from the list.</span><br><span style="color: #000000;">            [[connectedSockets objectAtIndex:i] disconnect];<br>        }<br><br>        [self logInfo:</span><span style="color: #800000;">@”</span><span style="color: #800000;">Stopped Echo server</span><span style="color: #800000;">“</span><span style="color: #000000;">];<br>        isRunning </span>= <span style="color: #0000ff;">false</span><span style="color: #000000;">;<br><br>        [portField setEnabled:YES];<br>        [startStopButton setTitle:</span><span style="color: #800000;">@”</span><span style="color: #800000;">Start</span><span style="color: #800000;">“</span><span style="color: #000000;">];<br>    }<br>}<br><br></span>- (<span style="color: #0000ff;">void</span><span style="color: #000000;">)scrollToBottom<br>{<br>    NSScrollView </span></em>scrollView =<span style="color: #000000;"> [logView enclosingScrollView];<br>    NSPoint newScrollOrigin;<br><br>    </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> ([[scrollView documentView] isFlipped])<br>        newScrollOrigin </span>= NSMakePoint(<span style="color: #800080;">0.0</span><span style="color: #000000;">, NSMaxY([[scrollView documentView] frame]));<br>    </span><span style="color: #0000ff;">else</span><span style="color: #000000;"><br>        newScrollOrigin </span>= NSMakePoint(<span style="color: #800080;">0.0</span>, <span style="color: #800080;">0.0</span><span style="color: #000000;">);<br><br>    [[scrollView documentView] scrollPoint:newScrollOrigin];<br>}<br><br></span>- (<span style="color: #0000ff;">void</span>)logError:(NSString <em><span style="color: #000000;">)msg<br>{<br>    NSString </span></em>paragraph = [NSString stringWithFormat:<span style="color: #800000;">@”</span><span style="color: #800000;">%@\n</span><span style="color: #800000;">“</span><span style="color: #000000;">, msg];<br><br>    NSMutableDictionary </span><em>attributes = [NSMutableDictionary dictionaryWithCapacity:<span style="color: #800080;">1</span><span style="color: #000000;">];<br>    [attributes setObject:[NSColor redColor] forKey:NSForegroundColorAttributeName];<br><br>    NSAttributedString </span></em><span style="color: #0000ff;">as</span> =<span style="color: #000000;"> [[NSAttributedString alloc] initWithString:paragraph attributes:attributes];<br>    [</span><span style="color: #0000ff;">as</span><span style="color: #000000;"> autorelease];<br><br>    [[logView textStorage] appendAttributedString:</span><span style="color: #0000ff;">as</span><span style="color: #000000;">];<br>    [self scrollToBottom];<br>}<br><br></span>- (<span style="color: #0000ff;">void</span>)logInfo:(NSString <em><span style="color: #000000;">)msg<br>{<br>    NSString </span></em>paragraph = [NSString stringWithFormat:<span style="color: #800000;">@”</span><span style="color: #800000;">%@\n</span><span style="color: #800000;">“</span><span style="color: #000000;">, msg];<br><br>    NSMutableDictionary </span><em>attributes = [NSMutableDictionary dictionaryWithCapacity:<span style="color: #800080;">1</span><span style="color: #000000;">];<br>    [attributes setObject:[NSColor purpleColor] forKey:NSForegroundColorAttributeName];<br><br>    NSAttributedString </span></em><span style="color: #0000ff;">as</span> =<span style="color: #000000;"> [[NSAttributedString alloc] initWithString:paragraph attributes:attributes];<br>    [</span><span style="color: #0000ff;">as</span><span style="color: #000000;"> autorelease];<br><br>    [[logView textStorage] appendAttributedString:</span><span style="color: #0000ff;">as</span><span style="color: #000000;">];<br>    [self scrollToBottom];<br>}<br><br></span>- (<span style="color: #0000ff;">void</span>)logMessage:(NSString <em><span style="color: #000000;">)msg<br>{<br>    NSString </span></em>paragraph = [NSString stringWithFormat:<span style="color: #800000;">@”</span><span style="color: #800000;">%@\n</span><span style="color: #800000;">“</span><span style="color: #000000;">, msg];<br><br>    NSMutableDictionary </span><em>attributes = [NSMutableDictionary dictionaryWithCapacity:<span style="color: #800080;">1</span><span style="color: #000000;">];<br>    [attributes setObject:[NSColor blackColor] forKey:NSForegroundColorAttributeName];<br><br>    NSAttributedString </span></em><span style="color: #0000ff;">as</span> =<span style="color: #000000;"> [[NSAttributedString alloc] initWithString:paragraph attributes:attributes];<br>    [</span><span style="color: #0000ff;">as</span><span style="color: #000000;"> autorelease];<br><br>    [[logView textStorage] appendAttributedString:</span><span style="color: #0000ff;">as</span><span style="color: #000000;">];<br>    [self scrollToBottom];<br>}<br><br></span>- (<span style="color: #0000ff;">void</span>)onSocket:(AsyncSocket <em>)sock didAcceptNewSocket:(AsyncSocket </em><span style="color: #000000;">)newSocket<br>{<br>    [connectedSockets addObject:newSocket];<br>}<br><br></span><span style="color: #008000;">//</span><span style="color: #008000;"> 客户连接成功！</span><br>- (<span style="color: #0000ff;">void</span>)onSocket:(AsyncSocket <em>)sock didConnectToHost:(NSString </em><span style="color: #000000;">)host port:(UInt16)port<br>{<br>    [self logInfo:FORMAT(</span><span style="color: #800000;">@”</span><span style="color: #800000;">Accepted client %@:%hu</span><span style="color: #800000;">“</span><span style="color: #000000;">, host, port)];<br><br>    NSString </span><em>welcomeMsg = <span style="color: #800000;">@”</span><span style="color: #800000;">恭喜您,已经通过scoket连接上服务器!</span><span style="color: #800000;">“</span><span style="color: #000000;">;<br>    NSData </span></em>welcomeData =<span style="color: #000000;"> [welcomeMsg dataUsingEncoding:NSUTF8StringEncoding];<br><br>    [sock writeData:welcomeData withTimeout:</span>-<span style="color: #800080;">1</span><span style="color: #000000;"> tag:WELCOME_MSG];<br><br>    </span><span style="color: #008000;">//</span><span style="color: #008000;"> We could call readDataToData:withTimeout:tag: here - that would be perfectly fine.<br>    </span><span style="color: #008000;">//</span><span style="color: #008000;"> If we did this, we’d want to add a check in onSocket:didWriteDataWithTag: and only<br>    </span><span style="color: #008000;">//</span><span style="color: #008000;"> queue another read if tag != WELCOME_MSG.</span><br><span style="color: #000000;">}<br><br></span>- (<span style="color: #0000ff;">void</span>)onSocket:(AsyncSocket <em>)sock didWriteDataWithTag:(<span style="color: #0000ff;">long</span><span style="color: #000000;">)tag<br>{<br>   [sock readDataToData:[AsyncSocket CRLFData] withTimeout:</span>-<span style="color: #800080;">1</span> tag:<span style="color: #800080;">0</span><span style="color: #000000;">];<br>}<br></span><span style="color: #008000;">//</span><span style="color: #008000;"> 接收到数据</span><br>- (<span style="color: #0000ff;">void</span>)onSocket:(AsyncSocket </em>)sock didReadData:(NSData <em>)data withTag:(<span style="color: #0000ff;">long</span><span style="color: #000000;">)tag<br>{<br>    NSData </span></em>strData = [data subdataWithRange:NSMakeRange(<span style="color: #800080;">0</span>, [data length] - <span style="color: #800080;">2</span><span style="color: #000000;">)];<br>    NSString </span><em>recvMsg =<span style="color: #000000;"> [[[NSString alloc] initWithData:strData encoding:NSUTF8StringEncoding] autorelease];<br>    </span><span style="color: #0000ff;">if</span><span style="color: #000000;">(recvMsg)<br>    {<br>        [self logMessage:recvMsg];<br>    }<br>    </span><span style="color: #0000ff;">else</span><span style="color: #000000;"><br>    {<br>        [self logError:</span><span style="color: #800000;">@”</span><span style="color: #800000;">Error converting received data into UTF-8 String</span><span style="color: #800000;">“</span><span style="color: #000000;">];<br>    }<br>    NSString </span></em>backStr =<span style="color: #000000;"> nil;<br>    </span><span style="color: #0000ff;">for</span> (AsyncSocket <em>socket <span style="color: #0000ff;">in</span><span style="color: #000000;"> connectedSockets) {<br>        </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> ([sock isEqualTo:socket]) {<br>            backStr </span>= [NSString stringWithFormat:<span style="color: #800000;">@”</span><span style="color: #800000;">我说: %@</span><span style="color: #800000;">“</span><span style="color: #000000;">,recvMsg];<br>        } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {<br>            backStr </span>= [NSString stringWithFormat:<span style="color: #800000;">@”</span><span style="color: #800000;">他说: %@</span><span style="color: #800000;">“</span><span style="color: #000000;">,recvMsg];<br>        }<br>    }<br><br>    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 回发数据</span><br>    NSData</em> backData =<span style="color: #000000;"> [backStr dataUsingEncoding:NSUTF8StringEncoding];<br>    [sock writeData:backData withTimeout:</span>-<span style="color: #800080;">1</span><span style="color: #000000;"> tag:ECHO_MSG];<br>}<br><br></span>- (<span style="color: #0000ff;">void</span>)onSocket:(AsyncSocket <em>)sock willDisconnectWithError:(NSError </em><span style="color: #000000;">)err<br>{<br>    [self logInfo:FORMAT(</span><span style="color: #800000;">@”</span><span style="color: #800000;">Client Disconnected: %@:%hu</span><span style="color: #800000;">“</span><span style="color: #000000;">, [sock connectedHost], [sock connectedPort])];<br>}<br><br></span>- (<span style="color: #0000ff;">void</span>)onSocketDidDisconnect:(AsyncSocket *<span style="color: #000000;">)sock<br>{<br>    [connectedSockets removeObject:sock];<br>}<br><br></span><span style="color: #0000ff;">@end</span></pre><br></div><br><p><span style="font-size: 12px; line-height: 18px;">界面搭建</span></p><br><p><span style="font-size: 12px; line-height: 18px;"><img src="http://images.cnitblog.com/i/615535/201407/140948458653023.png" alt=""></span></p><div id="MySignature"></div><br><div class="clear"></div><br><div id="blog_post_info_block"><br><div id="BlogPostCategory"></div><br><div id="EntryTag"></div><br><div id="blog_post_info"><br></div><br><div class="clear"></div><br><div id="post_next_prev"></div><br></div>

]]></content>
    <summary type="html">
    <![CDATA[<p><p>一、前言</p></p>
<p><p><span style="font-size: 12px;">公司的项目用到了Socket编程，之前在学习的过程当中，用到的更多的还是http请求的方式。但是既然用到了就必须学习一下，所以就在网上找一些例子，然后想自己写一个demo。可是发现很多写iOS Socket的博客并没有很详细的说明，也可能是大神们觉得其他东西都浅显易懂。</span></p><br>]]>
    
    </summary>
    
      <category term="AsyncSocket" scheme="http://yimouleng.com/tags/AsyncSocket/"/>
    
      <category term="Socket" scheme="http://yimouleng.com/tags/Socket/"/>
    
      <category term="即时通讯" scheme="http://yimouleng.com/tags/%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF/"/>
    
      <category term="iOS开发" scheme="http://yimouleng.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ios Block]]></title>
    <link href="http://yimouleng.com/2014/11/23/ios-block/"/>
    <id>http://yimouleng.com/2014/11/23/ios-block/</id>
    <published>2014-11-23T12:34:38.000Z</published>
    <updated>2015-12-09T09:16:39.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u4F55_u4E3ABlock"><a href="#u4F55_u4E3ABlock" class="headerlink" title="何为Block"></a>何为Block</h2><p>Block 是iOS在4.0之后新增的程式语法，严格来说block的概念并不算是基础程式设计的范围，对初学者来说也不是很容易了解，但是在iOS SDK 4.0之后，block几乎出现在所有新版的API之中，换句话说，如果不了解block这个概念就无法使用SDK 4.0版本以后的新功能，因此虽然block本身的语法有点难度，但为了使用iOS的新功能我们还是得硬着头皮去了解这个新的程式概念。</p>
<a id="more"></a>
<h3 id="u64CD_u86CB_u7684Block_u8BED_u6CD5"><a href="#u64CD_u86CB_u7684Block_u8BED_u6CD5" class="headerlink" title="操蛋的Block语法"></a>操蛋的Block语法</h3><p>Block 首先复制<a href="http://fuckingblocksyntax.com" target="_blank" rel="external">操蛋的Block语法</a>上面的代码<br>1、作为一个本地变量（local variable）</p>
<p><code>returnType (^blockName)(parameterTypes) = ^returnType(parameters) {…};</code></p>
<p>2、作为@property</p>
<p><code>@property (nonatomic, copy) returnType (^blockName)(parameterTypes);</code></p>
<p>3、作为方法的参数（method parameter）</p>
<p><code>- (void)someMethodThatTakesABlock:(returnType (^)(parameterTypes))blockName;</code></p>
<p>4、作为方法参数的时候被调用</p>
<p><code>[someObject someMethodThatTakesABlock: ^returnType (parameters) {...}];</code></p>
<p>5、使用typedef来定义block，可以事半功倍</p>
<p><code>typedef returnType (^TypeName)(parameterTypes);
TypeName blockName = ^returnType(parameters) {…};</code></p>
<p>这篇可能会比较长，先列个提纲</p>
<blockquote>
<ul>
<li>一个最简单的 Block</li>
<li>有参数无返回值的 Block</li>
<li>有参数有返回值的 Block</li>
<li>Block 中的 typedef</li>
<li>Block 到底（比函数）优越在哪里</li>
<li>Block 的进阶使用</li>
</ul>
</blockquote>
<p>Objective-C 的 Block 非常神奇，相当于一个类，里面保存的是一段代码（代码块），别的语言可能还没有这个特性，同时，Apple 官方也推荐开发者使用 Block 来写程序。</p>
<h3 id="u4E00_u4E2A_u6700_u7B80_u5355_u7684_Block"><a href="#u4E00_u4E2A_u6700_u7B80_u5355_u7684_Block" class="headerlink" title="一个最简单的 Block"></a>一个最简单的 Block</h3><p>Block 跟函数挺像的，不过用法比函数要高大上。举个栗子：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数是这样写</span></span><br><span class="line"><span class="keyword">void</span> blockTest() &#123;  </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Hello, World!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样调用</span></span><br><span class="line">blockTest();</span><br><span class="line"></span><br><span class="line"><span class="comment">// block 这样写</span></span><br><span class="line"><span class="keyword">void</span> (^blockTest)() = ^&#123;  </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Hello, World!"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样调用</span></span><br><span class="line">blockTest();</span><br></pre></td></tr></table></figure>
<p>两个调用是完全一样的，不过 Block 的声明有点难理解，来分析下</p>
<p><code>void</code> 说明函数没有返回值，跟函数的写法完全一样的，</p>
<p><code>(^blockTest)</code> 拆成三部分，<code>blockTest</code> 是 Block 的名字，前面加一个<code>^</code>说明这是个 Block 类型，然后再用括号括住，这是固定写法，</p>
<p><code>()</code> 说明无参数，</p>
<p><code>^{}</code> 这个就是 Block 内容的固定写法了，当然前提是<strong>没有参数</strong>，另一种情况稍后补充慢慢来~</p>
<h3 id="u6709_u53C2_u6570_u65E0_u8FD4_u56DE_u503C_u7684_Block"><a href="#u6709_u53C2_u6570_u65E0_u8FD4_u56DE_u503C_u7684_Block" class="headerlink" title="有参数无返回值的 Block"></a>有参数无返回值的 Block</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (^blockTest)(<span class="keyword">int</span>, <span class="built_in">NSString</span> *) = ^(<span class="keyword">int</span> count, <span class="built_in">NSString</span> *word)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;count; i++) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, word);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">blockTest(<span class="number">5</span>, <span class="string">@"Hello, World!"</span>);</span><br></pre></td></tr></table></figure>
<p>大括号内的东西大概都明白，不再细说，上面提到，<code>()</code> 代表无参数，那么这次里面有一个 int, NSString *，说明有两个类型的参数，后面原本是<code>^{}</code>，现在中间多了个 <code>()</code>，道理同上。</p>
<h3 id="u6709_u53C2_u6570_u6709_u8FD4_u56DE_u503C_u7684_Block"><a href="#u6709_u53C2_u6570_u6709_u8FD4_u56DE_u503C_u7684_Block" class="headerlink" title="有参数有返回值的 Block"></a>有参数有返回值的 Block</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (^<span class="keyword">sum</span>)(<span class="keyword">int</span>, <span class="keyword">int</span>) = ^(<span class="keyword">int</span> x, <span class="keyword">int</span> y)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">NSLog(@<span class="string">"%d"</span>, <span class="keyword">sum</span>(<span class="number">13</span>, <span class="number">14</span>));</span><br></pre></td></tr></table></figure>
<p>这个其实我不想多说了，以大家聪明的程度肯定自己能看懂。</p>
<h3 id="Block__u4E2D_u7684_typedef"><a href="#Block__u4E2D_u7684_typedef" class="headerlink" title="Block 中的 typedef"></a>Block 中的 typedef</h3><p>大家都知道 typedef 可以这么用</p>
<p><code>typedef int BlockInt;</code></p>
<p>相同的，可以推理到 Block 中</p>
<p><code>typedef int (^MyBlock)(int);</code></p>
<p><strong>注意写法，跟普通的不太一样</strong></p>
<p>之后想用的时候，可以直接把 MyBlock 当成一个类型，举个栗子<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MyBlock square = ^(<span class="keyword">int</span> x)&#123;  </span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">square(<span class="number">6</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="Block__u5230_u5E95_uFF08_u6BD4_u51FD_u6570_uFF09_u4F18_u8D8A_u5728_u54EA_u91CC"><a href="#Block__u5230_u5E95_uFF08_u6BD4_u51FD_u6570_uFF09_u4F18_u8D8A_u5728_u54EA_u91CC" class="headerlink" title="Block 到底（比函数）优越在哪里"></a>Block 到底（比函数）优越在哪里</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> getSomeInfo(<span class="built_in">NSString</span> *info) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用函数写的话，可以这么玩，传入一个已知类型的变量，由这个函数来决定如何处置变量。</p>
<p>我们写程序讲究低耦合，这个函数关心的东西越少越好，这么做管的太宽了，但是我们有 Block，来看一个神奇的效果：<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void <span class="function">getSomeInfo</span>(<span class="function">void</span>(^blockFunc)()) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">NSLog</span>(<span class="at_rule">@<span class="string">"Before Block"</span>);</span></span><br><span class="line">    <span class="function">blockFunc</span>();</span><br><span class="line">    <span class="function">NSLog</span>(<span class="at_rule">@<span class="string">"After Block"</span>);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>main 函数中<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">getSomeInfo</span>(^&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">NSLog</span>(<span class="at_rule">@<span class="string">"%@"</span>, @<span class="string">"You can do anything here"</span>);</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>结果是<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2015</span>-<span class="number">05</span>-<span class="number">21</span> <span class="number">22</span>:<span class="number">52</span>:<span class="number">23.498</span> Block-Test[<span class="number">5427</span>:<span class="number">277676</span>] Before Block  </span><br><span class="line"><span class="number">2015</span>-<span class="number">05</span>-<span class="number">21</span> <span class="number">22</span>:<span class="number">52</span>:<span class="number">23.499</span> Block-Test[<span class="number">5427</span>:<span class="number">277676</span>] You can <span class="keyword">do</span> anything here  </span><br><span class="line"><span class="number">2015</span>-<span class="number">05</span>-<span class="number">21</span> <span class="number">22</span>:<span class="number">52</span>:<span class="number">23.499</span> Block-Test[<span class="number">5427</span>:<span class="number">277676</span>] After Block</span><br></pre></td></tr></table></figure></p>
<p>当然这么搞不太严谨的，如果传进去一个空，程序会报错（坏访问），解决方法也很简单，判断一下是否为空即可，我就不写了 </p>
<h3 id="Block__u7684_u8FDB_u9636_u4F7F_u7528"><a href="#Block__u7684_u8FDB_u9636_u4F7F_u7528" class="headerlink" title="Block 的进阶使用"></a>Block 的进阶使用</h3><p>  1.修改外部变量的时候，外部变量需要加一个 __block 来修饰</p>
<p>  __block int a = 50;</p>
<p>  2.为什么加上 __block 就能修改了</p>
<p>先贴 main.m 的代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.m</span></span><br><span class="line"><span class="comment">//  Block-Test</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by JieLee on 15/5/21.</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2015年 PUPBOSS. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#import &lt;Foundation/Foundation.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;  </span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line"></span><br><span class="line">        __block <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> (^blockTest)() = ^&#123;</span><br><span class="line"></span><br><span class="line">            a = <span class="number">50</span>;</span><br><span class="line">            NSLog(@<span class="string">"%d"</span>, a);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        blockTest();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在 Terminal 中，输入 <code>clang -rewrite-objc main.m</code>，居然转换了 10 万多行 C++ 代码，拉到最下面分析</p>
<p>有一段是这样的<br><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, <span class="keyword">const</span> char * argv[]) <span class="comment">&#123;  </span><br><span class="line">    /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line">        __attribute__((__blocks__(byref))) __Block_byref_a_0 a = &#123;(void*)0,(__Block_byref_a_0 *)&amp;a, 0, sizeof(__Block_byref_a_0), 10&#125;</span>;</span><br><span class="line"></span><br><span class="line">        void <span class="comment">(*blockTest)() = (void (*)</span>())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_a_0 *)&amp;a, <span class="number">570425344</span>);</span><br><span class="line"></span><br><span class="line">        ((void <span class="comment">(*)(__block_impl *)</span>)((__block_impl *)blockTest)-&gt;FuncPtr)((__block_impl *)blockTest);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>来分析下，一般括号内的东西是强转，那就好办了，重点看这句<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void <span class="list">(<span class="keyword">*blockTest</span>)</span><span class="list">()</span> = <span class="list">(<span class="keyword">void</span> <span class="list">(<span class="keyword">*</span>)</span><span class="list">()</span>)</span>&amp;__main_block_impl_0<span class="list">(<span class="list">(<span class="keyword">void</span> <span class="variable">*)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_a_0 *</span>)</span><span class="keyword">&amp;a</span>, <span class="number">570425344</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>删掉各种括号，就变成了<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void <span class="list">(<span class="keyword">*blockTest</span>)</span><span class="list">()</span> = &amp;__main_block_impl_0<span class="list">(<span class="keyword">__main_block_func_0</span>, <span class="keyword">&amp;__main_block_desc_0_DATA</span>, <span class="keyword">&amp;a</span>, <span class="number">570425344</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p><code>__main_block_impl_0</code> 应该是一个类，或者结构体，我们往上找，还真有一个</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct __main_block_impl_0 &#123;  </span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* <span class="type">Desc</span>;</span><br><span class="line">  __Block_byref_a_0 *a; // by <span class="keyword">ref</span></span><br><span class="line">  __main_block_impl_0(<span class="type">void</span> *fp, struct __main_block_desc_0 *desc, __Block_byref_a_0 *_a, <span class="type">int</span> flags=<span class="number">0</span>) : a(_a-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.<span class="type">Flags</span> = flags;</span><br><span class="line">    impl.<span class="type">FuncPtr</span> = fp;</span><br><span class="line">    <span class="type">Desc</span> = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>C++ 的结构体比较有意思，他可以调用自己的 <code>__main_block_impl_0</code>函数，然后把需要的东西传进去，最后 <code>Desc = desc</code>; 返回一个结构体。</p>
<p>再转回来<code>&amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA,&amp;a,570425344)</code>; 是什么意思呢，返回一个结构体，然后取地址，所以 block 的本质，就是一个结构体！</p>
<p>至于为什么能改变 a 的值，我贴段代码，大家自己理解吧，我是有点蒙。反正就是各种地址各种传进去，然后就把值给改了。<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((__blocks__(byref))) __Block_byref_a_0 a = &#123;(<span class="type">void</span>*)<span class="number">0</span>,(__Block_byref_a_0 *)&amp;a, <span class="number">0</span>, sizeof(__Block_byref_a_0), <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">struct __Block_byref_a_0 &#123;  </span><br><span class="line">  <span class="type">void</span> *__isa;</span><br><span class="line">__Block_byref_a_0 *__forwarding;  </span><br><span class="line"> <span class="type">int</span> __flags;</span><br><span class="line"> <span class="type">int</span> __size;</span><br><span class="line"> <span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct __main_block_impl_0 &#123;  </span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* <span class="type">Desc</span>;</span><br><span class="line">  __Block_byref_a_0 *a; // by <span class="keyword">ref</span></span><br><span class="line">  __main_block_impl_0(<span class="type">void</span> *fp, struct __main_block_desc_0 *desc, __Block_byref_a_0 *_a, <span class="type">int</span> flags=<span class="number">0</span>) : a(_a-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.<span class="type">Flags</span> = flags;</span><br><span class="line">    impl.<span class="type">FuncPtr</span> = fp;</span><br><span class="line">    <span class="type">Desc</span> = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;  </span><br><span class="line">  __Block_byref_a_0 *a = __cself-&gt;a; // bound by <span class="keyword">ref</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            (a-&gt;__forwarding-&gt;a) = <span class="number">50</span>;</span><br><span class="line">            <span class="type">NSLog</span>((<span class="type">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_f__kvyhp79j5wbcb2d7t24v3v_c0000gn_T_main_f979f0_mi_2, (a-&gt;__forwarding-&gt;a));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>文章最后有完整的代码，想研究的可以去<a href="https://gist.githubusercontent.com/pupboss/0cf42d6114816ef2fdb8/raw/390a5e4117fac5da18878e91416a90b4eb796ef6/main.cpp" target="_blank" rel="external">pupboss的github</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u4F55_u4E3ABlock"><a href="#u4F55_u4E3ABlock" class="headerlink" title="何为Block"></a>何为Block</h2><p>Block 是iOS在4.0之后新增的程式语法，严格来说block的概念并不算是基础程式设计的范围，对初学者来说也不是很容易了解，但是在iOS SDK 4.0之后，block几乎出现在所有新版的API之中，换句话说，如果不了解block这个概念就无法使用SDK 4.0版本以后的新功能，因此虽然block本身的语法有点难度，但为了使用iOS的新功能我们还是得硬着头皮去了解这个新的程式概念。</p>]]>
    
    </summary>
    
      <category term="block" scheme="http://yimouleng.com/tags/block/"/>
    
      <category term="语法" scheme="http://yimouleng.com/tags/%E8%AF%AD%E6%B3%95/"/>
    
      <category term="iOS开发" scheme="http://yimouleng.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS绘图]]></title>
    <link href="http://yimouleng.com/2014/11/23/ios-CoreGraphics/"/>
    <id>http://yimouleng.com/2014/11/23/ios-CoreGraphics/</id>
    <published>2014-11-22T19:01:30.000Z</published>
    <updated>2015-12-09T09:15:36.000Z</updated>
    <content type="html"><![CDATA[<h3 id="iOS_u7ED8_u56FE"><a href="#iOS_u7ED8_u56FE" class="headerlink" title="iOS绘图"></a>iOS绘图</h3><p>在iOS中常用有三套绘图API。一个是UIKit提供的高层API，一个是CoreGraphics提供的C语言层的API，最后一个是OpenGL ES提供的API。</p>
<p>iOS的绘图逻辑代码需要放在UIView的drawRect:方法里面实现，所以绘图只能发生在UIView上面。</p>
<p>绘图后如果我们想要显示图像可以调用</p>
<p><code>setNeedsDisplay</code>和<code>setNeedsDisplayInRect:</code>这两个方法是用来标示一个视图是否需要进行重绘，这里标示重绘并不会马上重新绘制，而是等到该RunLoop上面的任务执行完成后才回执行重绘。<br><a id="more"></a><br>触发重绘有以下几种情况：</p>
<p>1.当遮挡你的视图得其它视图被移动或者删除操作得时候；</p>
<p>2.将视图的hidden属性声明设置为No，使其从隐藏状态变为可见；</p>
<p>3.将视图滚出屏幕，然后重新回到屏幕；</p>
<p>4.显示调用视图的<code>setNeedsDisplay</code>或者<code>setNeedsDisplayInRect:</code>方法；</p>
<h3 id="ios_u7ED8_u56FE_u5468_u671F_u5206_u6790"><a href="#ios_u7ED8_u56FE_u5468_u671F_u5206_u6790" class="headerlink" title="ios绘图周期分析"></a>ios绘图周期分析</h3><p>通过下面这个例子来分析</p>
<p>progressView.hidden = NO;</p>
<p>[self doSomethingTimeConsuming];</p>
<p>progressView.hidden = YES;</p>
<p>第一行代码progress.hidden = NO;根本没有效果，这行代码不会使进度视图在执行耗时操作时显示出来。无论这个方法运行多久，都不会看到视图显示出来。</p>
<p><img src="http://images0.cnblogs.com/blog2015/717519/201508/192124265355616.png" alt=""></p>
<p>所有的绘制都发生在主线程，只要代码运行在主线程，就没有东西可以绘制。这就是不要在主线程中执行长时间运行操作的一个原因。这不仅会阻碍绘制更新，还会阻碍事件处理（比如响应触摸事件）。只要代码在主线程上，应用对于用户其实就是“功能挂起的”。如果主线程例程返回足够快，这些变化根本就察觉不到。<br>你可能会想：“那我就在后台线程运行我的绘图指令。”通常是无法做到这一点的，因为对于当前的UIKit上下文来说绘图不是线程安全的。任何在后台线程修改视图的尝试都会导致未定义的行为，包括绘制出错或崩溃。<br>这个行为并不是需要解决的问题。绘图时间实质是ios在有限的硬件上渲染复杂绘图的功能。</p>
<h3 id="UIKit_u7ED8_u56FE"><a href="#UIKit_u7ED8_u56FE" class="headerlink" title="UIKit绘图"></a>UIKit绘图</h3><p>比较简单，这里就说一些常用API。</p>
<p>设置画笔颜色：</p>
<p>画笔颜色分为描边颜色和填充颜色，都是用UIColor的API设置的。在drawRect方法中调用<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">[<span class="comment">[UIColor anyColor]</span> setFill]</span>设置填充颜色。</span><br><span class="line"><span class="comment">[<span class="comment">[UIColor anyColor]</span> setStroke]</span>设置描边颜色。</span><br></pre></td></tr></table></figure></p>
<p>设置绘图区域：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">UIRectFill</span><span class="params">(CGRect rect)</span></span>，填充某一区域 。</span><br><span class="line"><span class="function"><span class="title">UIRectFrame</span><span class="params">(CGRect rect)</span></span>，矩形描边函数。</span><br><span class="line">UIBezierPath，绘图路径类，包括了线段、弧线、矩形、圆形等等。</span><br></pre></td></tr></table></figure></p>
<p>其中UIBezierPath可以定制主来很多很复杂的图形，这里就不具体的说UIBezierPath的api了，使用起来比较简单直接看文档就可以。</p>
<h4 id="u7ED8_u5236_u56FE_u50CF"><a href="#u7ED8_u5236_u56FE_u50CF" class="headerlink" title="绘制图像"></a>绘制图像</h4><p>UIImage提供了自己的绘图方法。显示UIImage，除了添加到UIImageView中，还可以直接画到UIView上面，常用API如下：<br><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="pp">-<span class="params">(void)</span>drawAtPoint:<span class="params">(<span class="variable">CGPoint</span>)</span>point;在某个点绘制</span><br><span class="line">-<span class="params">(void)</span>drawInRect:<span class="params">(<span class="variable">CGRect</span>)</span>rect;绘制到某个矩形中</span><br><span class="line">-<span class="params">(void)</span>drawAsPatternInRect;绘制到某个矩形中并平铺</span></span><br></pre></td></tr></table></figure></p>
<h4 id="u7ED8_u5236_u6587_u5B57"><a href="#u7ED8_u5236_u6587_u5B57" class="headerlink" title="绘制文字"></a>绘制文字</h4><p>NSString的category同样提供了绘制文字的功能<br><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="pp">-<span class="params">(void)</span>drawAtPoint:<span class="params">(<span class="variable">CGPoint</span>)</span>point withAttributes:<span class="params">(<span class="variable">NSDictionary</span> *)</span>attrs，文本在制定点用属性绘制。</span><br><span class="line">-<span class="params">(void)</span>drawInRect:<span class="params">(<span class="variable">CGRect</span>)</span>rect withAttributes:<span class="params">(<span class="variable">NSDictionary</span> *)</span>attrs，文本在指定的矩形里绘制。</span></span><br></pre></td></tr></table></figure></p>
<p>它们都可以用attrs，这和NSAttributedString很像。</p>
<h3 id="CoreGraphics_u7ED8_u56FE"><a href="#CoreGraphics_u7ED8_u56FE" class="headerlink" title="CoreGraphics绘图"></a>CoreGraphics绘图</h3><p>绘图上下文CGContextRef，CoreGraphics很类似java、C#等，需要有一个绘图上下文。</p>
<p>上下文中保存了要绘制内容的信息，要获得上下文需要调用。</p>
<p><code>CGContextRef UIGraphicsGetCurrentContext(void)</code></p>
<p>常用API</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">移动点</span><br><span class="line"><span class="keyword">void</span> <span class="built_in">CGContextMoveToPoint</span>(<span class="built_in">CGContextRef</span> c, <span class="built_in">CGFloat</span> x, <span class="built_in">CGFloat</span> y)</span><br><span class="line">画线</span><br><span class="line"><span class="keyword">void</span> <span class="built_in">CGContextAddLineToPoint</span>(<span class="built_in">CGContextRef</span> c, <span class="built_in">CGFloat</span> x, <span class="built_in">CGFloat</span> y)</span><br><span class="line">闭合路径</span><br><span class="line"><span class="keyword">void</span> <span class="built_in">CGContextClosePath</span>(<span class="built_in">CGContextRef</span> c)</span><br><span class="line">绘制路径</span><br><span class="line"><span class="keyword">void</span> <span class="built_in">CGContextDrawPath</span>(<span class="built_in">CGContextRef</span> c, <span class="built_in">CGPathDrawingMode</span> mode)</span><br><span class="line">设置描边颜色</span><br><span class="line"><span class="keyword">void</span> <span class="built_in">CGContextSetStrokeColorWithColor</span>(<span class="built_in">CGContextRef</span> c, <span class="built_in">CGColorRef</span> color)</span><br><span class="line">设置填充颜色</span><br><span class="line"><span class="keyword">void</span> <span class="built_in">CGContextSetFillColorWithColor</span>(<span class="built_in">CGContextRef</span> c, <span class="built_in">CGColorRef</span> color)</span><br><span class="line">绘制贝塞尔曲线，这里的参数分别是两个控制点和交点的左边，大家可以自行百度贝塞尔曲线定义</span><br><span class="line"><span class="keyword">void</span> <span class="built_in">CGContextAddCurveToPoint</span>(<span class="built_in">CGContextRef</span> c, <span class="built_in">CGFloat</span> cp1x,<span class="built_in">CGFloat</span> cp1y, <span class="built_in">CGFloat</span> cp2x, <span class="built_in">CGFloat</span> cp2y, <span class="built_in">CGFloat</span> x, <span class="built_in">CGFloat</span> y)</span><br><span class="line">保存上下文</span><br><span class="line"><span class="keyword">void</span> <span class="built_in">CGContextSaveGState</span>(<span class="built_in">CGContextRef</span> c)</span><br><span class="line">读取上下文</span><br><span class="line"><span class="keyword">void</span> <span class="built_in">CGContextRestoreGState</span>(<span class="built_in">CGContextRef</span> c)</span><br></pre></td></tr></table></figure>
<p>常用API有很多这里只列举上面这些，剩下的可以查下API</p>
<h4 id="CoreGraphics_u5750_u6807_u7CFB"><a href="#CoreGraphics_u5750_u6807_u7CFB" class="headerlink" title="CoreGraphics坐标系"></a>CoreGraphics坐标系</h4><p>CoreGraphics坐标系和我们平时用UIKit的坐标系是不样的，CoreGraphics的左下角为(0,0)点，而UIKit的左上角为(0,0)点。</p>
<p>所以我们在开发的时候，一般会先同步坐标系（CoreText也需要这么操作），应该这样写</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CGContextTranslateCTM<span class="list">(<span class="keyword">context</span>, <span class="number">0</span>, img.size.height)</span><span class="comment">;平移变化</span></span><br><span class="line">CGContextScaleCTM<span class="list">(<span class="keyword">context</span>,<span class="number">1</span>,<span class="number">-1</span>)</span><span class="comment">;缩放变换</span></span><br></pre></td></tr></table></figure>
<p>先利用平移变换上移一个视图大小，然后在用缩放变化把高度设-1进行以x为轴的对称变换。</p>
<h4 id="u53D8_u6362"><a href="#u53D8_u6362" class="headerlink" title="变换"></a>变换</h4><p>接下来说说变换，绘图是有很多矩阵变换的，其中常用的有以下：</p>
<p>1.平移变换</p>
<p>2.缩放变换</p>
<p>3.旋转变换</p>
<p>4.x轴对称变换</p>
<p>5.y轴对称变换</p>
<p>6.坐标原点对称变换</p>
<h4 id="u77E9_u9635_u53D8_u6362CTM"><a href="#u77E9_u9635_u53D8_u6362CTM" class="headerlink" title="矩阵变换CTM"></a>矩阵变换CTM</h4><p>CoreGraphics中提供了很多矩阵变换的API，主要有</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGContextRoatateCMT</span>，旋转CTM，旋转变换；</span><br><span class="line"><span class="built_in">CGContextScaleCTM</span>，缩放变换；</span><br><span class="line"><span class="built_in">CGContextTranslateCTM</span>，平移变换。</span><br></pre></td></tr></table></figure>
<h4 id="u4EFF_u5C04_u53D8_u6362affine"><a href="#u4EFF_u5C04_u53D8_u6362affine" class="headerlink" title="仿射变换affine"></a>仿射变换affine</h4><p>仿射变换是可以重用的变换，通过多次的矩阵乘法得到变换矩阵。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGAffineMakeRotation</span>，创建新的旋转矩阵；</span><br><span class="line"><span class="built_in">CGAffineMakeScale</span>，创建新的缩放矩阵；</span><br><span class="line"><span class="built_in">CGAffineMakeTranslation</span>，创建新的平移矩阵；</span><br><span class="line"><span class="built_in">CGAffineTransform</span>，仿射矩阵，可以经过多次变换；</span><br><span class="line"><span class="built_in">CGAffineTransformRotate</span>，旋转矩阵；</span><br><span class="line"><span class="built_in">CGAffineTransformScale</span>，缩放矩阵；</span><br><span class="line"><span class="built_in">CGAffineTransformTranslate</span>，平移矩阵；</span><br><span class="line"><span class="built_in">CGContextConcatCTM</span>，连接到CTM变换。</span><br></pre></td></tr></table></figure></p>
<p>我们可以创建一个CGAffineTransform，然后经过多次的仿射变换后连接到CTM进行显示。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="iOS_u7ED8_u56FE"><a href="#iOS_u7ED8_u56FE" class="headerlink" title="iOS绘图"></a>iOS绘图</h3><p>在iOS中常用有三套绘图API。一个是UIKit提供的高层API，一个是CoreGraphics提供的C语言层的API，最后一个是OpenGL ES提供的API。</p>
<p>iOS的绘图逻辑代码需要放在UIView的drawRect:方法里面实现，所以绘图只能发生在UIView上面。</p>
<p>绘图后如果我们想要显示图像可以调用</p>
<p><code>setNeedsDisplay</code>和<code>setNeedsDisplayInRect:</code>这两个方法是用来标示一个视图是否需要进行重绘，这里标示重绘并不会马上重新绘制，而是等到该RunLoop上面的任务执行完成后才回执行重绘。<br>]]>
    
    </summary>
    
      <category term="CoreGraphics" scheme="http://yimouleng.com/tags/CoreGraphics/"/>
    
      <category term="iOS开发" scheme="http://yimouleng.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS开发 - 动画-CALayer-Core Animation-UIView封装]]></title>
    <link href="http://yimouleng.com/2014/11/23/CALayer-Animation/"/>
    <id>http://yimouleng.com/2014/11/23/CALayer-Animation/</id>
    <published>2014-11-22T19:01:30.000Z</published>
    <updated>2015-12-09T10:07:36.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u6982_u89C8"><a href="#u6982_u89C8" class="headerlink" title="概览"></a>概览</h2><p>在iOS中随处都可以看到绚丽的动画效果，实现这些动画的过程并不复杂，今天将带大家一窥iOS动画全貌。在这里你可以看到iOS中如何使用图层精简非交互式绘图，如何通过核心动画创建基础动画、关键帧动画、动画组、转场动画，如何通过UIView的装饰方法对这些动画操作进行简化等。在今天的文章里您可以看到动画操作在iOS中是如何简单和高效，很多原来想做但是苦于没有思路的动画在iOS中将变得越发简单：</p>
<a id="more"></a>
<blockquote>
<p>1.CALayer<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.1</span> CALayer简介</span><br><span class="line"><span class="number">1.2</span> CALayer常用属性</span><br><span class="line"><span class="number">1.3</span> CALayer绘图</span><br></pre></td></tr></table></figure></p>
<p>2.Core Animation<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2.1</span> 基础动画</span><br><span class="line"><span class="number">2.2</span> 关键帧动画</span><br><span class="line"><span class="number">2.3</span> 动画组</span><br><span class="line"><span class="number">2.4</span> 转场动画</span><br><span class="line"><span class="number">2.5</span> 逐帧动画</span><br></pre></td></tr></table></figure></p>
<p>3.UIView动画封装<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.1</span> 基础动画</span><br><span class="line"><span class="number">3.2</span> 关键帧动画</span><br><span class="line"><span class="number">3.3</span> 转场动画</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="CALayer"><a href="#CALayer" class="headerlink" title="CALayer"></a>CALayer</h3><h4 id="CALayer_u7B80_u4ECB"><a href="#CALayer_u7B80_u4ECB" class="headerlink" title="CALayer简介"></a>CALayer简介</h4><p>在介绍动画操作之前我们必须先来了解一个动画中常用的对象CALayer。CALayer包含在QuartzCore框架中，这是一个跨平台的框架，既可以用在iOS中又可以用在Mac OS X中。在使用Core Animation开发动画的本质就是将CALayer中的内容转化为位图从而供硬件操作，所以要熟练掌握动画操作必须先来熟悉CALayer。</p>
<p>在上一篇文章中使用Quartz 2D绘图时大家其实已经用到了CALayer，当利用drawRect:方法绘图的本质就是绘制到了UIView的layer（属性）中，可是这个过程大家在上一节中根本体会不到。但是在Core Animation中我们操作更多的则不再是UIView而是直接面对CALayer。下图描绘了CALayer和UIView的关系，在UIView中有一个layer属性作为根图层，根图层上可以放其他子图层，在UIView中所有能够看到的内容都包含在layer中：</p>
<p><img src="http://images.cnitblog.com/blog/62046/201409/150628367066332.png" alt=""></p>
<hr>
<h4 id="CALayer_u5E38_u7528_u5C5E_u6027"><a href="#CALayer_u5E38_u7528_u5C5E_u6027" class="headerlink" title="CALayer常用属性"></a>CALayer常用属性</h4><p>在iOS中CALayer的设计主要是了为了内容展示和动画操作，CALayer本身并不包含在UIKit中，它不能响应事件。由于CALayer在设计之初就考虑它的动画操作功能，CALayer很多属性在修改时都能形成动画效果，这种属性称为“隐式动画属性”。但是对于UIView的根图层而言属性的修改并不形成动画效果，因为很多情况下根图层更多的充当容器的做用，如果它的属性变动形成动画效果会直接影响子图层。另外，UIView的根图层创建工作完全由iOS负责完成，无法重新创建，但是可以往根图层中添加子图层或移除子图层。</p>
<p>下表列出了CALayer常用的属性：</p>
<p><img src="/image/animation1.png" alt=""></p>
<ul>
<li><p>隐式属性动画的本质是这些属性的变动默认隐含了CABasicAnimation动画实现，详情大家可以参照Xcode帮助文档中“Animatable Properties”一节。</p>
</li>
<li><p>在CALayer中很少使用frame属性，因为frame本身不支持动画效果，通常使用bounds和position代替。</p>
</li>
<li><p>CALayer中透明度使用opacity表示而不是alpha；中心点使用position表示而不是center。</p>
</li>
<li><p>anchorPoint属性是图层的锚点，范围在（0~1,0~1）表示在x、y轴的比例，这个点永远可以同position（中心点）重合，当图层中心点固定后，调整anchorPoint即可达到调整图层显示位置的作用（因为它永远和position重合）</p>
</li>
</ul>
<p>为了进一步说明anchorPoint的作用，假设有一个层大小100*100，现在中心点位置（50,50），由此可以得出frame（0,0,100,100）。上面说过anchorPoint默认为（0.5,0.5），同中心点position重合，此时使用图形描述如图1；当修改anchorPoint为（0,0），此时锚点处于图层左上角，但是中心点poition并不会改变，因此图层会向右下角移动，如图2；然后修改anchorPoint为（1,1,），position还是保持位置不变，锚点处于图层右下角，此时图层如图3。<br><img src="http://images.cnitblog.com/blog/62046/201409/150628373935488.png" alt=""></p>
<hr>
<p>下面通过一个简单的例子演示一下上面几个属性，程序初始化阶段我们定义一个正方形，但是圆角路径调整为正方形边长的一般，使其看起来是一个圆形，在点击屏幕的时候修改图层的属性形成动画效果（注意在程序中没有直接修改UIView的layer属性，因为根图层无法形成动画效果）：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">"KCMainViewController.h"</span></span></span><br><span class="line"><span class="preprocessor">#define WIDTH 50</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">KCMainViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">KCMainViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">// Do any additional setup after loading the view.</span></span><br><span class="line">    [<span class="keyword">self</span> drawMyLayer];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark 绘制图层</span></span><br><span class="line">-(<span class="keyword">void</span>)drawMyLayer&#123;</span><br><span class="line">    <span class="built_in">CGSize</span> size=[<span class="built_in">UIScreen</span> mainScreen]<span class="variable">.bounds</span><span class="variable">.size</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获得根图层</span></span><br><span class="line">    <span class="built_in">CALayer</span> *layer=[[<span class="built_in">CALayer</span> alloc]init];</span><br><span class="line">    <span class="comment">//设置背景颜色,由于QuartzCore是跨平台框架，无法直接使用UIColor</span></span><br><span class="line">    layer<span class="variable">.backgroundColor</span>=[<span class="built_in">UIColor</span> colorWithRed:<span class="number">0</span> green:<span class="number">146</span>/<span class="number">255.0</span> blue:<span class="number">1.0</span> alpha:<span class="number">1.0</span>]<span class="variable">.CGColor</span>;</span><br><span class="line">    <span class="comment">//设置中心点</span></span><br><span class="line">    layer<span class="variable">.position</span>=<span class="built_in">CGPointMake</span>(size<span class="variable">.width</span>/<span class="number">2</span>, size<span class="variable">.height</span>/<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//设置大小</span></span><br><span class="line">    layer<span class="variable">.bounds</span>=<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, WIDTH,WIDTH);</span><br><span class="line">    <span class="comment">//设置圆角,当圆角半径等于矩形的一半时看起来就是一个圆形</span></span><br><span class="line">    layer<span class="variable">.cornerRadius</span>=WIDTH/<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//设置阴影</span></span><br><span class="line">    layer<span class="variable">.shadowColor</span>=[<span class="built_in">UIColor</span> grayColor]<span class="variable">.CGColor</span>;</span><br><span class="line">    layer<span class="variable">.shadowOffset</span>=<span class="built_in">CGSizeMake</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">    layer<span class="variable">.shadowOpacity</span>=<span class="number">.9</span>;</span><br><span class="line">    <span class="comment">//设置边框</span></span><br><span class="line"><span class="comment">//    layer.borderColor=[UIColor whiteColor].CGColor;</span></span><br><span class="line"><span class="comment">//    layer.borderWidth=1;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置锚点</span></span><br><span class="line"><span class="comment">//    layer.anchorPoint=CGPointZero;</span></span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.view</span><span class="variable">.layer</span> addSublayer:layer];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark 点击放大</span></span><br><span class="line">-(<span class="keyword">void</span>)touchesEnded:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</span><br><span class="line">    <span class="built_in">UITouch</span> *touch=[touches anyObject];</span><br><span class="line">    <span class="built_in">CALayer</span> *layer=<span class="keyword">self</span><span class="variable">.view</span><span class="variable">.layer</span><span class="variable">.sublayers</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">CGFloat</span> width=layer<span class="variable">.bounds</span><span class="variable">.size</span><span class="variable">.width</span>;</span><br><span class="line">    <span class="keyword">if</span> (width==WIDTH) &#123;</span><br><span class="line">        width=WIDTH*<span class="number">4</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        width=WIDTH;</span><br><span class="line">    &#125;</span><br><span class="line">    layer<span class="variable">.bounds</span>=<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, width, width);</span><br><span class="line">    layer<span class="variable">.position</span>=[touch locationInView:<span class="keyword">self</span><span class="variable">.view</span>];</span><br><span class="line">    layer<span class="variable">.cornerRadius</span>=width/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>运行效果：<br><img src="http://images.cnitblog.com/blog/62046/201409/150628379878373.gif" alt=""></p>
<hr>
<h4 id="CALayer_u7ED8_u56FE"><a href="#CALayer_u7ED8_u56FE" class="headerlink" title="CALayer绘图"></a>CALayer绘图</h4><p>上一篇文章中重点讨论了使用Quartz 2D绘图，当时调用了UIView的drawRect:方法绘制图形、图像，这种方式本质还是在图层中绘制，但是这里会着重介绍一下如何直接在图层中绘图。在图层中绘图的方式跟原来基本没有区别，只是drawRect:方法是由UIKit组件进行调用，因此里面可以使用一些UIKit封装的方法进行绘图，而直接绘制到图层的方法由于并非UIKit直接调用因此只能用原生的Core Graphics方法绘制。</p>
<p>图层绘图有两种方法，不管使用哪种方法绘制完必须调用图层的setNeedDisplay方法（注意是图层的方法，不是UIView的方法，前面我们介绍过UIView也有此方法）</p>
<p>1.通过图层代理<strong>drawLayer: inContext:</strong>方法绘制<br>2.通过自定义图层<strong>drawInContext:</strong>方法绘制</p>
<h5 id="u4F7F_u7528_u4EE3_u7406_u65B9_u6CD5_u7ED8_u56FE"><a href="#u4F7F_u7528_u4EE3_u7406_u65B9_u6CD5_u7ED8_u56FE" class="headerlink" title="使用代理方法绘图"></a>使用代理方法绘图</h5><p>通过代理方法进行图层绘图只要指定图层的代理，然后在代理对象中重写<strong>-(void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx</strong>方法即可。需要注意这个方法虽然是代理方法但是不用手动实现CALayerDelegate，因为CALayer定义中给NSObject做了分类扩展，所有的NSObject都包含这个方法。另外设置完代理后必须要调用图层的setNeedDisplay方法，否则绘制的内容无法显示。</p>
<p>下面的代码演示了在一个自定义图层绘制一张图像并将图像设置成圆形，这种效果在很多应用中很常见，如最新版的手机QQ头像就是这种效果：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">"KCMainViewController.h"</span></span></span><br><span class="line"><span class="preprocessor">#define PHOTO_HEIGHT 150</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">KCMainViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">KCMainViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//自定义图层</span></span><br><span class="line">    <span class="built_in">CALayer</span> *layer=[[<span class="built_in">CALayer</span> alloc]init];</span><br><span class="line">    layer<span class="variable">.bounds</span>=<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, PHOTO_HEIGHT, PHOTO_HEIGHT);</span><br><span class="line">    layer<span class="variable">.position</span>=<span class="built_in">CGPointMake</span>(<span class="number">160</span>, <span class="number">200</span>);</span><br><span class="line">    layer<span class="variable">.backgroundColor</span>=[<span class="built_in">UIColor</span> redColor]<span class="variable">.CGColor</span>;</span><br><span class="line">    layer<span class="variable">.cornerRadius</span>=PHOTO_HEIGHT/<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//注意仅仅设置圆角，对于图形而言可以正常显示，但是对于图层中绘制的图片无法正确显示</span></span><br><span class="line">    <span class="comment">//如果想要正确显示则必须设置masksToBounds=YES，剪切子图层</span></span><br><span class="line">    layer<span class="variable">.masksToBounds</span>=<span class="literal">YES</span>;</span><br><span class="line">    <span class="comment">//阴影效果无法和masksToBounds同时使用，因为masksToBounds的目的就是剪切外边框，</span></span><br><span class="line">    <span class="comment">//而阴影效果刚好在外边框</span></span><br><span class="line"><span class="comment">//    layer.shadowColor=[UIColor grayColor].CGColor;</span></span><br><span class="line"><span class="comment">//    layer.shadowOffset=CGSizeMake(2, 2);</span></span><br><span class="line"><span class="comment">//    layer.shadowOpacity=1;</span></span><br><span class="line">    <span class="comment">//设置边框</span></span><br><span class="line">    layer<span class="variable">.borderColor</span>=[<span class="built_in">UIColor</span> whiteColor]<span class="variable">.CGColor</span>;</span><br><span class="line">    layer<span class="variable">.borderWidth</span>=<span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置图层代理</span></span><br><span class="line">    layer<span class="variable">.delegate</span>=<span class="keyword">self</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//添加图层到根图层</span></span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.view</span><span class="variable">.layer</span> addSublayer:layer];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用图层setNeedDisplay,否则代理方法不会被调用</span></span><br><span class="line">    [layer setNeedsDisplay];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark 绘制图形、图像到图层，注意参数中的ctx是图层的图形上下文，其中绘图位置也是相对图层而言的</span></span><br><span class="line">-(<span class="keyword">void</span>)drawLayer:(<span class="built_in">CALayer</span> *)layer inContext:(<span class="built_in">CGContextRef</span>)ctx&#123;</span><br><span class="line"><span class="comment">//    NSLog(@"%@",layer);//这个图层正是上面定义的图层</span></span><br><span class="line">    <span class="built_in">CGContextSaveGState</span>(ctx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//图形上下文形变，解决图片倒立的问题</span></span><br><span class="line">    <span class="built_in">CGContextScaleCTM</span>(ctx, <span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">CGContextTranslateCTM</span>(ctx, <span class="number">0</span>, -PHOTO_HEIGHT);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIImage</span> *image=[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"photo.png"</span>];</span><br><span class="line">    <span class="comment">//注意这个位置是相对于图层而言的不是屏幕</span></span><br><span class="line">    <span class="built_in">CGContextDrawImage</span>(ctx, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, PHOTO_HEIGHT, PHOTO_HEIGHT), image<span class="variable">.CGImage</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//    CGContextFillRect(ctx, CGRectMake(0, 0, 100, 100));</span></span><br><span class="line"><span class="comment">//    CGContextDrawPath(ctx, kCGPathFillStroke);</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGContextRestoreGState</span>(ctx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>运行效果：</p>
<p><img src="http://images.cnitblog.com/blog/62046/201409/150628385812260.jpg" alt=""></p>
<hr>
<p>使用代理方法绘制图形、图像时在<strong>drawLayer:inContext:</strong>方法中可以通过事件参数获得绘制的图层和图形上下文。在这个方法中绘图时所有的位置都是相对于图层而言的，图形上下文指的也是当前图层的图形上下文。</p>
<p>需要注意的是上面代码中绘制图片圆形裁切效果时如果不设置masksToBounds是无法显示圆形，但是对于其他图形却没有这个限制。原因就是当绘制一张图片到图层上的时候会重新创建一个图层添加到当前图层，这样一来如果设置了圆角之后虽然底图层有圆角效果，但是子图层还是矩形，只有设置了masksToBounds为YES让子图层按底图层剪切才能显示圆角效果。同样的，有些朋友经常在网上提问说为什么使用UIImageView的layer设置圆角后图片无法显示圆角，只有设置masksToBounds才能出现效果，也是类似的问题。</p>
<p><strong>扩展1–带阴影效果的圆形图片裁切</strong></p>
<p>如果设置了masksToBounds=YES之后确实可以显示图片圆角效果，但遗憾的是设置了这个属性之后就无法设置阴影效果。因为masksToBounds=YES就意味着外边框不能显示，而阴影恰恰作为外边框绘制的，这样两个设置就产生了矛盾。要解决这个问题不妨换个思路:使用两个大小一样的图层，下面的图层负责绘制阴影，上面的图层用来显示图片。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">"KCMainViewController.h"</span></span></span><br><span class="line"><span class="preprocessor">#define PHOTO_HEIGHT 150</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">KCMainViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">KCMainViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGPoint</span> position= <span class="built_in">CGPointMake</span>(<span class="number">160</span>, <span class="number">200</span>);</span><br><span class="line">    <span class="built_in">CGRect</span> bounds=<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, PHOTO_HEIGHT, PHOTO_HEIGHT);</span><br><span class="line">    <span class="built_in">CGFloat</span> cornerRadius=PHOTO_HEIGHT/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> borderWidth=<span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//阴影图层</span></span><br><span class="line">    <span class="built_in">CALayer</span> *layerShadow=[[<span class="built_in">CALayer</span> alloc]init];</span><br><span class="line">    layerShadow<span class="variable">.bounds</span>=bounds;</span><br><span class="line">    layerShadow<span class="variable">.position</span>=position;</span><br><span class="line">    layerShadow<span class="variable">.cornerRadius</span>=cornerRadius;</span><br><span class="line">    layerShadow<span class="variable">.shadowColor</span>=[<span class="built_in">UIColor</span> grayColor]<span class="variable">.CGColor</span>;</span><br><span class="line">    layerShadow<span class="variable">.shadowOffset</span>=<span class="built_in">CGSizeMake</span>(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">    layerShadow<span class="variable">.shadowOpacity</span>=<span class="number">1</span>;</span><br><span class="line">    layerShadow<span class="variable">.borderColor</span>=[<span class="built_in">UIColor</span> whiteColor]<span class="variable">.CGColor</span>;</span><br><span class="line">    layerShadow<span class="variable">.borderWidth</span>=borderWidth;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.view</span><span class="variable">.layer</span> addSublayer:layerShadow];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//容器图层</span></span><br><span class="line">    <span class="built_in">CALayer</span> *layer=[[<span class="built_in">CALayer</span> alloc]init];</span><br><span class="line">    layer<span class="variable">.bounds</span>=bounds;</span><br><span class="line">    layer<span class="variable">.position</span>=position;</span><br><span class="line">    layer<span class="variable">.backgroundColor</span>=[<span class="built_in">UIColor</span> redColor]<span class="variable">.CGColor</span>;</span><br><span class="line">    layer<span class="variable">.cornerRadius</span>=cornerRadius;</span><br><span class="line">    layer<span class="variable">.masksToBounds</span>=<span class="literal">YES</span>;</span><br><span class="line">    layer<span class="variable">.borderColor</span>=[<span class="built_in">UIColor</span> whiteColor]<span class="variable">.CGColor</span>;</span><br><span class="line">    layer<span class="variable">.borderWidth</span>=borderWidth;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置图层代理</span></span><br><span class="line">    layer<span class="variable">.delegate</span>=<span class="keyword">self</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//添加图层到根图层</span></span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.view</span><span class="variable">.layer</span> addSublayer:layer];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用图层setNeedDisplay,否则代理方法不会被调用</span></span><br><span class="line">    [layer setNeedsDisplay];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark 绘制图形、图像到图层，注意参数中的ctx是图层的图形上下文，其中绘图位置也是相对图层而言的</span></span><br><span class="line">-(<span class="keyword">void</span>)drawLayer:(<span class="built_in">CALayer</span> *)layer inContext:(<span class="built_in">CGContextRef</span>)ctx&#123;</span><br><span class="line">    <span class="comment">//    NSLog(@"%@",layer);//这个图层正是上面定义的图层</span></span><br><span class="line">    <span class="built_in">CGContextSaveGState</span>(ctx);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//图形上下文形变，解决图片倒立的问题</span></span><br><span class="line">    <span class="built_in">CGContextScaleCTM</span>(ctx, <span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">CGContextTranslateCTM</span>(ctx, <span class="number">0</span>, -PHOTO_HEIGHT);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIImage</span> *image=[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"photo.jpg"</span>];</span><br><span class="line">    <span class="comment">//注意这个位置是相对于图层而言的不是屏幕</span></span><br><span class="line">    <span class="built_in">CGContextDrawImage</span>(ctx, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, PHOTO_HEIGHT, PHOTO_HEIGHT), image<span class="variable">.CGImage</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//    CGContextFillRect(ctx, CGRectMake(0, 0, 100, 100));</span></span><br><span class="line">    <span class="comment">//    CGContextDrawPath(ctx, kCGPathFillStroke);</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGContextRestoreGState</span>(ctx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>运行效果：</p>
<p><img src="http://images.cnitblog.com/blog/62046/201409/150628391437687.jpg" alt=""></p>
<hr>
<p><strong>扩展2–图层的形变</strong></p>
<p>从上面代码中大家不难发现使用Core Graphics绘制图片时会倒立显示，对图层的图形上下文进行了反转。在前一篇文章中也采用了类似的方法去解决这个问题，但是在那篇文章中也提到过如果直接让图像沿着x轴旋转180度同样可以达到正确显示的目的，只是当时的旋转靠图形上下文还无法绕x轴旋转。今天学习了图层之后，其实可以控制图层直接旋转而不用借助于图形上下文的形变操作，而且这么操作起来会更加简单和直观。对于上面的程序，只需要设置图层的transform属性即可。需要注意的是transform是CATransform3D类型，形变可以在三个维度上进行，使用方法和前面介绍的二维形变是类似的，而且都有对应的形变设置方法（如：CATransform3DMakeTranslation()、CATransform3DMakeScale()、CATransform3DMakeRotation()）。下面的代码通过CATransform3DMakeRotation()方法在x轴旋转180度解决倒立问题：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">"KCMainViewController.h"</span></span></span><br><span class="line"><span class="preprocessor">#define PHOTO_HEIGHT 150</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">KCMainViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">KCMainViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CGPoint</span> position= <span class="built_in">CGPointMake</span>(<span class="number">160</span>, <span class="number">200</span>);</span><br><span class="line">    <span class="built_in">CGRect</span> bounds=<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, PHOTO_HEIGHT, PHOTO_HEIGHT);</span><br><span class="line">    <span class="built_in">CGFloat</span> cornerRadius=PHOTO_HEIGHT/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> borderWidth=<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//阴影图层</span></span><br><span class="line">    <span class="built_in">CALayer</span> *layerShadow=[[<span class="built_in">CALayer</span> alloc]init];</span><br><span class="line">    layerShadow<span class="variable">.bounds</span>=bounds;</span><br><span class="line">    layerShadow<span class="variable">.position</span>=position;</span><br><span class="line">    layerShadow<span class="variable">.cornerRadius</span>=cornerRadius;</span><br><span class="line">    layerShadow<span class="variable">.shadowColor</span>=[<span class="built_in">UIColor</span> grayColor]<span class="variable">.CGColor</span>;</span><br><span class="line">    layerShadow<span class="variable">.shadowOffset</span>=<span class="built_in">CGSizeMake</span>(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">    layerShadow<span class="variable">.shadowOpacity</span>=<span class="number">1</span>;</span><br><span class="line">    layerShadow<span class="variable">.borderColor</span>=[<span class="built_in">UIColor</span> whiteColor]<span class="variable">.CGColor</span>;</span><br><span class="line">    layerShadow<span class="variable">.borderWidth</span>=borderWidth;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.view</span><span class="variable">.layer</span> addSublayer:layerShadow];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//容器图层</span></span><br><span class="line">    <span class="built_in">CALayer</span> *layer=[[<span class="built_in">CALayer</span> alloc]init];</span><br><span class="line">    layer<span class="variable">.bounds</span>=bounds;</span><br><span class="line">    layer<span class="variable">.position</span>=position;</span><br><span class="line">    layer<span class="variable">.backgroundColor</span>=[<span class="built_in">UIColor</span> redColor]<span class="variable">.CGColor</span>;</span><br><span class="line">    layer<span class="variable">.cornerRadius</span>=cornerRadius;</span><br><span class="line">    layer<span class="variable">.masksToBounds</span>=<span class="literal">YES</span>;</span><br><span class="line">    layer<span class="variable">.borderColor</span>=[<span class="built_in">UIColor</span> whiteColor]<span class="variable">.CGColor</span>;</span><br><span class="line">    layer<span class="variable">.borderWidth</span>=borderWidth;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//利用图层形变解决图像倒立问题</span></span><br><span class="line">    layer<span class="variable">.transform</span>=<span class="built_in">CATransform3DMakeRotation</span>(M_PI, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置图层代理</span></span><br><span class="line">    layer<span class="variable">.delegate</span>=<span class="keyword">self</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加图层到根图层</span></span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.view</span><span class="variable">.layer</span> addSublayer:layer];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用图层setNeedDisplay,否则代理方法不会被调用</span></span><br><span class="line">    [layer setNeedsDisplay];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark 绘制图形、图像到图层，注意参数中的ctx时图层的图形上下文，其中绘图位置也是相对图层而言的</span></span><br><span class="line">-(<span class="keyword">void</span>)drawLayer:(<span class="built_in">CALayer</span> *)layer inContext:(<span class="built_in">CGContextRef</span>)ctx&#123;</span><br><span class="line">    <span class="comment">//    NSLog(@"%@",layer);//这个图层正是上面定义的图层</span></span><br><span class="line">    <span class="built_in">UIImage</span> *image=[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"photo.jpg"</span>];</span><br><span class="line">    <span class="comment">//注意这个位置是相对于图层而言的不是屏幕</span></span><br><span class="line">    <span class="built_in">CGContextDrawImage</span>(ctx, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, PHOTO_HEIGHT, PHOTO_HEIGHT), image<span class="variable">.CGImage</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>事实上如果仅仅就显示一张图片在图层中当然没有必要那么麻烦，直接设置图层contents就可以了，不牵涉到绘图也就没有倒立的问题了。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="preprocessor">#import <span class="title">"KCMainViewController.h"</span></span></span><br><span class="line"><span class="preprocessor">#define PHOTO_HEIGHT 150</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">KCMainViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">KCMainViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CGPoint</span> position= <span class="built_in">CGPointMake</span>(<span class="number">160</span>, <span class="number">200</span>);</span><br><span class="line">    <span class="built_in">CGRect</span> bounds=<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, PHOTO_HEIGHT, PHOTO_HEIGHT);</span><br><span class="line">    <span class="built_in">CGFloat</span> cornerRadius=PHOTO_HEIGHT/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> borderWidth=<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//阴影图层</span></span><br><span class="line">    <span class="built_in">CALayer</span> *layerShadow=[[<span class="built_in">CALayer</span> alloc]init];</span><br><span class="line">    layerShadow<span class="variable">.bounds</span>=bounds;</span><br><span class="line">    layerShadow<span class="variable">.position</span>=position;</span><br><span class="line">    layerShadow<span class="variable">.cornerRadius</span>=cornerRadius;</span><br><span class="line">    layerShadow<span class="variable">.shadowColor</span>=[<span class="built_in">UIColor</span> grayColor]<span class="variable">.CGColor</span>;</span><br><span class="line">    layerShadow<span class="variable">.shadowOffset</span>=<span class="built_in">CGSizeMake</span>(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">    layerShadow<span class="variable">.shadowOpacity</span>=<span class="number">1</span>;</span><br><span class="line">    layerShadow<span class="variable">.borderColor</span>=[<span class="built_in">UIColor</span> whiteColor]<span class="variable">.CGColor</span>;</span><br><span class="line">    layerShadow<span class="variable">.borderWidth</span>=borderWidth;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.view</span><span class="variable">.layer</span> addSublayer:layerShadow];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//容器图层</span></span><br><span class="line">    <span class="built_in">CALayer</span> *layer=[[<span class="built_in">CALayer</span> alloc]init];</span><br><span class="line">    layer<span class="variable">.bounds</span>=bounds;</span><br><span class="line">    layer<span class="variable">.position</span>=position;</span><br><span class="line">    layer<span class="variable">.backgroundColor</span>=[<span class="built_in">UIColor</span> redColor]<span class="variable">.CGColor</span>;</span><br><span class="line">    layer<span class="variable">.cornerRadius</span>=cornerRadius;</span><br><span class="line">    layer<span class="variable">.masksToBounds</span>=<span class="literal">YES</span>;</span><br><span class="line">    layer<span class="variable">.borderColor</span>=[<span class="built_in">UIColor</span> whiteColor]<span class="variable">.CGColor</span>;</span><br><span class="line">    layer<span class="variable">.borderWidth</span>=borderWidth;</span><br><span class="line">    <span class="comment">//设置内容（注意这里一定要转换为CGImage）</span></span><br><span class="line">    <span class="built_in">UIImage</span> *image=[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"photo.jpg"</span>];</span><br><span class="line"><span class="comment">//    layer.contents=(id)image.CGImage;</span></span><br><span class="line">    [layer setContents:(<span class="keyword">id</span>)image<span class="variable">.CGImage</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加图层到根图层</span></span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.view</span><span class="variable">.layer</span> addSublayer:layer];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>既然如此为什么还大费周章的说形变呢，因为形变对于动画有特殊的意义。在动画开发中形变往往不是直接设置transform，而是通过keyPath进行设置。这种方法设置形变的本质和前面没有区别，只是利用了KVC可以动态修改其属性值而已，但是这种方式在动画中确实很常用的，因为它可以很方便的将几种形变组合到一起使用。同样是解决动画旋转问题，只要将前面的旋转代码改为下面的代码即可：</p>
<p><code>[layer setValue:@M_PI forKeyPath:@&quot;transform.rotation.x&quot;];</code></p>
<p>当然，通过key path设置形变参数就需要了解有哪些key path可以设置，这里就不再一一列举，大家可以参照Xcode帮助文档中“CATransform3D Key Paths”一节，里面描述的很详细。</p>
<p><strong>使用自定义图层绘图</strong></p>
<p>在自定义图层中绘图时只要自己编写一个类继承于CALayer然后在<strong>drawInContext:</strong>中绘图即可。同前面在代理方法绘图一样，要显示图层中绘制的内容也要调用图层的setNeedDisplay方法，否则drawInContext方法将不会调用。</p>
<p>前面的文章中曾经说过，在使用Quartz 2D在UIView中绘制图形的本质也是绘制到图层中，为了说明这个问题下面演示自定义图层绘图时没有直接在视图控制器中调用自定义图层，而是在一个UIView将自定义图层添加到UIView的根图层中（例子中的UIView跟自定义图层绘图没有直接关系）。从下面的代码中可以看到：UIView在显示时其根图层会自动创建一个CGContextRef（CALayer本质使用的是位图上下文），同时调用图层代理（UIView创建图层会自动设置图层代理为其自身）的<strong>draw: inContext:</strong>方法并将图形上下文作为参数传递给这个方法。而在UIView的<strong>draw:inContext:</strong>方法中会调用其<strong>drawRect:</strong>方法，在<strong>drawRect:</strong>方法中使用<strong>UIGraphicsGetCurrentContext()</strong>方法得到的上下文正是前面创建的上下文。</p>
<h5 id="KCLayer-m"><a href="#KCLayer-m" class="headerlink" title="KCLayer.m"></a>KCLayer.m</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="preprocessor">#import <span class="string">"KCLayer.h"</span></span></span><br><span class="line"></span><br><span class="line">@implementation KCLayer</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)drawInContext:(CGContextRef)ctx&#123;</span><br><span class="line">    NSLog(@<span class="string">"3-drawInContext:"</span>);</span><br><span class="line">    NSLog(@<span class="string">"CGContext:%@"</span>,ctx);</span><br><span class="line"><span class="comment">//    CGContextRotateCTM(ctx, M_PI_4);</span></span><br><span class="line">    CGContextSetRGBFillColor(ctx, <span class="number">135.0</span>/<span class="number">255.0</span>, <span class="number">232.0</span>/<span class="number">255.0</span>, <span class="number">84.0</span>/<span class="number">255.0</span>, <span class="number">1</span>);</span><br><span class="line">    CGContextSetRGBStrokeColor(ctx, <span class="number">135.0</span>/<span class="number">255.0</span>, <span class="number">232.0</span>/<span class="number">255.0</span>, <span class="number">84.0</span>/<span class="number">255.0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">//    CGContextFillRect(ctx, CGRectMake(0, 0, 100, 100));</span></span><br><span class="line"><span class="comment">//    CGContextFillEllipseInRect(ctx, CGRectMake(50, 50, 100, 100));</span></span><br><span class="line">    CGContextMoveToPoint(ctx, <span class="number">94.5</span>, <span class="number">33.5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//// Star Drawing</span></span><br><span class="line">    CGContextAddLineToPoint(ctx,<span class="number">104.02</span>, <span class="number">47.39</span>);</span><br><span class="line">    CGContextAddLineToPoint(ctx,<span class="number">120.18</span>, <span class="number">52.16</span>);</span><br><span class="line">    CGContextAddLineToPoint(ctx,<span class="number">109.91</span>, <span class="number">65.51</span>);</span><br><span class="line">    CGContextAddLineToPoint(ctx,<span class="number">110.37</span>, <span class="number">82.34</span>);</span><br><span class="line">    CGContextAddLineToPoint(ctx,<span class="number">94.5</span>, <span class="number">76.7</span>);</span><br><span class="line">    CGContextAddLineToPoint(ctx,<span class="number">78.63</span>, <span class="number">82.34</span>);</span><br><span class="line">    CGContextAddLineToPoint(ctx,<span class="number">79.09</span>, <span class="number">65.51</span>);</span><br><span class="line">    CGContextAddLineToPoint(ctx,<span class="number">68.82</span>, <span class="number">52.16</span>);</span><br><span class="line">    CGContextAddLineToPoint(ctx,<span class="number">84.98</span>, <span class="number">47.39</span>);</span><br><span class="line">    CGContextClosePath(ctx);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    CGContextDrawPath(ctx, kCGPathFillStroke);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h5 id="KCView-m"><a href="#KCView-m" class="headerlink" title="KCView.m"></a>KCView.m</h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">"KCView.h"</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">"KCLayer.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">KCView</span></span></span><br><span class="line"></span><br><span class="line">-(instancetype)initWithFrame:(<span class="built_in">CGRect</span>)frame&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"initWithFrame:"</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>=[<span class="keyword">super</span> initWithFrame:frame]) &#123;</span><br><span class="line">        KCLayer *layer=[[KCLayer alloc]init];</span><br><span class="line">        layer<span class="variable">.bounds</span>=<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">185</span>, <span class="number">185</span>);</span><br><span class="line">        layer<span class="variable">.position</span>=<span class="built_in">CGPointMake</span>(<span class="number">160</span>,<span class="number">284</span>);</span><br><span class="line">        layer<span class="variable">.backgroundColor</span>=[<span class="built_in">UIColor</span> colorWithRed:<span class="number">0</span> green:<span class="number">146</span>/<span class="number">255.0</span> blue:<span class="number">1.0</span> alpha:<span class="number">1.0</span>]<span class="variable">.CGColor</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//显示图层</span></span><br><span class="line">        [layer setNeedsDisplay];</span><br><span class="line">        </span><br><span class="line">        [<span class="keyword">self</span><span class="variable">.layer</span> addSublayer:layer];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"2-drawRect:"</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"CGContext:%@"</span>,<span class="built_in">UIGraphicsGetCurrentContext</span>());<span class="comment">//得到的当前图形上下文正是drawLayer中传递的</span></span><br><span class="line">    [<span class="keyword">super</span> drawRect:rect];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)drawLayer:(<span class="built_in">CALayer</span> *)layer inContext:(<span class="built_in">CGContextRef</span>)ctx&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"1-drawLayer:inContext:"</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"CGContext:%@"</span>,ctx);</span><br><span class="line">    [<span class="keyword">super</span> drawLayer:layer inContext:ctx];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>######KCMainViewController.m<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">"KCMainViewController.h"</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">"KCView.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">KCMainViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">KCMainViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    KCView *view=[[KCView alloc]initWithFrame:[<span class="built_in">UIScreen</span> mainScreen]<span class="variable">.bounds</span>];</span><br><span class="line">    view<span class="variable">.backgroundColor</span>=[<span class="built_in">UIColor</span> colorWithRed:<span class="number">249.0</span>/<span class="number">255.0</span> green:<span class="number">249.0</span>/<span class="number">255.0</span> blue:<span class="number">249.0</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.view</span> addSubview:view];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>运行效果：<br><img src="http://images.cnitblog.com/blog/62046/201409/150628396905587.jpg" alt=""></p>
<hr>
<h4 id="Core_Animation"><a href="#Core_Animation" class="headerlink" title="Core Animation"></a>Core Animation</h4><p>大家都知道在iOS中实现一个动画相当简单，只要调用UIView的块代码即可实现一个动画效果，这在其他系统开发中基本不可能实现。下面通过一个简单的UIView进行一个图片放大动画效果演示：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">"KCMainViewController.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">KCMainViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">KCMainViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIImage</span> *image=[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"open2.png"</span>];</span><br><span class="line">    <span class="built_in">UIImageView</span> *imageView=[[<span class="built_in">UIImageView</span> alloc]init];</span><br><span class="line">    imageView<span class="variable">.image</span>=image;</span><br><span class="line">    imageView<span class="variable">.frame</span>=<span class="built_in">CGRectMake</span>(<span class="number">120</span>, <span class="number">140</span>, <span class="number">80</span>, <span class="number">80</span>);</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.view</span> addSubview:imageView];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//两秒后开始一个持续一分钟的动画</span></span><br><span class="line">    [<span class="built_in">UIView</span> animateWithDuration:<span class="number">1</span> delay:<span class="number">2</span> options:<span class="built_in">UIViewAnimationOptionBeginFromCurrentState</span> animations:^&#123;</span><br><span class="line">        imageView<span class="variable">.frame</span>=<span class="built_in">CGRectMake</span>(<span class="number">80</span>, <span class="number">100</span>, <span class="number">160</span>, <span class="number">160</span>);</span><br><span class="line">    &#125; completion:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>使用上面UIView封装的方法进行动画设置固然十分方便，但是具体动画如何实现我们是不清楚的，而且上面的代码还有一些问题是无法解决的，例如：如何控制动画的暂停？如何进行动画的组合？。。。</p>
<p>这里就需要了解iOS的核心动画Core Animation（包含在Quartz Core框架中）。在iOS中核心动画分为几类：基础动画、关键帧动画、动画组、转场动画。各个类的关系大致如下：</p>
<p><img src="http://images.cnitblog.com/blog/62046/201409/150628403626215.png" alt=""></p>
<p>CAAnimation：核心动画的基础类，不能直接使用，负责动画运行时间、速度的控制，本身实现了CAMediaTiming协议。</p>
<p>CAPropertyAnimation：属性动画的基类（通过属性进行动画设置，注意是可动画属性），不能直接使用。</p>
<p>CAAnimationGroup：动画组，动画组是一种组合模式设计，可以通过动画组来进行所有动画行为的统一控制，组中所有动画效果可以并发执行。</p>
<p>CATransition：转场动画，主要通过滤镜进行动画效果设置。</p>
<p>CABasicAnimation：基础动画，通过属性修改进行动画参数控制，只有初始状态和结束状态。</p>
<p>CAKeyframeAnimation：关键帧动画，同样是通过属性进行动画参数控制，但是同基础动画不同的是它可以有多个状态控制。</p>
<p>基础动画、关键帧动画都属于属性动画，就是通过修改属性值产生动画效果，开发人员只需要设置初始值和结束值，中间的过程动画（又叫“补间动画”）由系统自动计算产生。和基础动画不同的是关键帧动画可以设置多个属性值，每两个属性中间的补间动画由系统自动完成，因此从这个角度而言基础动画又可以看成是有两个关键帧的关键帧动画。</p>
<h5 id="u57FA_u7840_u52A8_u753B"><a href="#u57FA_u7840_u52A8_u753B" class="headerlink" title="基础动画"></a>基础动画</h5><p>在开发过程中很多情况下通过基础动画就可以满足开发需求，前面例子中使用的UIView代码块进行图像放大缩小的演示动画也是基础动画（在iOS7中UIView也对关键帧动画进行了封装），只是UIView装饰方法隐藏了更多的细节。如果不使用UIView封装的方法，动画创建一般分为以下几步：</p>
<p>1.初始化动画并设置动画属性</p>
<p>2.设置动画属性初始值（可以省略）、结束值以及其他动画属性</p>
<p>3.给图层添加动画</p>
<p>下面以一个移动动画为例进行演示，在这个例子中点击屏幕哪个位置落花将飞向哪里。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">"KCMainViewController.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">KCMainViewController</span> ()</span>&#123;</span><br><span class="line">    <span class="built_in">CALayer</span> *_layer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">KCMainViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置背景(注意这个图片其实在根图层)</span></span><br><span class="line">    <span class="built_in">UIImage</span> *backgroundImage=[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"background.jpg"</span>];</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.backgroundColor</span>=[<span class="built_in">UIColor</span> colorWithPatternImage:backgroundImage];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//自定义一个图层</span></span><br><span class="line">    _layer=[[<span class="built_in">CALayer</span> alloc]init];</span><br><span class="line">    _layer<span class="variable">.bounds</span>=<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    _layer<span class="variable">.position</span>=<span class="built_in">CGPointMake</span>(<span class="number">50</span>, <span class="number">150</span>);</span><br><span class="line">    _layer<span class="variable">.contents</span>=(<span class="keyword">id</span>)[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"petal.png"</span>]<span class="variable">.CGImage</span>;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.view</span><span class="variable">.layer</span> addSublayer:_layer];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark 移动动画</span></span><br><span class="line">-(<span class="keyword">void</span>)translatonAnimation:(<span class="built_in">CGPoint</span>)location&#123;</span><br><span class="line">    <span class="comment">//1.创建动画并指定动画属性</span></span><br><span class="line">    <span class="built_in">CABasicAnimation</span> *basicAnimation=[<span class="built_in">CABasicAnimation</span> animationWithKeyPath:<span class="string">@"position"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.设置动画属性初始值和结束值</span></span><br><span class="line"><span class="comment">//    basicAnimation.fromValue=[NSNumber numberWithInteger:50];//可以不设置，默认为图层初始状态</span></span><br><span class="line">    basicAnimation<span class="variable">.toValue</span>=[<span class="built_in">NSValue</span> valueWith<span class="built_in">CGPoint</span>:location];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置其他动画属性</span></span><br><span class="line">    basicAnimation<span class="variable">.duration</span>=<span class="number">5.0</span>;<span class="comment">//动画时间5秒</span></span><br><span class="line">    <span class="comment">//basicAnimation.repeatCount=HUGE_VALF;//设置重复次数,HUGE_VALF可看做无穷大，起到循环动画的效果</span></span><br><span class="line">    <span class="comment">//    basicAnimation.removedOnCompletion=NO;//运行一次是否移除动画</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.添加动画到图层，注意key相当于给动画进行命名，以后获得该动画时可以使用此名称获取</span></span><br><span class="line">    [_layer addAnimation:basicAnimation forKey:<span class="string">@"KCBasicAnimation_Translation"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark 点击事件</span></span><br><span class="line">-(<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</span><br><span class="line">    <span class="built_in">UITouch</span> *touch=touches<span class="variable">.anyObject</span>;</span><br><span class="line">    <span class="built_in">CGPoint</span> location= [touch locationInView:<span class="keyword">self</span><span class="variable">.view</span>];</span><br><span class="line">    <span class="comment">//创建并开始动画</span></span><br><span class="line">    [<span class="keyword">self</span> translatonAnimation:location];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>运行效果：</p>
<p><img src="http://images.cnitblog.com/blog/62046/201409/150628410812829.gif" alt=""></p>
<p>上面实现了一个基本动画效果，但是这个动画存在一个问题：动画结束后动画图层回到了原来的位置，当然是用UIView封装的方法是没有这个问题的。如何解决这个问题呢？</p>
<p>前面说过图层动画的本质就是将图层内部的内容转化为位图经硬件操作形成一种动画效果，其实图层本身并没有任何的变化。上面的动画中图层并没有因为动画效果而改变它的位置（对于缩放动画其大小也是不会改变的），所以动画完成之后图层还是在原来的显示位置没有任何变化，如果这个图层在一个UIView中你会发现在UIView移动过程中你要触发UIView的点击事件也只能点击原来的位置（即使它已经运动到了别的位置），因为它的位置从来没有变过。当然解决这个问题方法比较多，这里不妨在动画完成之后重新设置它的位置。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">"KCMainViewController.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">KCMainViewController</span> ()</span>&#123;</span><br><span class="line">    <span class="built_in">CALayer</span> *_layer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">KCMainViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置背景(注意这个图片其实在根图层)</span></span><br><span class="line">    <span class="built_in">UIImage</span> *backgroundImage=[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"background.jpg"</span>];</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.backgroundColor</span>=[<span class="built_in">UIColor</span> colorWithPatternImage:backgroundImage];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//自定义一个图层</span></span><br><span class="line">    _layer=[[<span class="built_in">CALayer</span> alloc]init];</span><br><span class="line">    _layer<span class="variable">.bounds</span>=<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    _layer<span class="variable">.position</span>=<span class="built_in">CGPointMake</span>(<span class="number">50</span>, <span class="number">150</span>);</span><br><span class="line">    _layer<span class="variable">.contents</span>=(<span class="keyword">id</span>)[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"petal.png"</span>]<span class="variable">.CGImage</span>;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.view</span><span class="variable">.layer</span> addSublayer:_layer];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark 移动动画</span></span><br><span class="line">-(<span class="keyword">void</span>)translatonAnimation:(<span class="built_in">CGPoint</span>)location&#123;</span><br><span class="line">    <span class="comment">//1.创建动画并指定动画属性</span></span><br><span class="line">    <span class="built_in">CABasicAnimation</span> *basicAnimation=[<span class="built_in">CABasicAnimation</span> animationWithKeyPath:<span class="string">@"position"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.设置动画属性初始值和结束值</span></span><br><span class="line"><span class="comment">//    basicAnimation.fromValue=[NSNumber numberWithInteger:50];//可以不设置，默认为图层初始状态</span></span><br><span class="line">    basicAnimation<span class="variable">.toValue</span>=[<span class="built_in">NSValue</span> valueWith<span class="built_in">CGPoint</span>:location];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置其他动画属性</span></span><br><span class="line">    basicAnimation<span class="variable">.duration</span>=<span class="number">5.0</span>;<span class="comment">//动画时间5秒</span></span><br><span class="line">    <span class="comment">//basicAnimation.repeatCount=HUGE_VALF;//设置重复次数,HUGE_VALF可看做无穷大，起到循环动画的效果</span></span><br><span class="line">    <span class="comment">//    basicAnimation.removedOnCompletion=NO;//运行一次是否移除动画</span></span><br><span class="line">    basicAnimation<span class="variable">.delegate</span>=<span class="keyword">self</span>;</span><br><span class="line">    <span class="comment">//存储当前位置在动画结束后使用</span></span><br><span class="line">    [basicAnimation setValue:[<span class="built_in">NSValue</span> valueWith<span class="built_in">CGPoint</span>:location] forKey:<span class="string">@"KCBasicAnimationLocation"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.添加动画到图层，注意key相当于给动画进行命名，以后获得该动画时可以使用此名称获取</span></span><br><span class="line">    [_layer addAnimation:basicAnimation forKey:<span class="string">@"KCBasicAnimation_Translation"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark 点击事件</span></span><br><span class="line">-(<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</span><br><span class="line">    <span class="built_in">UITouch</span> *touch=touches<span class="variable">.anyObject</span>;</span><br><span class="line">    <span class="built_in">CGPoint</span> location= [touch locationInView:<span class="keyword">self</span><span class="variable">.view</span>];</span><br><span class="line">    <span class="comment">//创建并开始动画</span></span><br><span class="line">    [<span class="keyword">self</span> translatonAnimation:location];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - 动画代理方法</span></span><br><span class="line"><span class="preprocessor">#pragma mark 动画开始</span></span><br><span class="line">-(<span class="keyword">void</span>)animationDidStart:(<span class="built_in">CAAnimation</span> *)anim&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"animation(%@) start.\r_layer.frame=%@"</span>,anim,<span class="built_in">NSStringFromCGRect</span>(_layer<span class="variable">.frame</span>));</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[_layer animationForKey:<span class="string">@"KCBasicAnimation_Translation"</span>]);<span class="comment">//通过前面的设置的key获得动画</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark 动画结束</span></span><br><span class="line">-(<span class="keyword">void</span>)animationDidStop:(<span class="built_in">CAAnimation</span> *)anim finished:(<span class="built_in">BOOL</span>)flag&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"animation(%@) stop.\r_layer.frame=%@"</span>,anim,<span class="built_in">NSStringFromCGRect</span>(_layer<span class="variable">.frame</span>));</span><br><span class="line">    _layer<span class="variable">.position</span>=[[anim valueForKey:<span class="string">@"KCBasicAnimationLocation"</span>] <span class="built_in">CGPointValue</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>上面通过给动画设置一个代理去监听动画的开始和结束事件，在动画开始前给动画添加一个自定义属性“KCBasicAnimationLocation”存储动画终点位置，然后在动画结束后设置动画的位置为终点位置。</p>
<p>如果运行上面的代码大家可能会发现另外一个问题，那就是动画运行完成后会重新从起始点运动到终点。这个问题产生的原因就是前面提到的，对于非根图层，设置图层的可动画属性（在动画结束后重新设置了position，而position是可动画属性）会产生动画效果。解决这个问题有两种办法：关闭图层隐式动画、设置动画图层为根图层。显然这里不能采取后者，因为根图层当前已经作为动画的背景。</p>
<p>要关闭隐式动画需要用到动画事务CATransaction，在事务内将隐式动画关闭，例如上面的代码可以改为：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#pragma mark 动画结束</span></span><br><span class="line">-(<span class="keyword">void</span>)animationDidStop:(<span class="built_in">CAAnimation</span> *)anim finished:(<span class="built_in">BOOL</span>)flag&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"animation(%@) stop.\r_layer.frame=%@"</span>,anim,<span class="built_in">NSStringFromCGRect</span>(_layer<span class="variable">.frame</span>));</span><br><span class="line">    <span class="comment">//开启事务</span></span><br><span class="line">    [<span class="built_in">CATransaction</span> begin];</span><br><span class="line">    <span class="comment">//禁用隐式动画</span></span><br><span class="line">    [<span class="built_in">CATransaction</span> setDisableActions:<span class="literal">YES</span>];</span><br><span class="line">    </span><br><span class="line">    _layer<span class="variable">.position</span>=[[anim valueForKey:<span class="string">@"KCBasicAnimationLocation"</span>] <span class="built_in">CGPointValue</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//提交事务</span></span><br><span class="line">    [<span class="built_in">CATransaction</span> commit];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>补充：<br>上面通过在animationDidStop中重新设置动画的位置主要为了说明隐式动画关闭和动画事件之间传参的内容，有朋友发现这种方式有可能在动画运行完之后出现从原点瞬间回到终点的过程，最早在调试的时候没有发现这个问题，这里感谢这位朋友。其实解决这个问题并不难，首先必须设置fromValue，其次在动画开始前设置动画position为终点位置（当然也必须关闭隐式动画）。但是这里主要还是出于学习的目的，真正开发的时候做平移动画直接使用隐式动画即可，没有必要那么麻烦。</p>
</blockquote>
<p>当然上面的动画还显得有些生硬，因为落花飘散的时候可能不仅仅是自由落体运动，本身由于空气阻力、外界风力还会造成落花在空中的旋转、摇摆等，这里不妨给图层添加一个旋转的动画。对于图层的旋转前面已经演示过怎么通过key path设置图层旋转的内容了，在这里需要强调一下，图层的形变都是基于锚点进行的。例如旋转，旋转的中心点就是图层的锚点。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">"KCMainViewController.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">KCMainViewController</span> ()</span>&#123;</span><br><span class="line">    <span class="built_in">CALayer</span> *_layer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">KCMainViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置背景(注意这个图片其实在根图层)</span></span><br><span class="line">    <span class="built_in">UIImage</span> *backgroundImage=[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"background.jpg"</span>];</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.backgroundColor</span>=[<span class="built_in">UIColor</span> colorWithPatternImage:backgroundImage];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//自定义一个图层</span></span><br><span class="line">    _layer=[[<span class="built_in">CALayer</span> alloc]init];</span><br><span class="line">    _layer<span class="variable">.bounds</span>=<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    _layer<span class="variable">.position</span>=<span class="built_in">CGPointMake</span>(<span class="number">50</span>, <span class="number">150</span>);</span><br><span class="line">    _layer<span class="variable">.anchorPoint</span>=<span class="built_in">CGPointMake</span>(<span class="number">0.5</span>, <span class="number">0.6</span>);<span class="comment">//设置锚点</span></span><br><span class="line">    _layer<span class="variable">.contents</span>=(<span class="keyword">id</span>)[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"petal.png"</span>]<span class="variable">.CGImage</span>;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.view</span><span class="variable">.layer</span> addSublayer:_layer];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark 移动动画</span></span><br><span class="line">-(<span class="keyword">void</span>)translatonAnimation:(<span class="built_in">CGPoint</span>)location&#123;</span><br><span class="line">    <span class="comment">//1.创建动画并指定动画属性</span></span><br><span class="line">    <span class="built_in">CABasicAnimation</span> *basicAnimation=[<span class="built_in">CABasicAnimation</span> animationWithKeyPath:<span class="string">@"position"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.设置动画属性初始值、结束值</span></span><br><span class="line"><span class="comment">//    basicAnimation.fromValue=[NSNumber numberWithInteger:50];//可以不设置，默认为图层初始状态</span></span><br><span class="line">    basicAnimation<span class="variable">.toValue</span>=[<span class="built_in">NSValue</span> valueWith<span class="built_in">CGPoint</span>:location];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置其他动画属性</span></span><br><span class="line">    basicAnimation<span class="variable">.duration</span>=<span class="number">5.0</span>;<span class="comment">//动画时间5秒</span></span><br><span class="line">    <span class="comment">//basicAnimation.repeatCount=HUGE_VALF;//设置重复次数,HUGE_VALF可看做无穷大，起到循环动画的效果</span></span><br><span class="line">    <span class="comment">//    basicAnimation.removedOnCompletion=NO;//运行一次是否移除动画</span></span><br><span class="line">    basicAnimation<span class="variable">.delegate</span>=<span class="keyword">self</span>;</span><br><span class="line">    <span class="comment">//存储当前位置在动画结束后使用</span></span><br><span class="line">    [basicAnimation setValue:[<span class="built_in">NSValue</span> valueWith<span class="built_in">CGPoint</span>:location] forKey:<span class="string">@"KCBasicAnimationLocation"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.添加动画到图层，注意key相当于给动画进行命名，以后获得该图层时可以使用此名称获取</span></span><br><span class="line">    [_layer addAnimation:basicAnimation forKey:<span class="string">@"KCBasicAnimation_Translation"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark 旋转动画</span></span><br><span class="line">-(<span class="keyword">void</span>)rotationAnimation&#123;</span><br><span class="line">    <span class="comment">//1.创建动画并指定动画属性</span></span><br><span class="line">    <span class="built_in">CABasicAnimation</span> *basicAnimation=[<span class="built_in">CABasicAnimation</span> animationWithKeyPath:<span class="string">@"transform.rotation.z"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.设置动画属性初始值、结束值</span></span><br><span class="line"><span class="comment">//    basicAnimation.fromValue=[NSNumber numberWithInt:M_PI_2];</span></span><br><span class="line">    basicAnimation<span class="variable">.toValue</span>=[<span class="built_in">NSNumber</span> numberWithFloat:M_PI_2*<span class="number">3</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置其他动画属性</span></span><br><span class="line">    basicAnimation<span class="variable">.duration</span>=<span class="number">6.0</span>;</span><br><span class="line">    basicAnimation<span class="variable">.autoreverses</span>=<span class="literal">true</span>;<span class="comment">//旋转后再旋转到原来的位置</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4.添加动画到图层，注意key相当于给动画进行命名，以后获得该动画时可以使用此名称获取</span></span><br><span class="line">    [_layer addAnimation:basicAnimation forKey:<span class="string">@"KCBasicAnimation_Rotation"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark 点击事件</span></span><br><span class="line">-(<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</span><br><span class="line">    <span class="built_in">UITouch</span> *touch=touches<span class="variable">.anyObject</span>;</span><br><span class="line">    <span class="built_in">CGPoint</span> location= [touch locationInView:<span class="keyword">self</span><span class="variable">.view</span>];</span><br><span class="line">    <span class="comment">//创建并开始动画</span></span><br><span class="line">    [<span class="keyword">self</span> translatonAnimation:location];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> rotationAnimation];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - 动画代理方法</span></span><br><span class="line"><span class="preprocessor">#pragma mark 动画开始</span></span><br><span class="line">-(<span class="keyword">void</span>)animationDidStart:(<span class="built_in">CAAnimation</span> *)anim&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"animation(%@) start.\r_layer.frame=%@"</span>,anim,<span class="built_in">NSStringFromCGRect</span>(_layer<span class="variable">.frame</span>));</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[_layer animationForKey:<span class="string">@"KCBasicAnimation_Translation"</span>]);<span class="comment">//通过前面的设置的key获得动画</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark 动画结束</span></span><br><span class="line">-(<span class="keyword">void</span>)animationDidStop:(<span class="built_in">CAAnimation</span> *)anim finished:(<span class="built_in">BOOL</span>)flag&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"animation(%@) stop.\r_layer.frame=%@"</span>,anim,<span class="built_in">NSStringFromCGRect</span>(_layer<span class="variable">.frame</span>));</span><br><span class="line">    <span class="comment">//开启事务</span></span><br><span class="line">    [<span class="built_in">CATransaction</span> begin];</span><br><span class="line">    <span class="comment">//禁用隐式动画</span></span><br><span class="line">    [<span class="built_in">CATransaction</span> setDisableActions:<span class="literal">YES</span>];</span><br><span class="line">    </span><br><span class="line">    _layer<span class="variable">.position</span>=[[anim valueForKey:<span class="string">@"KCBasicAnimationLocation"</span>] <span class="built_in">CGPointValue</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//提交事务</span></span><br><span class="line">    [<span class="built_in">CATransaction</span> commit];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>上面代码中结合两种动画操作，需要注意的是只给移动动画设置了代理，在旋转动画中并没有设置代理，否则代理方法会执行两遍。由于旋转动画会无限循环执行（上面设置了重复次数无穷大），并且两个动画的执行时间没有必然的关系，这样一来移动停止后可能还在旋转，为了让移动动画停止后旋转动画停止就需要使用到动画的暂停和恢复方法。</p>
<p>核心动画的运行有一个媒体时间的概念，假设将一个旋转动画设置旋转一周用时60秒的话，那么当动画旋转90度后媒体时间就是15秒。如果此时要将动画暂停只需要让媒体时间偏移量设置为15秒即可，并把动画运行速度设置为0使其停止运动。类似的，如果又过了60秒后需要恢复动画（此时媒体时间为75秒），这时只要将动画开始开始时间设置为当前媒体时间75秒减去暂停时的时间（也就是之前定格动画时的偏移量）15秒（开始时间=75-15=60秒），那么动画就会重新计算60秒后的状态再开始运行，与此同时将偏移量重新设置为0并且把运行速度设置1。这个过程中真正起到暂停动画和恢复动画的其实是动画速度的调整，媒体时间偏移量以及恢复时的开始时间设置主要为了让动画更加连贯。</p>
<p>下面的代码演示了移动动画结束后旋转动画暂停，并且当再次点击动画时旋转恢复的过程(注意在移动过程中如果再次点击屏幕可以暂停移动和旋转动画，再次点击可以恢复两种动画。但是当移动结束后触发了移动动画的完成事件如果再次点击屏幕则只能恢复旋转动画，因为此时移动动画已经结束而不是暂停，无法再恢复)。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">"KCMainViewController.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">KCMainViewController</span> ()</span>&#123;</span><br><span class="line">    <span class="built_in">CALayer</span> *_layer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">KCMainViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置背景(注意这个图片其实在根图层)</span></span><br><span class="line">    <span class="built_in">UIImage</span> *backgroundImage=[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"background.jpg"</span>];</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.backgroundColor</span>=[<span class="built_in">UIColor</span> colorWithPatternImage:backgroundImage];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//自定义一个图层</span></span><br><span class="line">    _layer=[[<span class="built_in">CALayer</span> alloc]init];</span><br><span class="line">    _layer<span class="variable">.bounds</span>=<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    _layer<span class="variable">.position</span>=<span class="built_in">CGPointMake</span>(<span class="number">50</span>, <span class="number">150</span>);</span><br><span class="line">    _layer<span class="variable">.anchorPoint</span>=<span class="built_in">CGPointMake</span>(<span class="number">0.5</span>, <span class="number">0.6</span>);<span class="comment">//设置锚点</span></span><br><span class="line">    _layer<span class="variable">.contents</span>=(<span class="keyword">id</span>)[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"petal.png"</span>]<span class="variable">.CGImage</span>;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.view</span><span class="variable">.layer</span> addSublayer:_layer];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark 移动动画</span></span><br><span class="line">-(<span class="keyword">void</span>)translatonAnimation:(<span class="built_in">CGPoint</span>)location&#123;</span><br><span class="line">    <span class="comment">//1.创建动画并指定动画属性</span></span><br><span class="line">    <span class="built_in">CABasicAnimation</span> *basicAnimation=[<span class="built_in">CABasicAnimation</span> animationWithKeyPath:<span class="string">@"position"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.设置动画属性初始值、结束值</span></span><br><span class="line"><span class="comment">//    basicAnimation.fromValue=[NSNumber numberWithInteger:50];//可以不设置，默认为图层初始状态</span></span><br><span class="line">    basicAnimation<span class="variable">.toValue</span>=[<span class="built_in">NSValue</span> valueWith<span class="built_in">CGPoint</span>:location];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置其他动画属性</span></span><br><span class="line">    basicAnimation<span class="variable">.duration</span>=<span class="number">5.0</span>;<span class="comment">//动画时间5秒</span></span><br><span class="line"><span class="comment">//    basicAnimation.repeatCount=HUGE_VALF;//设置重复次数,HUGE_VALF可看做无穷大，起到循环动画的效果</span></span><br><span class="line">    basicAnimation<span class="variable">.removedOnCompletion</span>=<span class="literal">NO</span>;<span class="comment">//运行一次是否移除动画</span></span><br><span class="line">    basicAnimation<span class="variable">.delegate</span>=<span class="keyword">self</span>;</span><br><span class="line">    <span class="comment">//存储当前位置在动画结束后使用</span></span><br><span class="line">    [basicAnimation setValue:[<span class="built_in">NSValue</span> valueWith<span class="built_in">CGPoint</span>:location] forKey:<span class="string">@"KCBasicAnimationLocation"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.添加动画到图层，注意key相当于给动画进行命名，以后获得该图层时可以使用此名称获取</span></span><br><span class="line">    [_layer addAnimation:basicAnimation forKey:<span class="string">@"KCBasicAnimation_Translation"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark 旋转动画</span></span><br><span class="line">-(<span class="keyword">void</span>)rotationAnimation&#123;</span><br><span class="line">    <span class="comment">//1.创建动画并指定动画属性</span></span><br><span class="line">    <span class="built_in">CABasicAnimation</span> *basicAnimation=[<span class="built_in">CABasicAnimation</span> animationWithKeyPath:<span class="string">@"transform.rotation.z"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.设置动画属性初始值、结束值</span></span><br><span class="line"><span class="comment">//    basicAnimation.fromValue=[NSNumber numberWithInt:M_PI_2];</span></span><br><span class="line">    basicAnimation<span class="variable">.toValue</span>=[<span class="built_in">NSNumber</span> numberWithFloat:M_PI_2*<span class="number">3</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置其他动画属性</span></span><br><span class="line">    basicAnimation<span class="variable">.duration</span>=<span class="number">6.0</span>;</span><br><span class="line">    basicAnimation<span class="variable">.autoreverses</span>=<span class="literal">true</span>;<span class="comment">//旋转后在旋转到原来的位置</span></span><br><span class="line">    basicAnimation<span class="variable">.repeatCount</span>=HUGE_VALF;<span class="comment">//设置无限循环</span></span><br><span class="line">    basicAnimation<span class="variable">.removedOnCompletion</span>=<span class="literal">NO</span>;</span><br><span class="line"><span class="comment">//    basicAnimation.delegate=self;</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4.添加动画到图层，注意key相当于给动画进行命名，以后获得该动画时可以使用此名称获取</span></span><br><span class="line">    [_layer addAnimation:basicAnimation forKey:<span class="string">@"KCBasicAnimation_Rotation"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark 点击事件</span></span><br><span class="line">-(<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</span><br><span class="line">    <span class="built_in">UITouch</span> *touch=touches<span class="variable">.anyObject</span>;</span><br><span class="line">    <span class="built_in">CGPoint</span> location= [touch locationInView:<span class="keyword">self</span><span class="variable">.view</span>];</span><br><span class="line">    <span class="comment">//判断是否已经常见过动画，如果已经创建则不再创建动画</span></span><br><span class="line">    <span class="built_in">CAAnimation</span> *animation= [_layer animationForKey:<span class="string">@"KCBasicAnimation_Translation"</span>];</span><br><span class="line">    <span class="keyword">if</span>(animation)&#123;</span><br><span class="line">        <span class="keyword">if</span> (_layer<span class="variable">.speed</span>==<span class="number">0</span>) &#123;</span><br><span class="line">            [<span class="keyword">self</span> animationResume];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            [<span class="keyword">self</span> animationPause];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//创建并开始动画</span></span><br><span class="line">        [<span class="keyword">self</span> translatonAnimation:location];</span><br><span class="line">        </span><br><span class="line">        [<span class="keyword">self</span> rotationAnimation];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark 动画暂停</span></span><br><span class="line">-(<span class="keyword">void</span>)animationPause&#123;</span><br><span class="line">    <span class="comment">//取得指定图层动画的媒体时间，后面参数用于指定子图层，这里不需要</span></span><br><span class="line">    <span class="built_in">CFTimeInterval</span> interval=[_layer convertTime:<span class="built_in">CACurrentMediaTime</span>() fromLayer:<span class="literal">nil</span>];</span><br><span class="line">    <span class="comment">//设置时间偏移量，保证暂停时停留在旋转的位置</span></span><br><span class="line">    [_layer setTimeOffset:interval];</span><br><span class="line">    <span class="comment">//速度设置为0，暂停动画</span></span><br><span class="line">    _layer<span class="variable">.speed</span>=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark 动画恢复</span></span><br><span class="line">-(<span class="keyword">void</span>)animationResume&#123;</span><br><span class="line">    <span class="comment">//获得暂停的时间</span></span><br><span class="line">    <span class="built_in">CFTimeInterval</span> beginTime= <span class="built_in">CACurrentMediaTime</span>()- _layer<span class="variable">.timeOffset</span>;</span><br><span class="line">    <span class="comment">//设置偏移量</span></span><br><span class="line">    _layer<span class="variable">.timeOffset</span>=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//设置开始时间</span></span><br><span class="line">    _layer<span class="variable">.beginTime</span>=beginTime;</span><br><span class="line">    <span class="comment">//设置动画速度，开始运动</span></span><br><span class="line">    _layer<span class="variable">.speed</span>=<span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - 动画代理方法</span></span><br><span class="line"><span class="preprocessor">#pragma mark 动画开始</span></span><br><span class="line">-(<span class="keyword">void</span>)animationDidStart:(<span class="built_in">CAAnimation</span> *)anim&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"animation(%@) start.\r_layer.frame=%@"</span>,anim,<span class="built_in">NSStringFromCGRect</span>(_layer<span class="variable">.frame</span>));</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[_layer animationForKey:<span class="string">@"KCBasicAnimation_Translation"</span>]);<span class="comment">//通过前面的设置的key获得动画</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark 动画结束</span></span><br><span class="line">-(<span class="keyword">void</span>)animationDidStop:(<span class="built_in">CAAnimation</span> *)anim finished:(<span class="built_in">BOOL</span>)flag&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"animation(%@) stop.\r_layer.frame=%@"</span>,anim,<span class="built_in">NSStringFromCGRect</span>(_layer<span class="variable">.frame</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//开启事务</span></span><br><span class="line">    [<span class="built_in">CATransaction</span> begin];</span><br><span class="line">    <span class="comment">//禁用隐式动画</span></span><br><span class="line">    [<span class="built_in">CATransaction</span> setDisableActions:<span class="literal">YES</span>];</span><br><span class="line">    </span><br><span class="line">    _layer<span class="variable">.position</span>=[[anim valueForKey:<span class="string">@"KCBasicAnimationLocation"</span>] <span class="built_in">CGPointValue</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//提交事务</span></span><br><span class="line">    [<span class="built_in">CATransaction</span> commit];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//暂停动画</span></span><br><span class="line">    [<span class="keyword">self</span> animationPause];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>运行效果：</p>
<p><img src="http://images.cnitblog.com/blog/62046/201409/150628422217913.gif" alt=""></p>
<p><strong>注意：</strong></p>
<ul>
<li>动画暂停针对的是图层而不是图层中的某个动画。</li>
<li>要做无限循环的动画，动画的removedOnCompletion属性必须设置为NO，否则运行一次动画就会销毁。</li>
</ul>
<h5 id="u5173_u952E_u5E27_u52A8_u753B"><a href="#u5173_u952E_u5E27_u52A8_u753B" class="headerlink" title="关键帧动画"></a>关键帧动画</h5><p>熟悉flash开发的朋友对于关键帧动画应该不陌生，这种动画方式在flash开发中经常用到。关键帧动画就是在动画控制过程中开发者指定主要的动画状态，至于各个状态间动画如何进行则由系统自动运算补充（每两个关键帧之间系统形成的动画称为“补间动画”），这种动画的好处就是开发者不用逐个控制每个动画帧，而只要关心几个关键帧的状态即可。</p>
<p>关键帧动画开发分为两种形式：一种是通过设置不同的属性值进行关键帧控制，另一种是通过绘制路径进行关键帧控制。后者优先级高于前者，如果设置了路径则属性值就不再起作用。</p>
<p>对于前面的落花动画效果而言其实落花的过程并不自然，很显然实际生活中它不可能沿着直线下落，这里我们不妨通过关键帧动画的values属性控制它在下落过程中的属性。假设下落过程如图：</p>
<p><img src="http://images.cnitblog.com/blog/62046/201409/150628432212741.png" alt=""></p>
<p>在这里需要设置四个关键帧（如图中四个关键点），具体代码如下（动画创建过程同基本动画基本完全一致）:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  通过values设置关键帧动画</span></span><br><span class="line"><span class="comment">//  Animation</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Kenshin Cui on 14-3-22.</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#import <span class="title">"KCMainViewController.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">KCMainViewController</span> ()</span>&#123;</span><br><span class="line">    <span class="built_in">CALayer</span> *_layer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">KCMainViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置背景(注意这个图片其实在根图层)</span></span><br><span class="line">    <span class="built_in">UIImage</span> *backgroundImage=[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"background.jpg"</span>];</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.backgroundColor</span>=[<span class="built_in">UIColor</span> colorWithPatternImage:backgroundImage];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义一个图层</span></span><br><span class="line">    _layer=[[<span class="built_in">CALayer</span> alloc]init];</span><br><span class="line">    _layer<span class="variable">.bounds</span>=<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    _layer<span class="variable">.position</span>=<span class="built_in">CGPointMake</span>(<span class="number">50</span>, <span class="number">150</span>);</span><br><span class="line">    _layer<span class="variable">.contents</span>=(<span class="keyword">id</span>)[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"petal.png"</span>]<span class="variable">.CGImage</span>;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.view</span><span class="variable">.layer</span> addSublayer:_layer];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建动画</span></span><br><span class="line">    [<span class="keyword">self</span> translationAnimation];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark 关键帧动画</span></span><br><span class="line">-(<span class="keyword">void</span>)translationAnimation&#123;</span><br><span class="line">    <span class="comment">//1.创建关键帧动画并设置动画属性</span></span><br><span class="line">    <span class="built_in">CAKeyframeAnimation</span> *keyframeAnimation=[<span class="built_in">CAKeyframeAnimation</span> animationWithKeyPath:<span class="string">@"position"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.设置关键帧,这里有四个关键帧</span></span><br><span class="line">    <span class="built_in">NSValue</span> *key1=[<span class="built_in">NSValue</span> valueWith<span class="built_in">CGPoint</span>:_layer<span class="variable">.position</span>];<span class="comment">//对于关键帧动画初始值不能省略</span></span><br><span class="line">    <span class="built_in">NSValue</span> *key2=[<span class="built_in">NSValue</span> valueWith<span class="built_in">CGPoint</span>:<span class="built_in">CGPointMake</span>(<span class="number">80</span>, <span class="number">220</span>)];</span><br><span class="line">    <span class="built_in">NSValue</span> *key3=[<span class="built_in">NSValue</span> valueWith<span class="built_in">CGPoint</span>:<span class="built_in">CGPointMake</span>(<span class="number">45</span>, <span class="number">300</span>)];</span><br><span class="line">    <span class="built_in">NSValue</span> *key4=[<span class="built_in">NSValue</span> valueWith<span class="built_in">CGPoint</span>:<span class="built_in">CGPointMake</span>(<span class="number">55</span>, <span class="number">400</span>)];</span><br><span class="line">    <span class="built_in">NSArray</span> *values=@[key1,key2,key3,key4];</span><br><span class="line">    keyframeAnimation<span class="variable">.values</span>=values;</span><br><span class="line">    <span class="comment">//设置其他属性</span></span><br><span class="line">    keyframeAnimation<span class="variable">.duration</span>=<span class="number">8.0</span>;</span><br><span class="line">    keyframeAnimation<span class="variable">.beginTime</span>=<span class="built_in">CACurrentMediaTime</span>()+<span class="number">2</span>;<span class="comment">//设置延迟2秒执行</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.添加动画到图层，添加动画后就会执行动画</span></span><br><span class="line">    [_layer addAnimation:keyframeAnimation forKey:<span class="string">@"KCKeyframeAnimation_Position"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>运行效果(注意运行结束没有设置图层位置为动画运动结束位置)：</p>
<p><img src="http://images.cnitblog.com/blog/62046/201409/150628438318855.gif" alt=""></p>
<p>上面的方式固然比前面使用基础动画效果要好一些，但其实还是存在问题，那就是落花飞落的路径是直线的，当然这个直线是根据程序中设置的四个关键帧自动形成的，那么如何让它沿着曲线飘落呢？这就是第二种类型的关键帧动画，通过描绘路径进行关键帧动画控制。假设让落花沿着下面的曲线路径飘落：</p>
<p><img src="http://images.cnitblog.com/blog/62046/201409/150628443935283.png" alt=""></p>
<p>当然，这是一条贝塞尔曲线，学习了前篇文章之后相信对于这类曲线应该并不陌生，下面是具体实现代码：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  通过path设置关键帧动画</span></span><br><span class="line"><span class="comment">//  Animation</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Kenshin Cui on 14-3-22.</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#import <span class="title">"KCMainViewController.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">KCMainViewController</span> ()</span>&#123;</span><br><span class="line">    <span class="built_in">CALayer</span> *_layer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">KCMainViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置背景(注意这个图片其实在根图层)</span></span><br><span class="line">    <span class="built_in">UIImage</span> *backgroundImage=[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"background.jpg"</span>];</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.backgroundColor</span>=[<span class="built_in">UIColor</span> colorWithPatternImage:backgroundImage];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//自定义一个图层</span></span><br><span class="line">    _layer=[[<span class="built_in">CALayer</span> alloc]init];</span><br><span class="line">    _layer<span class="variable">.bounds</span>=<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    _layer<span class="variable">.position</span>=<span class="built_in">CGPointMake</span>(<span class="number">50</span>, <span class="number">150</span>);</span><br><span class="line">    _layer<span class="variable">.contents</span>=(<span class="keyword">id</span>)[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"petal.png"</span>]<span class="variable">.CGImage</span>;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.view</span><span class="variable">.layer</span> addSublayer:_layer];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建动画</span></span><br><span class="line">    [<span class="keyword">self</span> translationAnimation];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark 关键帧动画</span></span><br><span class="line">-(<span class="keyword">void</span>)translationAnimation&#123;</span><br><span class="line">    <span class="comment">//1.创建关键帧动画并设置动画属性</span></span><br><span class="line">    <span class="built_in">CAKeyframeAnimation</span> *keyframeAnimation=[<span class="built_in">CAKeyframeAnimation</span> animationWithKeyPath:<span class="string">@"position"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.设置路径</span></span><br><span class="line">    <span class="comment">//绘制贝塞尔曲线</span></span><br><span class="line">    <span class="built_in">CGPathRef</span> path=<span class="built_in">CGPathCreateMutable</span>();</span><br><span class="line">    <span class="built_in">CGPathMoveToPoint</span>(path, <span class="literal">NULL</span>, _layer<span class="variable">.position</span><span class="variable">.x</span>, _layer<span class="variable">.position</span><span class="variable">.y</span>);<span class="comment">//移动到起始点</span></span><br><span class="line">    <span class="built_in">CGPathAddCurveToPoint</span>(path, <span class="literal">NULL</span>, <span class="number">160</span>, <span class="number">280</span>, -<span class="number">30</span>, <span class="number">300</span>, <span class="number">55</span>, <span class="number">400</span>);<span class="comment">//绘制二次贝塞尔曲线</span></span><br><span class="line"></span><br><span class="line">    keyframeAnimation<span class="variable">.path</span>=path;<span class="comment">//设置path属性</span></span><br><span class="line">    <span class="built_in">CGPathRelease</span>(path);<span class="comment">//释放路径对象</span></span><br><span class="line">    <span class="comment">//设置其他属性</span></span><br><span class="line">    keyframeAnimation<span class="variable">.duration</span>=<span class="number">8.0</span>;</span><br><span class="line">    keyframeAnimation<span class="variable">.beginTime</span>=<span class="built_in">CACurrentMediaTime</span>()+<span class="number">5</span>;<span class="comment">//设置延迟2秒执行</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.添加动画到图层，添加动画后就会执行动画</span></span><br><span class="line">    [_layer addAnimation:keyframeAnimation forKey:<span class="string">@"KCKeyframeAnimation_Position"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>运行效果(注意运行结束没有设置图层位置为动画运动结束位置)：</p>
<p><img src="http://images.cnitblog.com/blog/62046/201409/150628450189925.gif" alt=""></p>
<p>看起来动画不会那么生硬了，但是这里需要注意，对于路径类型的关键帧动画系统是从描绘路径的位置开始路径，直到路径结束。如果上面的路径不是贝塞尔曲线而是矩形路径那么它会从矩形的左上角开始运行，顺时针一周回到左上角；如果指定的路径是一个椭圆，那么动画运行的路径是从椭圆右侧开始（0度）顺时针一周回到右侧。</p>
<p><strong>补充–其他属性</strong></p>
<p>在关键帧动画中还有一些动画属性初学者往往比较容易混淆，这里专门针对这些属性做一下介绍。</p>
<p>keyTimes：各个关键帧的时间控制。前面使用values设置了四个关键帧，默认情况下每两帧之间的间隔为:8/(4-1)秒。如果想要控制动画从第一帧到第二针占用时间4秒，从第二帧到第三帧时间为2秒，而从第三帧到第四帧时间2秒的话，就可以通过keyTimes进行设置。keyTimes中存储的是时间占用比例点，此时可以设置keyTimes的值为0.0，0.5，0.75，1.0（当然必须转换为NSNumber），也就是说1到2帧运行到总时间的50%，2到3帧运行到总时间的75%，3到4帧运行到8秒结束。</p>
<p>caculationMode：动画计算模式。还拿上面keyValues动画举例，之所以1到2帧能形成连贯性动画而不是直接从第1帧经过8/3秒到第2帧是因为动画模式是连续的（值为kCAAnimationLinear，这是计算模式的默认值）；而如果指定了动画模式为kCAAnimationDiscrete离散的那么你会看到动画从第1帧经过8/3秒直接到第2帧，中间没有任何过渡。其他动画模式还有：kCAAnimationPaced（均匀执行，会忽略keyTimes）、kCAAnimationCubic（平滑执行，对于位置变动关键帧动画运行轨迹更平滑）、kCAAnimationCubicPaced（平滑均匀执行）。</p>
<p>下图描绘出了几种动画模式的关系（横坐标是运行时间，纵坐标是动画属性[例如位置、透明度等]）：</p>
<p><img src="http://images.cnitblog.com/blog/62046/201409/150628458466039.png" alt=""></p>
<h5 id="u52A8_u753B_u7EC4"><a href="#u52A8_u753B_u7EC4" class="headerlink" title="动画组"></a>动画组</h5><p>实际开发中一个物体的运动往往是复合运动，单一属性的运动情况比较少，但恰恰属性动画每次进行动画设置时一次只能设置一个属性进行动画控制(不管是基础动画还是关键帧动画都是如此)，这样一来要做一个复合运动的动画就必须创建多个属性动画进行组合。对于一两种动画的组合或许处理起来还比较容易，但是对于更多动画的组合控制往往会变得很麻烦，动画组的产生就是基于这样一种情况而产生的。动画组是一系列动画的组合，凡是添加到动画组中的动画都受控于动画组，这样一来各类动画公共的行为就可以统一进行控制而不必单独设置，而且放到动画组中的各个动画可以并发执行，共同构建出复杂的动画效果。</p>
<p>动画组使用起来并不复杂，首先单独创建单个动画（可以是基础动画也可以是关键帧动画），然后将基础动画添加到动画组，最后将动画组添加到图层即可。</p>
<p>前面关键帧动画部分，路径动画看起来效果虽然很流畅，但是落花本身的旋转运动没有了，这里不妨将基础动画部分的旋转动画和路径关键帧动画进行组合使得整个动画看起来更加的和谐、顺畅。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  动画组</span></span><br><span class="line"><span class="comment">//  Animation</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Kenshin Cui on 14-3-22.</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#import <span class="title">"KCMainViewController.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">KCMainViewController</span> ()</span>&#123;</span><br><span class="line">    <span class="built_in">CALayer</span> *_layer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">KCMainViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置背景(注意这个图片其实在根图层)</span></span><br><span class="line">    <span class="built_in">UIImage</span> *backgroundImage=[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"background.jpg"</span>];</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.backgroundColor</span>=[<span class="built_in">UIColor</span> colorWithPatternImage:backgroundImage];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//自定义一个图层</span></span><br><span class="line">    _layer=[[<span class="built_in">CALayer</span> alloc]init];</span><br><span class="line">    _layer<span class="variable">.bounds</span>=<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    _layer<span class="variable">.position</span>=<span class="built_in">CGPointMake</span>(<span class="number">50</span>, <span class="number">150</span>);</span><br><span class="line">    _layer<span class="variable">.contents</span>=(<span class="keyword">id</span>)[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"petal.png"</span>]<span class="variable">.CGImage</span>;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.view</span><span class="variable">.layer</span> addSublayer:_layer];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建动画</span></span><br><span class="line">    [<span class="keyword">self</span> groupAnimation];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark 基础旋转动画</span></span><br><span class="line">-(<span class="built_in">CABasicAnimation</span> *)rotationAnimation&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CABasicAnimation</span> *basicAnimation=[<span class="built_in">CABasicAnimation</span> animationWithKeyPath:<span class="string">@"transform.rotation.z"</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CGFloat</span> toValue=M_PI_2*<span class="number">3</span>;</span><br><span class="line">    basicAnimation<span class="variable">.toValue</span>=[<span class="built_in">NSNumber</span> numberWithFloat:M_PI_2*<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//    basicAnimation.duration=6.0;</span></span><br><span class="line">    basicAnimation<span class="variable">.autoreverses</span>=<span class="literal">true</span>;</span><br><span class="line">    basicAnimation<span class="variable">.repeatCount</span>=HUGE_VALF;</span><br><span class="line">    basicAnimation<span class="variable">.removedOnCompletion</span>=<span class="literal">NO</span>;</span><br><span class="line">    </span><br><span class="line">    [basicAnimation setValue:[<span class="built_in">NSNumber</span> numberWithFloat:toValue] forKey:<span class="string">@"KCBasicAnimationProperty_ToValue"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> basicAnimation;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark 关键帧移动动画</span></span><br><span class="line">-(<span class="built_in">CAKeyframeAnimation</span> *)translationAnimation&#123;</span><br><span class="line">    <span class="built_in">CAKeyframeAnimation</span> *keyframeAnimation=[<span class="built_in">CAKeyframeAnimation</span> animationWithKeyPath:<span class="string">@"position"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGPoint</span> endPoint= <span class="built_in">CGPointMake</span>(<span class="number">55</span>, <span class="number">400</span>);</span><br><span class="line">    <span class="built_in">CGPathRef</span> path=<span class="built_in">CGPathCreateMutable</span>();</span><br><span class="line">    <span class="built_in">CGPathMoveToPoint</span>(path, <span class="literal">NULL</span>, _layer<span class="variable">.position</span><span class="variable">.x</span>, _layer<span class="variable">.position</span><span class="variable">.y</span>);</span><br><span class="line">    <span class="built_in">CGPathAddCurveToPoint</span>(path, <span class="literal">NULL</span>, <span class="number">160</span>, <span class="number">280</span>, -<span class="number">30</span>, <span class="number">300</span>, endPoint<span class="variable">.x</span>, endPoint<span class="variable">.y</span>);</span><br><span class="line">    </span><br><span class="line">    keyframeAnimation<span class="variable">.path</span>=path;</span><br><span class="line">    <span class="built_in">CGPathRelease</span>(path);</span><br><span class="line"></span><br><span class="line">    [keyframeAnimation setValue:[<span class="built_in">NSValue</span> valueWith<span class="built_in">CGPoint</span>:endPoint] forKey:<span class="string">@"KCKeyframeAnimationProperty_EndPosition"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> keyframeAnimation;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark 创建动画组</span></span><br><span class="line">-(<span class="keyword">void</span>)groupAnimation&#123;</span><br><span class="line">    <span class="comment">//1.创建动画组</span></span><br><span class="line">    <span class="built_in">CAAnimationGroup</span> *animationGroup=[<span class="built_in">CAAnimationGroup</span> animation];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.设置组中的动画和其他属性</span></span><br><span class="line">    <span class="built_in">CABasicAnimation</span> *basicAnimation=[<span class="keyword">self</span> rotationAnimation];</span><br><span class="line">    <span class="built_in">CAKeyframeAnimation</span> *keyframeAnimation=[<span class="keyword">self</span> translationAnimation];</span><br><span class="line">    animationGroup<span class="variable">.animations</span>=@[basicAnimation,keyframeAnimation];</span><br><span class="line">    </span><br><span class="line">    animationGroup<span class="variable">.delegate</span>=<span class="keyword">self</span>;</span><br><span class="line">    animationGroup<span class="variable">.duration</span>=<span class="number">10.0</span>;<span class="comment">//设置动画时间，如果动画组中动画已经设置过动画属性则不再生效</span></span><br><span class="line">    animationGroup<span class="variable">.beginTime</span>=<span class="built_in">CACurrentMediaTime</span>()+<span class="number">5</span>;<span class="comment">//延迟五秒执行</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.给图层添加动画</span></span><br><span class="line">    [_layer addAnimation:animationGroup forKey:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - 代理方法</span></span><br><span class="line"><span class="preprocessor">#pragma mark 动画完成</span></span><br><span class="line">-(<span class="keyword">void</span>)animationDidStop:(<span class="built_in">CAAnimation</span> *)anim finished:(<span class="built_in">BOOL</span>)flag&#123;</span><br><span class="line">    <span class="built_in">CAAnimationGroup</span> *animationGroup=(<span class="built_in">CAAnimationGroup</span> *)anim;</span><br><span class="line">    <span class="built_in">CABasicAnimation</span> *basicAnimation=animationGroup<span class="variable">.animations</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">CAKeyframeAnimation</span> *keyframeAnimation=animationGroup<span class="variable">.animations</span>[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">CGFloat</span> toValue=[[basicAnimation valueForKey:<span class="string">@"KCBasicAnimationProperty_ToValue"</span>] floatValue];</span><br><span class="line">    <span class="built_in">CGPoint</span> endPoint=[[keyframeAnimation valueForKey:<span class="string">@"KCKeyframeAnimationProperty_EndPosition"</span>] <span class="built_in">CGPointValue</span>];</span><br><span class="line">    </span><br><span class="line">    [<span class="built_in">CATransaction</span> begin];</span><br><span class="line">    [<span class="built_in">CATransaction</span> setDisableActions:<span class="literal">YES</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置动画最终状态</span></span><br><span class="line">    _layer<span class="variable">.position</span>=endPoint;</span><br><span class="line">    _layer<span class="variable">.transform</span>=<span class="built_in">CATransform3DMakeRotation</span>(toValue, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    [<span class="built_in">CATransaction</span> commit];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>运行效果：</p>
<p><img src="http://images.cnitblog.com/blog/62046/201409/150628465964410.gif" alt=""></p>
<h5 id="u8F6C_u573A_u52A8_u753B"><a href="#u8F6C_u573A_u52A8_u753B" class="headerlink" title="转场动画"></a>转场动画</h5><p>转场动画就是从一个场景以动画的形式过渡到另一个场景。转场动画的使用一般分为以下几个步骤：</p>
<p>1.创建转场动画</p>
<p>2.设置转场类型、子类型（可选）及其他属性</p>
<p>3.设置转场后的新视图并添加动画到图层</p>
<p>下表列出了常用的转场类型(注意私有API是苹果官方没有公开的动画类型，但是目前通过仍然可以使用)：</p>
<p><img src="/content/images/2015/08/15A23FE6-4053-4A5C-A64B-F715AD29D534.png" alt=""></p>
<p>另外对于支持方向设置的动画类型还包含子类型：</p>
<p><img src="/content/images/2015/08/7F9CDD25-9A6A-4185-A186-EE70AAED90C9.png" alt=""></p>
<p>这里使用转场动画利用一个UIImageView实现一个漂亮的无限循环图片浏览器</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  KCMainViewController.m</span></span><br><span class="line"><span class="comment">//  TransitionAnimation</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Kenshin Cui on 14-3-12.</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#import <span class="title">"KCMainViewController.h"</span></span></span><br><span class="line"><span class="preprocessor">#define IMAGE_COUNT 5</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">KCMainViewController</span> ()</span>&#123;</span><br><span class="line">    <span class="built_in">UIImageView</span> *_imageView;</span><br><span class="line">    <span class="keyword">int</span> _currentIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">KCMainViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义图片控件</span></span><br><span class="line">    _imageView=[[<span class="built_in">UIImageView</span> alloc]init];</span><br><span class="line">    _imageView<span class="variable">.frame</span>=[<span class="built_in">UIScreen</span> mainScreen]<span class="variable">.applicationFrame</span>;</span><br><span class="line">    _imageView<span class="variable">.contentMode</span>=<span class="built_in">UIViewContentModeScaleAspectFit</span>;</span><br><span class="line">    _imageView<span class="variable">.image</span>=[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"0.jpg"</span>];<span class="comment">//默认图片</span></span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.view</span> addSubview:_imageView];</span><br><span class="line">    <span class="comment">//添加手势</span></span><br><span class="line">    <span class="built_in">UISwipeGestureRecognizer</span> *leftSwipeGesture=[[<span class="built_in">UISwipeGestureRecognizer</span> alloc]initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(leftSwipe:)];</span><br><span class="line">    leftSwipeGesture<span class="variable">.direction</span>=<span class="built_in">UISwipeGestureRecognizerDirectionLeft</span>;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.view</span> addGestureRecognizer:leftSwipeGesture];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UISwipeGestureRecognizer</span> *rightSwipeGesture=[[<span class="built_in">UISwipeGestureRecognizer</span> alloc]initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(rightSwipe:)];</span><br><span class="line">    rightSwipeGesture<span class="variable">.direction</span>=<span class="built_in">UISwipeGestureRecognizerDirectionRight</span>;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.view</span> addGestureRecognizer:rightSwipeGesture];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark 向左滑动浏览下一张图片</span></span><br><span class="line">-(<span class="keyword">void</span>)leftSwipe:(<span class="built_in">UISwipeGestureRecognizer</span> *)gesture&#123;</span><br><span class="line">    [<span class="keyword">self</span> transitionAnimation:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark 向右滑动浏览上一张图片</span></span><br><span class="line">-(<span class="keyword">void</span>)rightSwipe:(<span class="built_in">UISwipeGestureRecognizer</span> *)gesture&#123;</span><br><span class="line">    [<span class="keyword">self</span> transitionAnimation:<span class="literal">NO</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark 转场动画</span></span><br><span class="line">-(<span class="keyword">void</span>)transitionAnimation:(<span class="built_in">BOOL</span>)isNext&#123;</span><br><span class="line">    <span class="comment">//1.创建转场动画对象</span></span><br><span class="line">    <span class="built_in">CATransition</span> *transition=[[<span class="built_in">CATransition</span> alloc]init];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.设置动画类型,注意对于苹果官方没公开的动画类型只能使用字符串，并没有对应的常量定义</span></span><br><span class="line">    transition<span class="variable">.type</span>=<span class="string">@"cube"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置子类型</span></span><br><span class="line">    <span class="keyword">if</span> (isNext) &#123;</span><br><span class="line">        transition<span class="variable">.subtype</span>=k<span class="built_in">CATransitionFromRight</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        transition<span class="variable">.subtype</span>=k<span class="built_in">CATransitionFromLeft</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置动画时常</span></span><br><span class="line">    transition<span class="variable">.duration</span>=<span class="number">1.0</span>f;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.设置转场后的新视图添加转场动画</span></span><br><span class="line">    _imageView<span class="variable">.image</span>=[<span class="keyword">self</span> getImage:isNext];</span><br><span class="line">    [_imageView<span class="variable">.layer</span> addAnimation:transition forKey:<span class="string">@"KCTransitionAnimation"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark 取得当前图片</span></span><br><span class="line">-(<span class="built_in">UIImage</span> *)getImage:(<span class="built_in">BOOL</span>)isNext&#123;</span><br><span class="line">    <span class="keyword">if</span> (isNext) &#123;</span><br><span class="line">        _currentIndex=(_currentIndex+<span class="number">1</span>)%IMAGE_COUNT;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        _currentIndex=(_currentIndex-<span class="number">1</span>+IMAGE_COUNT)%IMAGE_COUNT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSString</span> *imageName=[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%i.jpg"</span>,_currentIndex];</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">UIImage</span> imageNamed:imageName];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>运行效果：</p>
<p><img src="http://images.cnitblog.com/blog/62046/201409/150628587684058.gif" alt=""></p>
<p>代码十分简单，但是效果和性能却很惊人。当然演示代码有限，其他动画类型大家可以自己实现，效果都很绚丽。</p>
<h5 id="u9010_u5E27_u52A8_u753B"><a href="#u9010_u5E27_u52A8_u753B" class="headerlink" title="逐帧动画"></a>逐帧动画</h5><p>前面介绍了核心动画中大部分动画类型，但是做过动画处理的朋友都知道，在动画制作中还有一种动画类型“逐帧动画”。说到逐帧动画相信很多朋友第一个想到的就是UIImageView，通过设置UIImageView的animationImages属性，然后调用它的startAnimating方法去播放这组图片。当然这种方法在某些场景下是可以达到逐帧的动画效果，但是它也存在着很大的性能问题，并且这种方法一旦设置完图片中间的过程就无法控制了。当然，也许有朋友会想到利用iOS的定时器NSTimer定时更新图片来达到逐帧动画的效果。这种方式确实可以解决UIImageView一次性加载大量图片的问题，而且让播放过程可控，唯一的缺点就是定时器方法调用有时可能会因为当前系统执行某种比较占用时间的任务造成动画连续性出现问题。</p>
<p>虽然在核心动画没有直接提供逐帧动画类型，但是却提供了用于完成逐帧动画的相关对象CADisplayLink。CADisplayLink是一个计时器，但是同NSTimer不同的是，CADisplayLink的刷新周期同屏幕完全一致。例如在iOS中屏幕刷新周期是60次/秒，CADisplayLink刷新周期同屏幕刷新一致也是60次/秒，这样一来使用它完成的逐帧动画（又称为“时钟动画”）完全感觉不到动画的停滞情况。</p>
<p>在iOS开篇“IOS开发系列–IOS程序开发概览”中就曾说过：iOS程序在运行后就进入一个消息循环中（这个消息循环称为“主运行循环”），整个程序相当于进入一个死循环中，始终等待用户输入。将CADisplayLink加入到主运行循环队列后，它的时钟周期就和主运行循环保持一致，而主运行循环周期就是屏幕刷新周期。在CADisplayLink加入到主运行循环队列后就会循环调用目标方法，在这个方法中更新视图内容就可以完成逐帧动画。</p>
<p>当然这里不得不强调的是逐帧动画性能势必较低，但是对于一些事物的运动又不得不选择使用逐帧动画，例如人的运动，这是一个高度复杂的运动，基本动画、关键帧动画是不可能解决的。所大家一定要注意在循环方法中尽可能的降低算法复杂度，同时保证循环过程中内存峰值尽可能低。下面以一个鱼的运动为例为大家演示一下逐帧动画。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  KCMainViewController.m</span></span><br><span class="line"><span class="comment">//  DisplayLink</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Kenshin Cui on 14-3-22.</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#import <span class="title">"KCMainViewController.h"</span></span></span><br><span class="line"><span class="preprocessor">#define IMAGE_COUNT 10</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">KCMainViewController</span> ()</span>&#123;</span><br><span class="line">    <span class="built_in">CALayer</span> *_layer;</span><br><span class="line">    <span class="keyword">int</span> _index;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *_images;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">KCMainViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置背景</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.layer</span><span class="variable">.contents</span>=(<span class="keyword">id</span>)[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"bg.png"</span>]<span class="variable">.CGImage</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建图像显示图层</span></span><br><span class="line">    _layer=[[<span class="built_in">CALayer</span> alloc]init];</span><br><span class="line">    _layer<span class="variable">.bounds</span>=<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">87</span>, <span class="number">32</span>);</span><br><span class="line">    _layer<span class="variable">.position</span>=<span class="built_in">CGPointMake</span>(<span class="number">160</span>, <span class="number">284</span>);</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.view</span><span class="variable">.layer</span> addSublayer:_layer];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//由于鱼的图片在循环中会不断创建，而10张鱼的照片相对都很小</span></span><br><span class="line">    <span class="comment">//与其在循环中不断创建UIImage不如直接将10张图片缓存起来</span></span><br><span class="line">    _images=[<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *imageName=[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"fish%i.png"</span>,i];</span><br><span class="line">        <span class="built_in">UIImage</span> *image=[<span class="built_in">UIImage</span> imageNamed:imageName];</span><br><span class="line">        [_images addObject:image];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义时钟对象</span></span><br><span class="line">    <span class="built_in">CADisplayLink</span> *displayLink=[<span class="built_in">CADisplayLink</span> displayLinkWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(step)];</span><br><span class="line">    <span class="comment">//添加时钟对象到主运行循环</span></span><br><span class="line">    [displayLink addToRunLoop:[<span class="built_in">NSRunLoop</span> mainRunLoop] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark 每次屏幕刷新就会执行一次此方法(每秒接近60次)</span></span><br><span class="line">-(<span class="keyword">void</span>)step&#123;</span><br><span class="line">    <span class="comment">//定义一个变量记录执行次数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> s=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//每秒执行6次</span></span><br><span class="line">    <span class="keyword">if</span> (++s%<span class="number">10</span>==<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">UIImage</span> *image=_images[_index];</span><br><span class="line">        _layer<span class="variable">.contents</span>=(<span class="keyword">id</span>)image<span class="variable">.CGImage</span>;<span class="comment">//更新图片</span></span><br><span class="line">        _index=(_index+<span class="number">1</span>)%IMAGE_COUNT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>运行效果：</p>
<p><img src="http://images.cnitblog.com/blog/62046/201409/150629077379751.gif" alt=""></p>
<p>注意：上面仅仅演示了逐帧动画的过程，事实上结合其他动画类型可以让整条鱼游动起来，这里不再赘述。</p>
<hr>
<h4 id="UIView_u52A8_u753B_u5C01_u88C5"><a href="#UIView_u52A8_u753B_u5C01_u88C5" class="headerlink" title="UIView动画封装"></a>UIView动画封装</h4><p>有了前面核心动画的知识，相信大家开发出一般的动画效果应该不在话下。在核心动画开篇也给大家说过，其实UIView本身对于基本动画和关键帧动画、转场动画都有相应的封装，在对动画细节没有特殊要求的情况下使用起来也要简单的多。可以说在日常开发中90%以上的情况使用UIView的动画封装方法都可以搞定，因此在熟悉了核心动画的原理之后还是有必要给大家简单介绍一下UIView中各类动画使用方法的。由于前面核心动画内容已经进行过详细介绍，学习UIView的封装方法根本是小菜一碟，这里对于一些细节就不再赘述了。</p>
<h5 id="u57FA_u7840_u52A8_u753B-1"><a href="#u57FA_u7840_u52A8_u753B-1" class="headerlink" title="基础动画"></a>基础动画</h5><p>基础动画部分和前面的基础动画演示相对应，演示点击屏幕落叶飘落到鼠标点击位置的过程。注意根据前面介绍的隐式动画知识其实非根图层直接设置终点位置不需要使用UIView的动画方法也可以实现动画效果，因此这里落花不再放到图层中而是放到了一个UIImageView中。</p>
<p>下面的代码演示了通过block和静态方法实现动画控制的过程：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  UIView实现基础动画</span></span><br><span class="line"><span class="comment">//  Animation</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Kenshin Cui on 14-3-22.</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#import <span class="title">"KCMainViewController.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">KCMainViewController</span> ()</span>&#123;</span><br><span class="line">    <span class="built_in">UIImageView</span> *_imageView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">KCMainViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置背景</span></span><br><span class="line">    <span class="built_in">UIImage</span> *backgroundImage=[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"background.jpg"</span>];</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.backgroundColor</span>=[<span class="built_in">UIColor</span> colorWithPatternImage:backgroundImage];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建图像显示控件</span></span><br><span class="line">    _imageView=[[<span class="built_in">UIImageView</span> alloc]initWithImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"petal.png"</span>]];</span><br><span class="line">    _imageView<span class="variable">.center</span>=<span class="built_in">CGPointMake</span>(<span class="number">50</span>, <span class="number">150</span>);</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.view</span> addSubview:_imageView];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark 点击事件</span></span><br><span class="line">-(<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</span><br><span class="line">    <span class="built_in">UITouch</span> *touch=touches<span class="variable">.anyObject</span>;</span><br><span class="line">    <span class="built_in">CGPoint</span> location= [touch locationInView:<span class="keyword">self</span><span class="variable">.view</span>];</span><br><span class="line">    <span class="comment">//方法1：block方式</span></span><br><span class="line">    <span class="comment">/*开始动画，UIView的动画方法执行完后动画会停留在重点位置，而不需要进行任何特殊处理</span><br><span class="line">     duration:执行时间</span><br><span class="line">     delay:延迟时间</span><br><span class="line">     options:动画设置，例如自动恢复、匀速运动等</span><br><span class="line">     completion:动画完成回调方法</span><br><span class="line">     */</span></span><br><span class="line"><span class="comment">//    [UIView animateWithDuration:5.0 delay:0 options:UIViewAnimationOptionCurveLinear animations:^&#123;</span></span><br><span class="line"><span class="comment">//        _imageView.center=location;</span></span><br><span class="line"><span class="comment">//    &#125; completion:^(BOOL finished) &#123;</span></span><br><span class="line"><span class="comment">//        NSLog(@"Animation end.");</span></span><br><span class="line"><span class="comment">//    &#125;];</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方法2：静态方法</span></span><br><span class="line">    <span class="comment">//开始动画</span></span><br><span class="line">    [<span class="built_in">UIView</span> beginAnimations:<span class="string">@"KCBasicAnimation"</span> context:<span class="literal">nil</span>];</span><br><span class="line">    [<span class="built_in">UIView</span> setAnimationDuration:<span class="number">5.0</span>];</span><br><span class="line">    <span class="comment">//[UIView setAnimationDelay:1.0];//设置延迟</span></span><br><span class="line">    <span class="comment">//[UIView setAnimationRepeatAutoreverses:NO];//是否回复</span></span><br><span class="line">    <span class="comment">//[UIView setAnimationRepeatCount:10];//重复次数</span></span><br><span class="line">    <span class="comment">//[UIView setAnimationStartDate:(NSDate *)];//设置动画开始运行的时间</span></span><br><span class="line">    <span class="comment">//[UIView setAnimationDelegate:self];//设置代理</span></span><br><span class="line">    <span class="comment">//[UIView setAnimationWillStartSelector:(SEL)];//设置动画开始运动的执行方法</span></span><br><span class="line">    <span class="comment">//[UIView setAnimationDidStopSelector:(SEL)];//设置动画运行结束后的执行方法</span></span><br><span class="line">    </span><br><span class="line">    _imageView<span class="variable">.center</span>=location;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//开始动画</span></span><br><span class="line">    [<span class="built_in">UIView</span> commitAnimations];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p><strong>补充–弹簧动画效果</strong></p>
<p>由于在iOS开发中弹性动画使用很普遍，所以在iOS7苹果官方直接提供了一个方法用于弹性动画开发，下面简单的演示一下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  UIView实现基础动画--弹性动画</span></span><br><span class="line"><span class="comment">//  Animation</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Kenshin Cui on 14-3-22.</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#import <span class="title">"KCMainViewController.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">KCMainViewController</span> ()</span>&#123;</span><br><span class="line">    <span class="built_in">UIImageView</span> *_imageView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">KCMainViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建图像显示控件</span></span><br><span class="line">    _imageView=[[<span class="built_in">UIImageView</span> alloc]initWithImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"ball.png"</span>]];</span><br><span class="line">    _imageView<span class="variable">.center</span>=<span class="built_in">CGPointMake</span>(<span class="number">160</span>, <span class="number">50</span>);</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.view</span> addSubview:_imageView];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark 点击事件</span></span><br><span class="line">-(<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</span><br><span class="line">    <span class="built_in">UITouch</span> *touch=touches<span class="variable">.anyObject</span>;</span><br><span class="line">    <span class="built_in">CGPoint</span> location= [touch locationInView:<span class="keyword">self</span><span class="variable">.view</span>];</span><br><span class="line">    <span class="comment">/*创建弹性动画</span><br><span class="line">     damping:阻尼，范围0-1，阻尼越接近于0，弹性效果越明显</span><br><span class="line">     velocity:弹性复位的速度</span><br><span class="line">    */</span></span><br><span class="line">    [<span class="built_in">UIView</span> animateWithDuration:<span class="number">5.0</span> delay:<span class="number">0</span> usingSpringWithDamping:<span class="number">0.1</span> initialSpringVelocity:<span class="number">1.0</span> options:<span class="built_in">UIViewAnimationOptionCurveLinear</span> animations:^&#123;</span><br><span class="line">        _imageView<span class="variable">.center</span>=location; <span class="comment">//CGPointMake(160, 284);</span></span><br><span class="line">    &#125; completion:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>运行效果：</p>
<p><img src="http://images.cnitblog.com/blog/62046/201409/150629086121851.gif" alt=""></p>
<p><strong>补充–动画设置参数</strong></p>
<p>在动画方法中有一个option参数，UIViewAnimationOptions类型，它是一个枚举类型，动画参数分为三类，可以组合使用：</p>
<p>1.常规动画属性设置（可以同时选择多个进行设置）</p>
<p>UIViewAnimationOptionLayoutSubviews：动画过程中保证子视图跟随运动。</p>
<p>UIViewAnimationOptionAllowUserInteraction：动画过程中允许用户交互。</p>
<p>UIViewAnimationOptionBeginFromCurrentState：所有视图从当前状态开始运行。</p>
<p>UIViewAnimationOptionRepeat：重复运行动画。</p>
<p>UIViewAnimationOptionAutoreverse ：动画运行到结束点后仍然以动画方式回到初始点。</p>
<p>UIViewAnimationOptionOverrideInheritedDuration：忽略嵌套动画时间设置。</p>
<p>UIViewAnimationOptionOverrideInheritedCurve：忽略嵌套动画速度设置。</p>
<p>UIViewAnimationOptionAllowAnimatedContent：动画过程中重绘视图（注意仅仅适用于转场动画）。 </p>
<p>UIViewAnimationOptionShowHideTransitionViews：视图切换时直接隐藏旧视图、显示新视图，而不是将旧视图从父视图移除（仅仅适用于转场动画）<br>UIViewAnimationOptionOverrideInheritedOptions ：不继承父动画设置或动画类型。</p>
<p>2.动画速度控制（可从其中选择一个设置）</p>
<p>UIViewAnimationOptionCurveEaseInOut：动画先缓慢，然后逐渐加速。</p>
<p>UIViewAnimationOptionCurveEaseIn ：动画逐渐变慢。</p>
<p>UIViewAnimationOptionCurveEaseOut：动画逐渐加速。</p>
<p>UIViewAnimationOptionCurveLinear ：动画匀速执行，默认值。</p>
<p>3.转场类型（仅适用于转场动画设置，可以从中选择一个进行设置，基本动画、关键帧动画不需要设置）</p>
<p>UIViewAnimationOptionTransitionNone：没有转场动画效果。</p>
<p>UIViewAnimationOptionTransitionFlipFromLeft ：从左侧翻转效果。</p>
<p>UIViewAnimationOptionTransitionFlipFromRight：从右侧翻转效果。</p>
<p>UIViewAnimationOptionTransitionCurlUp：向后翻页的动画过渡效果。   </p>
<p>UIViewAnimationOptionTransitionCurlDown ：向前翻页的动画过渡效果。   </p>
<p>UIViewAnimationOptionTransitionCrossDissolve：旧视图溶解消失显示下一个新视图的效果。   </p>
<p>UIViewAnimationOptionTransitionFlipFromTop ：从上方翻转效果。   </p>
<p>UIViewAnimationOptionTransitionFlipFromBottom：从底部翻转效果。</p>
<h5 id="u5173_u952E_u5E27_u52A8_u753B-1"><a href="#u5173_u952E_u5E27_u52A8_u753B-1" class="headerlink" title="关键帧动画"></a>关键帧动画</h5><p>从iOS7开始UIView动画中封装了关键帧动画，下面就来看一下如何使用UIView封装方法进行关键帧动画控制，这里实现前面关键帧动画部分对于落花的控制。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  UIView关键帧动画</span></span><br><span class="line"><span class="comment">//  UIViewAnimation</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Kenshin Cui on 14-3-22.</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#import <span class="title">"KCMainViewController.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">KCMainViewController</span> ()</span>&#123;</span><br><span class="line">    <span class="built_in">UIImageView</span> *_imageView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">KCMainViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置背景</span></span><br><span class="line">    <span class="built_in">UIImage</span> *backgroundImage=[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"background.jpg"</span>];</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.backgroundColor</span>=[<span class="built_in">UIColor</span> colorWithPatternImage:backgroundImage];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建图像显示控件</span></span><br><span class="line">    _imageView=[[<span class="built_in">UIImageView</span> alloc]initWithImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"petal.png"</span>]];</span><br><span class="line">    _imageView<span class="variable">.center</span>=<span class="built_in">CGPointMake</span>(<span class="number">50</span>, <span class="number">150</span>);</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.view</span> addSubview:_imageView];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</span><br><span class="line">    <span class="comment">//UITouch *touch=touches.anyObject;</span></span><br><span class="line">    <span class="comment">//CGPoint location= [touch locationInView:self.view];</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*关键帧动画</span><br><span class="line">     options:</span><br><span class="line">     */</span></span><br><span class="line">    [<span class="built_in">UIView</span> animateKeyframesWithDuration:<span class="number">5.0</span> delay:<span class="number">0</span> options: <span class="built_in">UIViewAnimationOptionCurveLinear</span>| <span class="built_in">UIViewAnimationOptionCurveLinear</span> animations:^&#123;</span><br><span class="line">        <span class="comment">//第二个关键帧（准确的说第一个关键帧是开始位置）:从0秒开始持续50%的时间，也就是5.0*0.5=2.5秒</span></span><br><span class="line">        [<span class="built_in">UIView</span> addKeyframeWithRelativeStartTime:<span class="number">0.0</span> relativeDuration:<span class="number">0.5</span> animations:^&#123;</span><br><span class="line">            _imageView<span class="variable">.center</span>=<span class="built_in">CGPointMake</span>(<span class="number">80.0</span>, <span class="number">220.0</span>);</span><br><span class="line">        &#125;];</span><br><span class="line">        <span class="comment">//第三个关键帧，从0.5*5.0秒开始，持续5.0*0.25=1.25秒</span></span><br><span class="line">        [<span class="built_in">UIView</span> addKeyframeWithRelativeStartTime:<span class="number">0.5</span> relativeDuration:<span class="number">0.25</span> animations:^&#123;</span><br><span class="line">            _imageView<span class="variable">.center</span>=<span class="built_in">CGPointMake</span>(<span class="number">45.0</span>, <span class="number">300.0</span>);</span><br><span class="line">        &#125;];</span><br><span class="line">        <span class="comment">//第四个关键帧：从0.75*5.0秒开始，持所需5.0*0.25=1.25秒</span></span><br><span class="line">        [<span class="built_in">UIView</span> addKeyframeWithRelativeStartTime:<span class="number">0.75</span> relativeDuration:<span class="number">0.25</span> animations:^&#123;</span><br><span class="line">            _imageView<span class="variable">.center</span>=<span class="built_in">CGPointMake</span>(<span class="number">55.0</span>, <span class="number">400.0</span>);</span><br><span class="line">        &#125;];</span><br><span class="line">        </span><br><span class="line">    &#125; completion:^(<span class="built_in">BOOL</span> finished) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Animation end."</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h5 id="u8865_u5145_u2013_u52A8_u753B_u8BBE_u7F6E_u53C2_u6570"><a href="#u8865_u5145_u2013_u52A8_u753B_u8BBE_u7F6E_u53C2_u6570" class="headerlink" title="补充–动画设置参数"></a>补充–动画设置参数</h5><p>对于关键帧动画也有一些动画参数设置options，UIViewKeyframeAnimationOptions类型，和上面基本动画参数设置有些差别，关键帧动画设置参数分为两类，可以组合使用：</p>
<p>1.常规动画属性设置（可以同时选择多个进行设置）</p>
<p>UIViewAnimationOptionLayoutSubviews：动画过程中保证子视图跟随运动。</p>
<p>UIViewAnimationOptionAllowUserInteraction：动画过程中允许用户交互。</p>
<p>UIViewAnimationOptionBeginFromCurrentState：所有视图从当前状态开始运行。</p>
<p>UIViewAnimationOptionRepeat：重复运行动画。</p>
<p>UIViewAnimationOptionAutoreverse ：动画运行到结束点后仍然以动画方式回到初始点。</p>
<p>UIViewAnimationOptionOverrideInheritedDuration：忽略嵌套动画时间设置。<br>UIViewAnimationOptionOverrideInheritedOptions ：不继承父动画设置或动画类型。</p>
<p>2.动画模式设置（同前面关键帧动画动画模式一一对应，可以从其中选择一个进行设置）</p>
<p>UIViewKeyframeAnimationOptionCalculationModeLinear：连续运算模式。</p>
<p>UIViewKeyframeAnimationOptionCalculationModeDiscrete ：离散运算模式。</p>
<p>UIViewKeyframeAnimationOptionCalculationModePaced：均匀执行运算模式。</p>
<p>UIViewKeyframeAnimationOptionCalculationModeCubic：平滑运算模式。</p>
<p>UIViewKeyframeAnimationOptionCalculationModeCubicPaced：平滑均匀运算模式。</p>
<p>注意：前面说过关键帧动画有两种形式，上面演示的是属性值关键帧动画，路径关键帧动画目前UIView还不支持。</p>
<h5 id="u8F6C_u573A_u52A8_u753B-1"><a href="#u8F6C_u573A_u52A8_u753B-1" class="headerlink" title="转场动画"></a>转场动画</h5><p>从iOS4.0开始，UIView直接封装了转场动画，使用起来同样很简单。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  UIView转场动画</span></span><br><span class="line"><span class="comment">//  TransitionAnimation</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Kenshin Cui on 14-3-12.</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#import <span class="title">"KCMainViewController.h"</span></span></span><br><span class="line"><span class="preprocessor">#define IMAGE_COUNT 5</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">KCMainViewController</span> ()</span>&#123;</span><br><span class="line">    <span class="built_in">UIImageView</span> *_imageView;</span><br><span class="line">    <span class="keyword">int</span> _currentIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">KCMainViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义图片控件</span></span><br><span class="line">    _imageView=[[<span class="built_in">UIImageView</span> alloc]init];</span><br><span class="line">    _imageView<span class="variable">.frame</span>=[<span class="built_in">UIScreen</span> mainScreen]<span class="variable">.applicationFrame</span>;</span><br><span class="line">    _imageView<span class="variable">.contentMode</span>=<span class="built_in">UIViewContentModeScaleAspectFit</span>;</span><br><span class="line">    _imageView<span class="variable">.image</span>=[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"0.jpg"</span>];<span class="comment">//默认图片</span></span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.view</span> addSubview:_imageView];</span><br><span class="line">    <span class="comment">//添加手势</span></span><br><span class="line">    <span class="built_in">UISwipeGestureRecognizer</span> *leftSwipeGesture=[[<span class="built_in">UISwipeGestureRecognizer</span> alloc]initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(leftSwipe:)];</span><br><span class="line">    leftSwipeGesture<span class="variable">.direction</span>=<span class="built_in">UISwipeGestureRecognizerDirectionLeft</span>;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.view</span> addGestureRecognizer:leftSwipeGesture];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UISwipeGestureRecognizer</span> *rightSwipeGesture=[[<span class="built_in">UISwipeGestureRecognizer</span> alloc]initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(rightSwipe:)];</span><br><span class="line">    rightSwipeGesture<span class="variable">.direction</span>=<span class="built_in">UISwipeGestureRecognizerDirectionRight</span>;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.view</span> addGestureRecognizer:rightSwipeGesture];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark 向左滑动浏览下一张图片</span></span><br><span class="line">-(<span class="keyword">void</span>)leftSwipe:(<span class="built_in">UISwipeGestureRecognizer</span> *)gesture&#123;</span><br><span class="line">    [<span class="keyword">self</span> transitionAnimation:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark 向右滑动浏览上一张图片</span></span><br><span class="line">-(<span class="keyword">void</span>)rightSwipe:(<span class="built_in">UISwipeGestureRecognizer</span> *)gesture&#123;</span><br><span class="line">    [<span class="keyword">self</span> transitionAnimation:<span class="literal">NO</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark 转场动画</span></span><br><span class="line">-(<span class="keyword">void</span>)transitionAnimation:(<span class="built_in">BOOL</span>)isNext&#123;</span><br><span class="line">    <span class="built_in">UIViewAnimationOptions</span> option;</span><br><span class="line">    <span class="keyword">if</span> (isNext) &#123;</span><br><span class="line">        option=<span class="built_in">UIViewAnimationOptionCurveLinear</span>|<span class="built_in">UIViewAnimationOptionTransitionFlipFromRight</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        option=<span class="built_in">UIViewAnimationOptionCurveLinear</span>|<span class="built_in">UIViewAnimationOptionTransitionFlipFromLeft</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [<span class="built_in">UIView</span> transitionWithView:_imageView duration:<span class="number">1.0</span> options:option animations:^&#123;</span><br><span class="line">        _imageView<span class="variable">.image</span>=[<span class="keyword">self</span> getImage:isNext];</span><br><span class="line">    &#125; completion:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark 取得当前图片</span></span><br><span class="line">-(<span class="built_in">UIImage</span> *)getImage:(<span class="built_in">BOOL</span>)isNext&#123;</span><br><span class="line">    <span class="keyword">if</span> (isNext) &#123;</span><br><span class="line">        _currentIndex=(_currentIndex+<span class="number">1</span>)%IMAGE_COUNT;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        _currentIndex=(_currentIndex-<span class="number">1</span>+IMAGE_COUNT)%IMAGE_COUNT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSString</span> *imageName=[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%i.jpg"</span>,_currentIndex];</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">UIImage</span> imageNamed:imageName];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>上面的转场动画演示中，其实仅仅有一个视图UIImageView做转场动画，每次转场通过切换UIImageView的内容而已。如果有两个完全不同的视图，并且每个视图布局都很复杂，此时要在这两个视图之间进行转场可以使用<strong>+ (void)transitionFromView:(UIView <em>)fromView toView:(UIView </em>)toView duration:(NSTimeInterval)duration options:(UIViewAnimationOptions)options completion:(void (^)(BOOL finished))completion NS_AVAILABLE_IOS(4_0)</strong>方法进行两个视图间的转场，需要注意的是默认情况下转出的视图会从父视图移除，转入后重新添加，可以通过<strong>UIViewAnimationOptionShowHideTransitionViews</strong>参数设置，设置此参数后转出的视图会隐藏（不会移除）转入后再显示。</p>
<p>注意：转场动画设置参数完全同基本动画参数设置；同直接使用转场动画不同的是使用UIView的装饰方法进行转场动画其动画效果较少，因为这里无法直接使用私有API。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u6982_u89C8"><a href="#u6982_u89C8" class="headerlink" title="概览"></a>概览</h2><p>在iOS中随处都可以看到绚丽的动画效果，实现这些动画的过程并不复杂，今天将带大家一窥iOS动画全貌。在这里你可以看到iOS中如何使用图层精简非交互式绘图，如何通过核心动画创建基础动画、关键帧动画、动画组、转场动画，如何通过UIView的装饰方法对这些动画操作进行简化等。在今天的文章里您可以看到动画操作在iOS中是如何简单和高效，很多原来想做但是苦于没有思路的动画在iOS中将变得越发简单：</p>]]>
    
    </summary>
    
      <category term="Animation" scheme="http://yimouleng.com/tags/Animation/"/>
    
      <category term="CALayer" scheme="http://yimouleng.com/tags/CALayer/"/>
    
      <category term="动画" scheme="http://yimouleng.com/tags/%E5%8A%A8%E7%94%BB/"/>
    
      <category term="iOS开发" scheme="http://yimouleng.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS 多线程编程 GCD]]></title>
    <link href="http://yimouleng.com/2014/11/16/iso-duoxiancheng-GCD/"/>
    <id>http://yimouleng.com/2014/11/16/iso-duoxiancheng-GCD/</id>
    <published>2014-11-16T14:28:00.000Z</published>
    <updated>2015-12-09T08:51:49.000Z</updated>
    <content type="html"><![CDATA[<p>GCD，全名是 Grand Central Dispatch ，通常是 create 一个 <code>dispatch_queue_t</code> 队列，然后把任务放到队列中，队列分为 <code>dispatch_async</code> （异步队列）和 <code>dispatch_sync</code> （同步队列）。</p>
<a id="more"></a>
<blockquote>
<ul>
<li>串行队列</li>
<li>并行队列</li>
<li>全局队列</li>
<li>主线程队列</li>
<li>实际操作一（网络下载图片）</li>
<li>实际操作二（iOS 推送并发执行）</li>
</ul>
</blockquote>
<h4 id="u7B80_u5355_u5730_u7406_u89E3"><a href="#u7B80_u5355_u5730_u7406_u89E3" class="headerlink" title="简单地理解"></a>简单地理解</h4><blockquote>
<ul>
<li>GCD 的基本思想是就将操作放在队列中去执行</li>
<li>操作使用 Block 定义</li>
<li>队列负责调度任务执行所在的线程以及具体的执行时间</li>
<li>队列的特点是先进先出（FIFO）的，新添加至对列的操作都会排在队尾</li>
<li>GCD 的函数都是以 dispatch 开头的</li>
</ul>
</blockquote>
<h4 id="u4E32_u884C_u961F_u5217"><a href="#u4E32_u884C_u961F_u5217" class="headerlink" title="串行队列"></a>串行队列</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)gcdDemo1 &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 串行队列</span></span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> q = dispatch_queue_create(<span class="string">"com.pupboss.gcddemo1"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 串行行队列的同步任务，同样会在主线程上运行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="comment">// 同步任务顺序执行</span></span><br><span class="line">        dispatch_sync(q, ^&#123;</span><br><span class="line">            NSLog(@<span class="string">"%@ %d"</span>, [NSThread currentThread], i);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="comment">// 异步任务，并发执行，但是如果在串行队列中，仍然会依次顺序执行</span></span><br><span class="line">        dispatch_async(q, ^&#123;</span><br><span class="line">            <span class="comment">// [NSThread currentThread] 可以在开发中，跟踪当前线程</span></span><br><span class="line">            <span class="comment">// num = 1，表示主线程</span></span><br><span class="line">            <span class="comment">// num = 2，表示第2个子线程。。。</span></span><br><span class="line">            NSLog(@<span class="string">"%@ %d"</span>, [NSThread currentThread], i);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2015</span>-<span class="number">05</span>-<span class="number">23</span> <span class="number">22</span>:<span class="number">03</span>:<span class="number">17.990</span> Multi-Thread-Test[<span class="number">4502</span>:<span class="number">211585</span>] &lt;NSThread: <span class="number">0x7feeb3f289d0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125; <span class="number">0</span>  </span><br><span class="line"><span class="number">2015</span>-<span class="number">05</span>-<span class="number">23</span> <span class="number">22</span>:<span class="number">03</span>:<span class="number">17.990</span> Multi-Thread-Test[<span class="number">4502</span>:<span class="number">211585</span>] &lt;NSThread: <span class="number">0x7feeb3f289d0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125; <span class="number">1</span>  </span><br><span class="line"><span class="number">2015</span>-<span class="number">05</span>-<span class="number">23</span> <span class="number">22</span>:<span class="number">03</span>:<span class="number">17.991</span> Multi-Thread-Test[<span class="number">4502</span>:<span class="number">211585</span>] &lt;NSThread: <span class="number">0x7feeb3f289d0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125; <span class="number">2</span>  </span><br><span class="line"><span class="number">2015</span>-<span class="number">05</span>-<span class="number">23</span> <span class="number">22</span>:<span class="number">03</span>:<span class="number">17.991</span> Multi-Thread-Test[<span class="number">4502</span>:<span class="number">211585</span>] &lt;NSThread: <span class="number">0x7feeb3f289d0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125; <span class="number">3</span>  </span><br><span class="line"><span class="number">2015</span>-<span class="number">05</span>-<span class="number">23</span> <span class="number">22</span>:<span class="number">03</span>:<span class="number">17.991</span> Multi-Thread-Test[<span class="number">4502</span>:<span class="number">211585</span>] &lt;NSThread: <span class="number">0x7feeb3f289d0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125; <span class="number">4</span>  </span><br><span class="line"><span class="number">2015</span>-<span class="number">05</span>-<span class="number">23</span> <span class="number">22</span>:<span class="number">03</span>:<span class="number">17.991</span> Multi-Thread-Test[<span class="number">4502</span>:<span class="number">211685</span>] &lt;NSThread: <span class="number">0x7feeb506dc70</span>&gt;&#123;number = <span class="number">2</span>, name = (null)&#125; <span class="number">0</span>  </span><br><span class="line"><span class="number">2015</span>-<span class="number">05</span>-<span class="number">23</span> <span class="number">22</span>:<span class="number">03</span>:<span class="number">17.991</span> Multi-Thread-Test[<span class="number">4502</span>:<span class="number">211685</span>] &lt;NSThread: <span class="number">0x7feeb506dc70</span>&gt;&#123;number = <span class="number">2</span>, name = (null)&#125; <span class="number">1</span>  </span><br><span class="line"><span class="number">2015</span>-<span class="number">05</span>-<span class="number">23</span> <span class="number">22</span>:<span class="number">03</span>:<span class="number">17.991</span> Multi-Thread-Test[<span class="number">4502</span>:<span class="number">211685</span>] &lt;NSThread: <span class="number">0x7feeb506dc70</span>&gt;&#123;number = <span class="number">2</span>, name = (null)&#125; <span class="number">2</span>  </span><br><span class="line"><span class="number">2015</span>-<span class="number">05</span>-<span class="number">23</span> <span class="number">22</span>:<span class="number">03</span>:<span class="number">17.991</span> Multi-Thread-Test[<span class="number">4502</span>:<span class="number">211685</span>] &lt;NSThread: <span class="number">0x7feeb506dc70</span>&gt;&#123;number = <span class="number">2</span>, name = (null)&#125; <span class="number">3</span>  </span><br><span class="line"><span class="number">2015</span>-<span class="number">05</span>-<span class="number">23</span> <span class="number">22</span>:<span class="number">03</span>:<span class="number">17.991</span> Multi-Thread-Test[<span class="number">4502</span>:<span class="number">211685</span>] &lt;NSThread: <span class="number">0x7feeb506dc70</span>&gt;&#123;number = <span class="number">2</span>, name = (null)&#125; <span class="number">4</span></span><br></pre></td></tr></table></figure>
<h4 id="u5E76_u884C_u961F_u5217"><a href="#u5E76_u884C_u961F_u5217" class="headerlink" title="并行队列"></a>并行队列</h4><p>这个比较有意思了，看下面这种情况</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)gcdDemo2 &#123;</span><br><span class="line">    <span class="comment">// 并行队列，执行顺序不确定，线程个数不确定</span></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> q = dispatch_queue_create(<span class="string">"com.pupboss.gcddemo2"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="comment">// 异步任务</span></span><br><span class="line">        <span class="built_in">dispatch_async</span>(q, ^&#123;</span><br><span class="line">            <span class="comment">// [NSThread currentThread] 可以在开发中，跟踪当前线程</span></span><br><span class="line">            <span class="comment">// num = 1，表示主线程</span></span><br><span class="line">            <span class="comment">// num = 2，表示第2个子线程。。。</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@ %d"</span>, [<span class="built_in">NSThread</span> currentThread], i);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="comment">// 同步任务顺序执行</span></span><br><span class="line">        <span class="built_in">dispatch_sync</span>(q, ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@ %d"</span>, [<span class="built_in">NSThread</span> currentThread], i);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果是下面的，非常混乱，是吧，但是</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2015</span>-<span class="number">05</span>-<span class="number">23</span> <span class="number">22</span>:<span class="number">04</span>:<span class="number">03.804</span> Multi-Thread-Test[<span class="number">4527</span>:<span class="number">212722</span>] &lt;NSThread: <span class="number">0x7f98e9600000</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125; <span class="number">3</span>  </span><br><span class="line"><span class="number">2015</span>-<span class="number">05</span>-<span class="number">23</span> <span class="number">22</span>:<span class="number">04</span>:<span class="number">03.804</span> Multi-Thread-Test[<span class="number">4527</span>:<span class="number">212715</span>] &lt;NSThread: <span class="number">0x7f98e9979e90</span>&gt;&#123;number = <span class="number">2</span>, name = (null)&#125; <span class="number">0</span>  </span><br><span class="line"><span class="number">2015</span>-<span class="number">05</span>-<span class="number">23</span> <span class="number">22</span>:<span class="number">04</span>:<span class="number">03.804</span> Multi-Thread-Test[<span class="number">4527</span>:<span class="number">212664</span>] &lt;NSThread: <span class="number">0x7f98e9428a30</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125; <span class="number">0</span>  </span><br><span class="line"><span class="number">2015</span>-<span class="number">05</span>-<span class="number">23</span> <span class="number">22</span>:<span class="number">04</span>:<span class="number">03.804</span> Multi-Thread-Test[<span class="number">4527</span>:<span class="number">212714</span>] &lt;NSThread: <span class="number">0x7f98e9a00a70</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125; <span class="number">1</span>  </span><br><span class="line"><span class="number">2015</span>-<span class="number">05</span>-<span class="number">23</span> <span class="number">22</span>:<span class="number">04</span>:<span class="number">03.804</span> Multi-Thread-Test[<span class="number">4527</span>:<span class="number">212716</span>] &lt;NSThread: <span class="number">0x7f98e98301d0</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125; <span class="number">2</span>  </span><br><span class="line"><span class="number">2015</span>-<span class="number">05</span>-<span class="number">23</span> <span class="number">22</span>:<span class="number">04</span>:<span class="number">03.804</span> Multi-Thread-Test[<span class="number">4527</span>:<span class="number">212723</span>] &lt;NSThread: <span class="number">0x7f98e9a003b0</span>&gt;&#123;number = <span class="number">6</span>, name = (null)&#125; <span class="number">4</span>  </span><br><span class="line"><span class="number">2015</span>-<span class="number">05</span>-<span class="number">23</span> <span class="number">22</span>:<span class="number">04</span>:<span class="number">03.805</span> Multi-Thread-Test[<span class="number">4527</span>:<span class="number">212664</span>] &lt;NSThread: <span class="number">0x7f98e9428a30</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125; <span class="number">1</span>  </span><br><span class="line"><span class="number">2015</span>-<span class="number">05</span>-<span class="number">23</span> <span class="number">22</span>:<span class="number">04</span>:<span class="number">03.805</span> Multi-Thread-Test[<span class="number">4527</span>:<span class="number">212664</span>] &lt;NSThread: <span class="number">0x7f98e9428a30</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125; <span class="number">2</span>  </span><br><span class="line"><span class="number">2015</span>-<span class="number">05</span>-<span class="number">23</span> <span class="number">22</span>:<span class="number">04</span>:<span class="number">03.805</span> Multi-Thread-Test[<span class="number">4527</span>:<span class="number">212664</span>] &lt;NSThread: <span class="number">0x7f98e9428a30</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125; <span class="number">3</span>  </span><br><span class="line"><span class="number">2015</span>-<span class="number">05</span>-<span class="number">23</span> <span class="number">22</span>:<span class="number">04</span>:<span class="number">03.805</span> Multi-Thread-Test[<span class="number">4527</span>:<span class="number">212664</span>] &lt;NSThread: <span class="number">0x7f98e9428a30</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125; <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>如果把两个任务换换位置，变成这样<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">    <span class="comment">// 同步任务顺序执行</span></span><br><span class="line">    <span class="built_in">dispatch_sync</span>(q, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@ %d"</span>, [<span class="built_in">NSThread</span> currentThread], i);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">    <span class="comment">// 异步任务</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(q, ^&#123;</span><br><span class="line">        <span class="comment">// [NSThread currentThread] 可以在开发中，跟踪当前线程</span></span><br><span class="line">        <span class="comment">// num = 1，表示主线程</span></span><br><span class="line">        <span class="comment">// num = 2，表示第2个子线程。。。</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@ %d"</span>, [<span class="built_in">NSThread</span> currentThread], i);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果就变了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2015</span>-<span class="number">05</span>-<span class="number">23</span> <span class="number">22</span>:<span class="number">04</span>:<span class="number">58.874</span> Multi-Thread-Test[<span class="number">4555</span>:<span class="number">214018</span>] &lt;NSThread: <span class="number">0x7fc8d3c28bd0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125; <span class="number">0</span>  </span><br><span class="line"><span class="number">2015</span>-<span class="number">05</span>-<span class="number">23</span> <span class="number">22</span>:<span class="number">04</span>:<span class="number">58.876</span> Multi-Thread-Test[<span class="number">4555</span>:<span class="number">214018</span>] &lt;NSThread: <span class="number">0x7fc8d3c28bd0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125; <span class="number">1</span>  </span><br><span class="line"><span class="number">2015</span>-<span class="number">05</span>-<span class="number">23</span> <span class="number">22</span>:<span class="number">04</span>:<span class="number">58.876</span> Multi-Thread-Test[<span class="number">4555</span>:<span class="number">214018</span>] &lt;NSThread: <span class="number">0x7fc8d3c28bd0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125; <span class="number">2</span>  </span><br><span class="line"><span class="number">2015</span>-<span class="number">05</span>-<span class="number">23</span> <span class="number">22</span>:<span class="number">04</span>:<span class="number">58.876</span> Multi-Thread-Test[<span class="number">4555</span>:<span class="number">214018</span>] &lt;NSThread: <span class="number">0x7fc8d3c28bd0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125; <span class="number">3</span>  </span><br><span class="line"><span class="number">2015</span>-<span class="number">05</span>-<span class="number">23</span> <span class="number">22</span>:<span class="number">04</span>:<span class="number">58.876</span> Multi-Thread-Test[<span class="number">4555</span>:<span class="number">214018</span>] &lt;NSThread: <span class="number">0x7fc8d3c28bd0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125; <span class="number">4</span>  </span><br><span class="line"><span class="number">2015</span>-<span class="number">05</span>-<span class="number">23</span> <span class="number">22</span>:<span class="number">04</span>:<span class="number">58.880</span> Multi-Thread-Test[<span class="number">4555</span>:<span class="number">214043</span>] &lt;NSThread: <span class="number">0x7fc8d3e00ae0</span>&gt;&#123;number = <span class="number">2</span>, name = (null)&#125; <span class="number">0</span>  </span><br><span class="line"><span class="number">2015</span>-<span class="number">05</span>-<span class="number">23</span> <span class="number">22</span>:<span class="number">04</span>:<span class="number">58.881</span> Multi-Thread-Test[<span class="number">4555</span>:<span class="number">214043</span>] &lt;NSThread: <span class="number">0x7fc8d3e00ae0</span>&gt;&#123;number = <span class="number">2</span>, name = (null)&#125; <span class="number">1</span>  </span><br><span class="line"><span class="number">2015</span>-<span class="number">05</span>-<span class="number">23</span> <span class="number">22</span>:<span class="number">04</span>:<span class="number">58.881</span> Multi-Thread-Test[<span class="number">4555</span>:<span class="number">214044</span>] &lt;NSThread: <span class="number">0x7fc8d3e03280</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125; <span class="number">2</span>  </span><br><span class="line"><span class="number">2015</span>-<span class="number">05</span>-<span class="number">23</span> <span class="number">22</span>:<span class="number">04</span>:<span class="number">58.881</span> Multi-Thread-Test[<span class="number">4555</span>:<span class="number">214043</span>] &lt;NSThread: <span class="number">0x7fc8d3e00ae0</span>&gt;&#123;number = <span class="number">2</span>, name = (null)&#125; <span class="number">4</span>  </span><br><span class="line"><span class="number">2015</span>-<span class="number">05</span>-<span class="number">23</span> <span class="number">22</span>:<span class="number">04</span>:<span class="number">58.881</span> Multi-Thread-Test[<span class="number">4555</span>:<span class="number">214046</span>] &lt;NSThread: <span class="number">0x7fc8d3f0adb0</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125; <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p><strong>说明并行队列中的同步任务，还是在主线程上，并且执行完了之后才会往下走</strong></p>
<h4 id="u5168_u5C40_u961F_u5217"><a href="#u5168_u5C40_u961F_u5217" class="headerlink" title="全局队列"></a>全局队列</h4><p>苹果为了方便多线程的设计，提供一个全局队列，供所有的APP共同使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span>  <span class="built_in">queue</span> = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>两个参数，一个是优先级，一个是 0，现在只能写 0，因为苹果没想好这个参数怎么开放给开发者。</p>
<p>全局队列用起来跟并行队列是差不多的，所以就不上代码了</p>
<h4 id="u4E3B_u7EBF_u7A0B_u961F_u5217"><a href="#u4E3B_u7EBF_u7A0B_u961F_u5217" class="headerlink" title="主线程队列"></a>主线程队列</h4><p>每一个应用程序都只有一个主线程，有些操作，需要放到主线程队列来完成，比如数据下载完，刷新界面，等等</p>
<p><strong>主线程队列千万不要使用同步任务</strong>，会发生阻塞！</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)gcdDemo4 &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> q = dispatch_get_main_queue();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步任务，在主线程上运行，同时是保持队形的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(q, ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@ - %d"</span>, [<span class="built_in">NSThread</span> currentThread], i);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2015</span>-<span class="number">05</span>-<span class="number">23</span> <span class="number">22</span>:<span class="number">34</span>:<span class="number">17.663</span> Multi-Thread-Test[<span class="number">4800</span>:<span class="number">243581</span>] &lt;NSThread: <span class="number">0x7fbffc023060</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125; - <span class="number">0</span>  </span><br><span class="line"><span class="number">2015</span>-<span class="number">05</span>-<span class="number">23</span> <span class="number">22</span>:<span class="number">34</span>:<span class="number">17.664</span> Multi-Thread-Test[<span class="number">4800</span>:<span class="number">243581</span>] &lt;NSThread: <span class="number">0x7fbffc023060</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125; - <span class="number">1</span>  </span><br><span class="line"><span class="number">2015</span>-<span class="number">05</span>-<span class="number">23</span> <span class="number">22</span>:<span class="number">34</span>:<span class="number">17.664</span> Multi-Thread-Test[<span class="number">4800</span>:<span class="number">243581</span>] &lt;NSThread: <span class="number">0x7fbffc023060</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125; - <span class="number">2</span>  </span><br><span class="line"><span class="number">2015</span>-<span class="number">05</span>-<span class="number">23</span> <span class="number">22</span>:<span class="number">34</span>:<span class="number">17.664</span> Multi-Thread-Test[<span class="number">4800</span>:<span class="number">243581</span>] &lt;NSThread: <span class="number">0x7fbffc023060</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125; - <span class="number">3</span>  </span><br><span class="line"><span class="number">2015</span>-<span class="number">05</span>-<span class="number">23</span> <span class="number">22</span>:<span class="number">34</span>:<span class="number">17.664</span> Multi-Thread-Test[<span class="number">4800</span>:<span class="number">243581</span>] &lt;NSThread: <span class="number">0x7fbffc023060</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125; - <span class="number">4</span></span><br></pre></td></tr></table></figure>
<h4 id="u6279_u91CF_u4E0B_u8F7D_u56FE_u7247"><a href="#u6279_u91CF_u4E0B_u8F7D_u56FE_u7247" class="headerlink" title="批量下载图片"></a>批量下载图片</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dispatch_sync</span>(q, ^&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@ %d"</span>, [<span class="built_in">NSThread</span> currentThread], i);</span><br><span class="line">        <span class="built_in">NSString</span> *imageName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%d.jpg"</span>, i];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSString</span> *url = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"http://xxxxy/%@"</span>, imageName];</span><br><span class="line"></span><br><span class="line">        [LJFileTool writeImageToFileName:imageName withImgURL:url];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这么写没什么好处 = =，也就是不阻塞主线程，除此之外真没啥了。。。。卧槽，本来想写成异步任务的，结果发现老是有问题，而且速度也一般。</p>
<h4 id="iOS__u7684_u63A8_u9001"><a href="#iOS__u7684_u63A8_u9001" class="headerlink" title="iOS 的推送"></a>iOS 的推送</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *startArr = [<span class="built_in">NSArray</span> arrayWithContentsOfFile:<span class="string">@"/xxxxx/test.plist"</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> q = dispatch_queue_create(<span class="string">"com.pupboss.pusher"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; startArr<span class="variable">.count</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(q, ^&#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@ %d"</span>, [<span class="built_in">NSThread</span> currentThread], i);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, startArr[i]);</span><br><span class="line"></span><br><span class="line">            [<span class="keyword">self</span> sendMsg:startArr[i]];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>GCD，全名是 Grand Central Dispatch ，通常是 create 一个 <code>dispatch_queue_t</code> 队列，然后把任务放到队列中，队列分为 <code>dispatch_async</code> （异步队列）和 <code>dispatch_sync</code> （同步队列）。</p>]]>
    
    </summary>
    
      <category term="GCD" scheme="http://yimouleng.com/tags/GCD/"/>
    
      <category term="多线程" scheme="http://yimouleng.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="iOS开发" scheme="http://yimouleng.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS开发 正则匹配用户身份证号15或18位]]></title>
    <link href="http://yimouleng.com/2014/11/09/ios-shenfenzheng-zhenze/"/>
    <id>http://yimouleng.com/2014/11/09/ios-shenfenzheng-zhenze/</id>
    <published>2014-11-08T16:31:45.000Z</published>
    <updated>2015-12-09T08:45:58.000Z</updated>
    <content type="html"><![CDATA[<p>　　<strong>身份证正则：</strong>正则匹配用户身份证号15或18位,经测试，非常完美。传入身份证字符串即可。返回YES-NO;</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">pragma</span> 正则匹配用户身份证号<span class="number">15</span>或<span class="number">18</span>位</span></span><br><span class="line"></span><br><span class="line">+ (BOOL)validateIDCardNumber:(NSString *)value </span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    value = [value stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> length =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!value) &#123;</span><br><span class="line">        <span class="keyword">return</span> NO;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        length = value.length;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (length !=<span class="number">15</span> &amp;&amp; length !=<span class="number">18</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> NO;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省份代码</span></span><br><span class="line">    NSArray *areasArray =@[@<span class="string">"11"</span>,@<span class="string">"12"</span>, @<span class="string">"13"</span>,@<span class="string">"14"</span>, @<span class="string">"15"</span>,@<span class="string">"21"</span>, @<span class="string">"22"</span>,@<span class="string">"23"</span>, @<span class="string">"31"</span>,@<span class="string">"32"</span>, @<span class="string">"33"</span>,@<span class="string">"34"</span>, @<span class="string">"35"</span>,@<span class="string">"36"</span>, @<span class="string">"37"</span>,@<span class="string">"41"</span>, @<span class="string">"42"</span>,@<span class="string">"43"</span>, @<span class="string">"44"</span>,@<span class="string">"45"</span>, @<span class="string">"46"</span>,@<span class="string">"50"</span>, @<span class="string">"51"</span>,@<span class="string">"52"</span>, @<span class="string">"53"</span>,@<span class="string">"54"</span>, @<span class="string">"61"</span>,@<span class="string">"62"</span>, @<span class="string">"63"</span>,@<span class="string">"64"</span>, @<span class="string">"65"</span>,@<span class="string">"71"</span>, @<span class="string">"81"</span>,@<span class="string">"82"</span>, @<span class="string">"91"</span>];</span><br><span class="line">    </span><br><span class="line">    NSString *valueStart2 = [value substringToIndex:<span class="number">2</span>];</span><br><span class="line">    BOOL areaFlag =NO;</span><br><span class="line">    <span class="keyword">for</span> (NSString *areaCode in areasArray) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([areaCode isEqualToString:valueStart2]) &#123;</span><br><span class="line">            areaFlag =YES;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!areaFlag) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    NSRegularExpression *regularExpression;</span><br><span class="line">    NSUInteger numberofMatch;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> year =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (length) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">15</span>:</span><br><span class="line">            year = [value substringWithRange:NSMakeRange(<span class="number">6</span>,<span class="number">2</span>)].intValue +<span class="number">1900</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (year %<span class="number">4</span> ==<span class="number">0</span> || (year %<span class="number">100</span> ==<span class="number">0</span> &amp;&amp; year %<span class="number">4</span> ==<span class="number">0</span>)) &#123;</span><br><span class="line">                </span><br><span class="line">                regularExpression = [[NSRegularExpression alloc]initWithPattern:@<span class="string">"^[1-9][0-9]&#123;5&#125;[0-9]&#123;2&#125;((01|03|05|07|08|10|12)(0[1-9]|[1-2][0-9]|3[0-1])|(04|06|09|11)(0[1-9]|[1-2][0-9]|30)|02(0[1-9]|[1-2][0-9]))[0-9]&#123;3&#125;$"</span></span><br><span class="line">                                                                       options:NSRegularExpressionCaseInsensitive</span><br><span class="line">                                                                         error:nil];<span class="comment">//测试出生日期的合法性</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                regularExpression = [[NSRegularExpression alloc]initWithPattern:@<span class="string">"^[1-9][0-9]&#123;5&#125;[0-9]&#123;2&#125;((01|03|05|07|08|10|12)(0[1-9]|[1-2][0-9]|3[0-1])|(04|06|09|11)(0[1-9]|[1-2][0-9]|30)|02(0[1-9]|1[0-9]|2[0-8]))[0-9]&#123;3&#125;$"</span></span><br><span class="line">                                                                       options:NSRegularExpressionCaseInsensitive</span><br><span class="line">                                                                         error:nil];<span class="comment">//测试出生日期的合法性</span></span><br><span class="line">            &#125;</span><br><span class="line">            numberofMatch = [regularExpression numberOfMatchesInString:value</span><br><span class="line">                                                              options:NSMatchingReportProgress</span><br><span class="line">                                                                range:NSMakeRange(<span class="number">0</span>, value.length)];</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(numberofMatch &gt;<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> YES;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> NO;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">18</span>:</span><br><span class="line">            </span><br><span class="line">            year = [value substringWithRange:NSMakeRange(<span class="number">6</span>,<span class="number">4</span>)].intValue;</span><br><span class="line">            <span class="keyword">if</span> (year %<span class="number">4</span> ==<span class="number">0</span> || (year %<span class="number">100</span> ==<span class="number">0</span> &amp;&amp; year %<span class="number">4</span> ==<span class="number">0</span>)) &#123;</span><br><span class="line">                </span><br><span class="line">                regularExpression = [[NSRegularExpression alloc]initWithPattern:@<span class="string">"^[1-9][0-9]&#123;5&#125;19[0-9]&#123;2&#125;((01|03|05|07|08|10|12)(0[1-9]|[1-2][0-9]|3[0-1])|(04|06|09|11)(0[1-9]|[1-2][0-9]|30)|02(0[1-9]|[1-2][0-9]))[0-9]&#123;3&#125;[0-9Xx]$"</span></span><br><span class="line">                                                                       options:NSRegularExpressionCaseInsensitive</span><br><span class="line">                                                                         error:nil];<span class="comment">//测试出生日期的合法性</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                regularExpression = [[NSRegularExpression alloc]initWithPattern:@<span class="string">"^[1-9][0-9]&#123;5&#125;19[0-9]&#123;2&#125;((01|03|05|07|08|10|12)(0[1-9]|[1-2][0-9]|3[0-1])|(04|06|09|11)(0[1-9]|[1-2][0-9]|30)|02(0[1-9]|1[0-9]|2[0-8]))[0-9]&#123;3&#125;[0-9Xx]$"</span></span><br><span class="line">                                                                       options:NSRegularExpressionCaseInsensitive</span><br><span class="line">                                                                         error:nil];<span class="comment">//测试出生日期的合法性</span></span><br><span class="line">            &#125;</span><br><span class="line">            numberofMatch = [regularExpression numberOfMatchesInString:value</span><br><span class="line">                                                              options:NSMatchingReportProgress</span><br><span class="line">                                                                range:NSMakeRange(<span class="number">0</span>, value.length)];</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(numberofMatch &gt;<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> S = ([value substringWithRange:NSMakeRange(<span class="number">0</span>,<span class="number">1</span>)].intValue + [value substringWithRange:NSMakeRange(<span class="number">10</span>,<span class="number">1</span>)].intValue) *<span class="number">7</span> + ([value substringWithRange:NSMakeRange(<span class="number">1</span>,<span class="number">1</span>)].intValue + [value substringWithRange:NSMakeRange(<span class="number">11</span>,<span class="number">1</span>)].intValue) *<span class="number">9</span> + ([value substringWithRange:NSMakeRange(<span class="number">2</span>,<span class="number">1</span>)].intValue + [value substringWithRange:NSMakeRange(<span class="number">12</span>,<span class="number">1</span>)].intValue) *<span class="number">10</span> + ([value substringWithRange:NSMakeRange(<span class="number">3</span>,<span class="number">1</span>)].intValue + [value substringWithRange:NSMakeRange(<span class="number">13</span>,<span class="number">1</span>)].intValue) *<span class="number">5</span> + ([value substringWithRange:NSMakeRange(<span class="number">4</span>,<span class="number">1</span>)].intValue + [value substringWithRange:NSMakeRange(<span class="number">14</span>,<span class="number">1</span>)].intValue) *<span class="number">8</span> + ([value substringWithRange:NSMakeRange(<span class="number">5</span>,<span class="number">1</span>)].intValue + [value substringWithRange:NSMakeRange(<span class="number">15</span>,<span class="number">1</span>)].intValue) *<span class="number">4</span> + ([value substringWithRange:NSMakeRange(<span class="number">6</span>,<span class="number">1</span>)].intValue + [value substringWithRange:NSMakeRange(<span class="number">16</span>,<span class="number">1</span>)].intValue) *<span class="number">2</span> + [value substringWithRange:NSMakeRange(<span class="number">7</span>,<span class="number">1</span>)].intValue *<span class="number">1</span> + [value substringWithRange:NSMakeRange(<span class="number">8</span>,<span class="number">1</span>)].intValue *<span class="number">6</span> + [value substringWithRange:NSMakeRange(<span class="number">9</span>,<span class="number">1</span>)].intValue *<span class="number">3</span>;</span><br><span class="line">                <span class="keyword">int</span> Y = S %<span class="number">11</span>;</span><br><span class="line">                NSString *M =@<span class="string">"F"</span>;</span><br><span class="line">                NSString *JYM =@<span class="string">"10X98765432"</span>;</span><br><span class="line">                M = [JYM substringWithRange:NSMakeRange(Y,<span class="number">1</span>)];<span class="comment">// 判断校验位</span></span><br><span class="line">                <span class="keyword">if</span> ([M isEqualToString:[value substringWithRange:NSMakeRange(<span class="number">17</span>,<span class="number">1</span>)]]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> YES;<span class="comment">// 检测ID的校验位</span></span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> NO;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> NO;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p>　　<strong>身份证正则：</strong>正则匹配用户身份证号15或18位,经测试，非常完美。传入身份证字符串即可。返回YES-NO;</p>]]>
    
    </summary>
    
      <category term="正则" scheme="http://yimouleng.com/tags/%E6%AD%A3%E5%88%99/"/>
    
      <category term="iOS开发" scheme="http://yimouleng.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[UIKeyboardType样式]]></title>
    <link href="http://yimouleng.com/2014/09/29/UIKeyboardType-style/"/>
    <id>http://yimouleng.com/2014/09/29/UIKeyboardType-style/</id>
    <published>2014-09-28T17:24:41.000Z</published>
    <updated>2015-12-09T08:41:35.000Z</updated>
    <content type="html"><![CDATA[<h3 id="UIKeyboardType_u6837_u5F0F"><a href="#UIKeyboardType_u6837_u5F0F" class="headerlink" title="UIKeyboardType样式"></a>UIKeyboardType样式</h3><h4 id="UIKeyboardTypeAlphabet__u591A_u7528_u4E8E_u90AE_u7BB1_u7B49"><a href="#UIKeyboardTypeAlphabet__u591A_u7528_u4E8E_u90AE_u7BB1_u7B49" class="headerlink" title="UIKeyboardTypeAlphabet  多用于邮箱等"></a>UIKeyboardTypeAlphabet  多用于邮箱等</h4><p><img src="http://my.csdn.net/uploads/201206/15/1339740926_4824.png" alt=""></p>
<a id="more"></a>
<h4 id="UIKeyboardTypeASCIICapable__u591A_u7528_u4E8E_u90AE_u7BB1_u7B49"><a href="#UIKeyboardTypeASCIICapable__u591A_u7528_u4E8E_u90AE_u7BB1_u7B49" class="headerlink" title="UIKeyboardTypeASCIICapable 多用于邮箱等"></a>UIKeyboardTypeASCIICapable 多用于邮箱等</h4><p><img src="http://my.csdn.net/uploads/201206/15/1339740996_1806.png" alt=""></p>
<h4 id="UIKeyboardTypeDecimalPad__u591A_u7528_u4E8E_u624B_u673A_u53F7_uFF0C_u91D1_u94B1_u7B49"><a href="#UIKeyboardTypeDecimalPad__u591A_u7528_u4E8E_u624B_u673A_u53F7_uFF0C_u91D1_u94B1_u7B49" class="headerlink" title="UIKeyboardTypeDecimalPad  多用于手机号，金钱等"></a>UIKeyboardTypeDecimalPad  多用于手机号，金钱等</h4><p><img src="http://my.csdn.net/uploads/201206/15/1339741017_6102.png" alt=""></p>
<h4 id="UIKeyboardTypeDefault__u591A_u9ED8_u8BA4_u6837_u5F0F"><a href="#UIKeyboardTypeDefault__u591A_u9ED8_u8BA4_u6837_u5F0F" class="headerlink" title="UIKeyboardTypeDefault 多默认样式"></a>UIKeyboardTypeDefault 多默认样式</h4><p><img src="http://my.csdn.net/uploads/201206/15/1339741055_6733.png" alt=""></p>
<h4 id="UIKeyboardTypeEmailAddress__u591A_u7528_u4E8E_u90AE_u7BB1_u7B49"><a href="#UIKeyboardTypeEmailAddress__u591A_u7528_u4E8E_u90AE_u7BB1_u7B49" class="headerlink" title="UIKeyboardTypeEmailAddress  多用于邮箱等"></a>UIKeyboardTypeEmailAddress  多用于邮箱等</h4><p><img src="http://my.csdn.net/uploads/201206/15/1339741091_7392.png" alt=""></p>
<h4 id="UIKeyboardTypeNamePhonePad__u591A_u7528_u4E8E_u90AE_u7BB1_u7B49"><a href="#UIKeyboardTypeNamePhonePad__u591A_u7528_u4E8E_u90AE_u7BB1_u7B49" class="headerlink" title="UIKeyboardTypeNamePhonePad   多用于邮箱等"></a>UIKeyboardTypeNamePhonePad   多用于邮箱等</h4><p><img src="http://my.csdn.net/uploads/201206/15/1339741130_2983.png" alt=""></p>
<h4 id="UIKeyboardTypeNumberPad__u591A_u7528_u4E8E_u624B_u673A_u53F7_uFF0C_u91D1_u94B1_u7B49"><a href="#UIKeyboardTypeNumberPad__u591A_u7528_u4E8E_u624B_u673A_u53F7_uFF0C_u91D1_u94B1_u7B49" class="headerlink" title="UIKeyboardTypeNumberPad  多用于手机号，金钱等"></a>UIKeyboardTypeNumberPad  多用于手机号，金钱等</h4><p><img src="http://my.csdn.net/uploads/201206/15/1339741152_5004.png" alt=""></p>
<h4 id="UIKeyboardTypeNumbersAndPunctuation__u591A_u7528_u4E8E_u7279_u6B8A_u6570_u5B57_uFF0C_u7B26_u53F7_u7B49"><a href="#UIKeyboardTypeNumbersAndPunctuation__u591A_u7528_u4E8E_u7279_u6B8A_u6570_u5B57_uFF0C_u7B26_u53F7_u7B49" class="headerlink" title="UIKeyboardTypeNumbersAndPunctuation 多用于特殊数字，符号等"></a>UIKeyboardTypeNumbersAndPunctuation 多用于特殊数字，符号等</h4><p><img src="http://my.csdn.net/uploads/201206/15/1339741179_3086.png" alt=""></p>
<h4 id="UIKeyboardTypePhonePad__u591A_u7528_u4E8E_u7279_u6B8A_u6570_u5B57_uFF0C_u52A0_u51CF_u6CD5_u7B49"><a href="#UIKeyboardTypePhonePad__u591A_u7528_u4E8E_u7279_u6B8A_u6570_u5B57_uFF0C_u52A0_u51CF_u6CD5_u7B49" class="headerlink" title="UIKeyboardTypePhonePad   多用于特殊数字，加减法等"></a>UIKeyboardTypePhonePad   多用于特殊数字，加减法等</h4><p><img src="http://my.csdn.net/uploads/201206/15/1339741211_3922.png" alt=""></p>
<h4 id="UIKeyboardTypeTwitter__u591A_u7528_u4E8E_u8F93_u5165_u7B49"><a href="#UIKeyboardTypeTwitter__u591A_u7528_u4E8E_u8F93_u5165_u7B49" class="headerlink" title="UIKeyboardTypeTwitter 多用于输入等"></a>UIKeyboardTypeTwitter 多用于输入等</h4><p><img src="http://my.csdn.net/uploads/201206/15/1339741242_2918.png" alt=""></p>
<h4 id="UIKeyboardTypeURL__u591A_u7528_u4E8E_u7F51_u5740_u7B49"><a href="#UIKeyboardTypeURL__u591A_u7528_u4E8E_u7F51_u5740_u7B49" class="headerlink" title="UIKeyboardTypeURL  多用于网址等"></a>UIKeyboardTypeURL  多用于网址等</h4><p><img src="http://my.csdn.net/uploads/201206/15/1339741271_7077.png" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="UIKeyboardType_u6837_u5F0F"><a href="#UIKeyboardType_u6837_u5F0F" class="headerlink" title="UIKeyboardType样式"></a>UIKeyboardType样式</h3><h4 id="UIKeyboardTypeAlphabet__u591A_u7528_u4E8E_u90AE_u7BB1_u7B49"><a href="#UIKeyboardTypeAlphabet__u591A_u7528_u4E8E_u90AE_u7BB1_u7B49" class="headerlink" title="UIKeyboardTypeAlphabet  多用于邮箱等"></a>UIKeyboardTypeAlphabet  多用于邮箱等</h4><p><img src="http://my.csdn.net/uploads/201206/15/1339740926_4824.png" alt=""></p>]]>
    
    </summary>
    
      <category term="UIKeyboardType" scheme="http://yimouleng.com/tags/UIKeyboardType/"/>
    
      <category term="键盘" scheme="http://yimouleng.com/tags/%E9%94%AE%E7%9B%98/"/>
    
      <category term="iOS开发" scheme="http://yimouleng.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[UITextField限制输入中文字数]]></title>
    <link href="http://yimouleng.com/2014/08/28/ios-UITextField-zifu/"/>
    <id>http://yimouleng.com/2014/08/28/ios-UITextField-zifu/</id>
    <published>2014-08-27T16:00:00.000Z</published>
    <updated>2015-12-09T08:25:36.000Z</updated>
    <content type="html"><![CDATA[<h2 id="UITextField_u9650_u5236_u8F93_u5165_u4E2D_u6587_u5B57_u6570"><a href="#UITextField_u9650_u5236_u8F93_u5165_u4E2D_u6587_u5B57_u6570" class="headerlink" title="UITextField限制输入中文字数"></a>UITextField限制输入中文字数</h2><p></p><h2 id="intro">前言</h2>在开发中，经常遇到限制字符串长度，比如输入用户名，签名等，系统的截取方法，会有各种各样的问题， 比如在使用第三方输入法连续打出超过长度的字符串，直接添加，并不会自动限制等，本文对限制字符做出一些分析，尤其师输入中文字符的时候。<p></p>
<p>采用了UITextField作为我的输入框控件，并且在委托方法</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="pp">- <span class="params">(<span class="variable">BOOL</span>)</span>textField:<span class="params">(<span class="variable">UITextField</span> *)</span>textField shouldChangeCharactersInRange:<span class="params">(<span class="variable">NSRange</span>)</span>range replacementString:<span class="params">(<span class="variable">NSString</span> *)</span>string</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>中实现了对字符串的长度限制，实现如下</p>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#define kMaxLength <span class="number">20</span></span><br><span class="line"></span><br><span class="line">- (BOOL)<span class="keyword">textField</span>:(UITextField <span class="variable">*)</span><span class="keyword">textField</span> shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString <span class="variable">*)</span><span class="keyword">string</span>&#123;</span><br><span class="line"></span><br><span class="line">   NSString * toBeString = [<span class="keyword">textField</span>.<span class="keyword">text</span> stringByReplacingCharactersInRange:range withString:<span class="keyword">string</span>];</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (toBeString.length &gt; kMaxLength &amp;&amp; range.length!=<span class="number">1</span>)&#123;</span><br><span class="line">       <span class="keyword">textField</span>.<span class="keyword">text</span> = [toBeString substringToIndex:kMaxLength];</span><br><span class="line">       <span class="keyword">return</span> NO;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">   <span class="keyword">return</span> YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样实现的结果是：对于纯字符的统计没有什么问题，当输入的字符超过限制时输入框便截取最大限制长度的字符串。但是，有个问题，当使用拼音输入法时，该委托方法中的最后一个参数string接受的是输入的字母，而不是选择的汉字，造成的结果是，当想输入文字“我在编程”，输入拼音“wozaibiancheng”，每输入一个字母便会进入委托方法，统计的字符长度是字母的长度，实际上汉字还未超过限制长度，但是字母的长度超过了导致无法继续输入。</p>
<p>而且，致命的是，这个委托方法并不响应，选中候选汉字的过程，这就没有办法重新修正字符长度的统计了。</p>
<p>网上查了一些方法，有个叫Onyx的博主写了篇文章：iOS中UITextView/UITextField 输入英文和拼音状态下如何正确的统计输入的文字字数 看起来似乎是和我同样的问题，但是当我把他的代码搬到我的类里时，实现的结果并不理想，我没有得到想要的结果，而且他的方法看起来似乎复杂了点，我也没有研究清楚这个方法的问题出在哪。之所以把他的这篇博文引进来，是因为他的文章后来给了我些启发。</p>
<p>我刚开始时候并没有发现</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="pp">- <span class="params">(<span class="variable">BOOL</span>)</span>textField:<span class="params">(<span class="variable">UITextField</span> *)</span>textField shouldChangeCharactersInRange:<span class="params">(<span class="variable">NSRange</span>)</span>range replacementString:<span class="params">(<span class="variable">NSString</span> *)</span>string</span></span><br></pre></td></tr></table></figure>
<p>这个委托方法没有响应最后拼音到汉字的过程，当我发现这个问题时，问题便也差不多得到了解决。因为在之前向微博上的一个朋友咨询时，他告诉我可以注册这个观察者 <code>UITextInputCurrentInputModeDidChangeNotification</code><br>在它的监听下可以得到中文。我刚开始时候理解错了他的意思，以为得到的就是最终选中的汉字，而中间输入的拼音并不会被得到。但其实这个监听，比以上的委托方法多了最后一步而已，即从拼音到中文的过程。</p>
<p>所以实现的代码如下。</p>
<p><strong><1>在init时候注册notification：</1></strong></p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="collection">[<span class="collection">[NSNotificationCenter defaultCenter]</span>addObserver:self selector:@selector<span class="list">(<span class="keyword">textFiledEditChanged:</span>)</span></span><br><span class="line">                                           name:@<span class="string">"UITextFieldTextDidChangeNotification"</span></span><br><span class="line">                                         object:myTextField]</span><span class="comment">;`</span></span><br></pre></td></tr></table></figure>
<p><strong><2>实现监听方法：</2></strong></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)textFiledEditChanged:(<span class="built_in">NSNotification</span> *)obj&#123;</span><br><span class="line">   <span class="built_in">UITextField</span> *textField = (<span class="built_in">UITextField</span> *)obj<span class="variable">.object</span>;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">NSString</span> *toBeString = textField<span class="variable">.text</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="built_in">NSString</span> *lang = [[<span class="built_in">UITextInputMode</span> currentInputMode] primaryLanguage]; <span class="comment">// 键盘输入模式</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> ([lang isEqualToString:<span class="string">@"zh-Hans"</span>]) &#123; <span class="comment">// 简体中文输入，包括简体拼音，健体五笔，简体手写`</span></span><br><span class="line"></span><br><span class="line">       <span class="built_in">UITextRange</span> *selectedRange = [textField markedTextRange];</span><br><span class="line"></span><br><span class="line">       <span class="comment">//获取高亮部分</span></span><br><span class="line">       <span class="built_in">UITextPosition</span> *position = [textField positionFromPosition:selectedRange<span class="variable">.start</span> offset:<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 没有高亮选择的字，则对已输入的文字进行字数统计和限制</span></span><br><span class="line">       <span class="keyword">if</span> (!position) &#123;</span><br><span class="line">           <span class="keyword">if</span> (toBeString<span class="variable">.length</span> &gt; kMaxLength) &#123;</span><br><span class="line">               textField<span class="variable">.text</span> = [toBeString substringToIndex:kMaxLength];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 有高亮选择的字符串，则暂不对文字进行统计和限制</span></span><br><span class="line">       <span class="keyword">else</span>&#123;</span><br><span class="line">         </span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 中文输入法以外的直接对其统计限制即可，不考虑其他语种情况</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">else</span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (toBeString<span class="variable">.length</span> &gt; kMaxLength) &#123;</span><br><span class="line">           textField<span class="variable">.text</span> = [toBeString substringToIndex:kMaxLength];</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><3>在dealloc里注销掉监听方法，切记！</3></strong></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)dealloc&#123;</span><br><span class="line">   [[<span class="built_in">NSNotificationCenter</span> defaultCenter]removeObserver:<span class="keyword">self</span></span><br><span class="line">                                           name:<span class="string">@"UITextFieldTextDidChangeNotification"</span></span><br><span class="line">                                         object:_albumNameTextField];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>==注：本文主要提供思路，代码仅供参考，不为其百分百正确负责，若有不足之处欢迎讨论。==</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="UITextField_u9650_u5236_u8F93_u5165_u4E2D_u6587_u5B57_u6570"><a href="#UITextField_u9650_u5236_u8F93_u5165_u4E2D_u6587_u5B57_u6570" class="headerlink" title="UITextField限制输入中文字数"></a>UITextField限制输入中文字数</h2><p><h2 id="intro">前言</h2>在开发中，经常遇到限制字符串长度，比如输入用户名，签名等，系统的截取方法，会有各种各样的问题， 比如在使用第三方输入法连续打出超过长度的字符串，直接添加，并不会自动限制等，本文对限制字符做出一些分析，尤其师输入中文字符的时候。</p>
<p>采用了UITextField作为我的输入框控件，并且在委托方法</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="pp">- <span class="params">(<span class="variable">BOOL</span>)</span>textField:<span class="params">(<span class="variable">UITextField</span> *)</span>textField shouldChangeCharactersInRange:<span class="params">(<span class="variable">NSRange</span>)</span>range replacementString:<span class="params">(<span class="variable">NSString</span> *)</span>string</span></span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="UITextField" scheme="http://yimouleng.com/tags/UITextField/"/>
    
      <category term="字符串" scheme="http://yimouleng.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="iOS开发" scheme="http://yimouleng.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[你可能不知道的魔兽世界小技巧]]></title>
    <link href="http://yimouleng.com/2014/08/24/WOW-skill/"/>
    <id>http://yimouleng.com/2014/08/24/WOW-skill/</id>
    <published>2014-08-23T16:00:00.000Z</published>
    <updated>2015-12-09T09:48:09.000Z</updated>
    <content type="html"><![CDATA[<h4 id="u4F60_u6240_u53EF_u80FD_u4E0D_u77E5_u9053_u7684_u9B54_u517D_u4E16_u754C_u5C0F_u6280_u5DE7_uFF08_u6709_u771F_u7684_uFF0C_u4E5F_u6709_u5FFD_u60A0_u7684_uFF0C_u81EA_u5DF1_u8FDB_u6E38_u620F_u5BFB_u627E_uFF09"><a href="#u4F60_u6240_u53EF_u80FD_u4E0D_u77E5_u9053_u7684_u9B54_u517D_u4E16_u754C_u5C0F_u6280_u5DE7_uFF08_u6709_u771F_u7684_uFF0C_u4E5F_u6709_u5FFD_u60A0_u7684_uFF0C_u81EA_u5DF1_u8FDB_u6E38_u620F_u5BFB_u627E_uFF09" class="headerlink" title="你所可能不知道的魔兽世界小技巧（有真的，也有忽悠的，自己进游戏寻找）"></a>你所可能不知道的魔兽世界小技巧（有真的，也有忽悠的，自己进游戏寻找）</h4><p>以下所有内容未经亲自测试，仅仅从外国网站上搬运过来。如有小白鼠认证，实属感谢。<br><a id="more"></a></p>
<h4 id="u5982_u4F55_u5728_u88AB_u602A_u63A7_u5236_u4E4B_u540E_u4E0D_u653B_u51FB_u961F_u53CB_uFF1F"><a href="#u5982_u4F55_u5728_u88AB_u602A_u63A7_u5236_u4E4B_u540E_u4E0D_u653B_u51FB_u961F_u53CB_uFF1F" class="headerlink" title="如何在被怪控制之后不攻击队友？"></a>如何在被怪控制之后不攻击队友？</h4><p>例如能源的计算者XXXX，或者是迷宫的老2，被控制之后攻击队友，特别是大技能狂开很是让人恼火。怎样避免呢？只需要做一个宏，内容为:<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">Code:</span></span><br><span class="line">/sit</span><br><span class="line">/sit</span><br><span class="line">/sit</span><br><span class="line">/sit</span><br><span class="line">/sit</span><br></pre></td></tr></table></figure></p>
<p>然后再被控制之后狂用这个宏即可。据称可以在很大程度上防止你的角色用施法型法术或攻击技能伤害你的队友。（我这个没有解释清楚，我是说用这个宏的人是被boss控制的人，不是其他没有被控制的人）</p>
<h4 id="66_u7EA7_u600E_u6837_u901A_u8FC7_u505A10_u7EA7_u7684_u4EFB_u52A1_u6765_u83B7_u5F971_u4E07+_u7684_u7ECF_u9A8C_uFF1F"><a href="#66_u7EA7_u600E_u6837_u901A_u8FC7_u505A10_u7EA7_u7684_u4EFB_u52A1_u6765_u83B7_u5F971_u4E07+_u7684_u7ECF_u9A8C_uFF1F" class="headerlink" title="66级怎样通过做10级的任务来获得1万+的经验？"></a>66级怎样通过做10级的任务来获得1万+的经验？</h4><p>举例。例如人类术士在多少多少级的时候可以找NPC接到召唤小鬼的任务，如果你是侏儒术士，那么你可以在70之前找到北郡修道院给任务的NPC接这个任务并完成，能够获得11000经验。同理精灵战士可以到暴风城旧城区旅馆接防御姿态的任务，等等。其他职业未知，不过可以肯定的是只要是跨种族的职业任务基本都可以完成，并且给予当前等级应该给予的客观的经验。</p>
<p>好吧，有人说我60级没小鬼，没防御姿态。这个技巧我是证实过的。我自己有个精灵战士，60级是团里面的AT。68级的时候我偶然在暴风城旧城区的旅馆里面接到了人类战士的防御（还是狂暴，忘记了）姿态任务，当时显示的任务等级是68级，不过任务怪依然是10级。完成了那个任务我获得了11000经验。</p>
<p>明白了吧？不管你是否是获得了职业的技能，只要是跨种族的相同的获得职业技能的任务都可以这样。</p>
<h4 id="u600E_u6837_u8FDB_u5165_u96C6_u5408_u77F3_u7684_u91CC_u9762_uFF0Cem_u3002_u3002_u3002_u62C9_u4EBA_uFF1F_u653E_u6697_u7BAD_uFF1F"><a href="#u600E_u6837_u8FDB_u5165_u96C6_u5408_u77F3_u7684_u91CC_u9762_uFF0Cem_u3002_u3002_u3002_u62C9_u4EBA_uFF1F_u653E_u6697_u7BAD_uFF1F" class="headerlink" title="怎样进入集合石的里面，em。。。拉人？放暗箭？"></a>怎样进入集合石的里面，em。。。拉人？放暗箭？</h4><p>方法之一：你是一个法师，你必须在外域，你有鸟可以飞起来。好吧，找个集合石，飞到他的正上方，然<br>           后按住键盘的空格键（跳跃键），你会垂直上升。飞到一定的高度一直到你看不到地面的集合<br>           石的时候，点掉你的坐骑buff图标，这时候你就会垂直下落。当你即将到地上的瞬间，冰箱。<br>           ok，如果时间卡的好的话可以让你卡在集合石里面。（注意如果你的电脑很牛，并且网速很<br>           好，那么当你从飞机上下来的瞬间，把视角调成仰视正上方，一旦你感觉到快到地了，冰箱）<br>           据说可以用冰盾代替冰箱？<br>方法之二：找个骑士，依然按照上面的方法，不过这次让骑士在地上等着你，并且锁定你为目标。当你跳<br>          下来快到地的时候，让骑士一直按着保护祝福给你。<br>方法之三：你必须有280%的鸟，310%的更好，加上马鞭、十字军光环什么的，然后超低空飞行。所谓超低<br>           空飞行就是紧贴地面但是不会在地上跑的方式。向着集合石飞去，等到你感到自己正好到集合<br>           石的地方时候，迅速点掉坐骑。<br>（如果成功率低可以将视频设置里面的显示景观范围调到最低）</p>
<h4 id="u5982_u4F55_u8BA9_u4F60_u590D_u6D3B_u5BA0_u7269_u4E4B_u540E_u5BA0_u7269_u662F100_25_u751F_u547D"><a href="#u5982_u4F55_u8BA9_u4F60_u590D_u6D3B_u5BA0_u7269_u4E4B_u540E_u5BA0_u7269_u662F100_25_u751F_u547D" class="headerlink" title="如何让你复活宠物之后宠物是100%生命"></a>如何让你复活宠物之后宠物是100%生命</h4><p>首先做一个宏，内容为：<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">Code:</span></span><br><span class="line"><span class="preprocessor">#showtooltip 复活宠物</span></span><br><span class="line">/castsequence 复活宠物, 复活宠物</span><br><span class="line">/cancelaura 复活宠物</span><br></pre></td></tr></table></figure></p>
<p>接下来就是当宠物死去之后，点一下这个宏，然后当施法条到最后一点的时候（用Quartz或者同类型施法进度条插件的话可以看剩下1秒的时候），再狂点此宏。那么一切顺利出来的宝宝就是满血的。</p>
<h4 id="u8BA9_u6BCF_u65E5_u4EFB_u52A1_u201C_u7EF4_u6301_u4F20_u9001_u95E8_u201D_u6765_u5F97_u66F4_u7B80_u5355_u5427"><a href="#u8BA9_u6BCF_u65E5_u4EFB_u52A1_u201C_u7EF4_u6301_u4F20_u9001_u95E8_u201D_u6765_u5F97_u66F4_u7B80_u5355_u5427" class="headerlink" title="让每日任务“维持传送门”来得更简单吧"></a>让每日任务“维持传送门”来得更简单吧</h4><p>这任务首先要到刀锋山打怪掉个任务品，使用了进入位面世界然后做任务。</p>
<p>我们可以在开完了10个箱子之后，点掉位面状态，然后随便杀1、2个怪，就可以很快的掉那个装置。然后回去交任务，第二天或者以后再直接用那个装置即可很快的进入位面世界开箱子。</p>
<h4 id="u65B0_u5C9B_u6BCF_u65E5_u4EFB_u52A1_u201C_u7A7A_u88AD_u5FC5_u987B_u7EE7_u7EED_u201D_uFF0C_u5982_u4F55_u540C_u65F6_u4E22_u51FA2_u4E2A_u70B8_u5F39"><a href="#u65B0_u5C9B_u6BCF_u65E5_u4EFB_u52A1_u201C_u7A7A_u88AD_u5FC5_u987B_u7EE7_u7EED_u201D_uFF0C_u5982_u4F55_u540C_u65F6_u4E22_u51FA2_u4E2A_u70B8_u5F39" class="headerlink" title="新岛每日任务“空袭必须继续”，如何同时丢出2个炸弹"></a>新岛每日任务“空袭必须继续”，如何同时丢出2个炸弹</h4><p>把奥术炸药拖到快捷栏里面，绑定一个按键。飞到死亡之痕上空的时候，点炸弹，这时候目标范围的环出现。当你点鼠标丢炸弹之前的瞬间，你按一下绑定的按键，这时候你的炸弹扔出去了，环消失了，但是你还可以扔一次，虽然提示炸弹在CD。熟练之后可以最多一次扔3、4个。</p>
<h4 id="u7528_u5965_u672F_u70B8_u5F39_u70B8_u8054_u76DF/_u90E8_u843D_uFF1F"><a href="#u7528_u5965_u672F_u70B8_u5F39_u70B8_u8054_u76DF/_u90E8_u843D_uFF1F" class="headerlink" title="用奥术炸弹炸联盟/部落？"></a>用奥术炸弹炸联盟/部落？</h4><p>每日任务“空袭必须继续”里面，等到你完成任务，并且没有飞出死亡之痕范围的时候，点炸弹，当鼠标出现目标范围环的时候不要把炸弹扔出去，一直保持这个状态直到飞出死亡之痕。剩下的事情就是找敌对阵营的在做任务的人吧。炸一下14400伤害。</p>
<h4 id="u6CD5_u5E08_u5982_u4F55_u6CA1_u94A5_u5319_u4E0D_u5F00_u95E8_u8FDB_u5165_u5361_u62C9_u8D5E_uFF1F"><a href="#u6CD5_u5E08_u5982_u4F55_u6CA1_u94A5_u5319_u4E0D_u5F00_u95E8_u8FDB_u5165_u5361_u62C9_u8D5E_uFF1F" class="headerlink" title="法师如何没钥匙不开门进入卡拉赞？"></a>法师如何没钥匙不开门进入卡拉赞？</h4><p>er，其实很简单，门口顶着门然后闪现。同样适用于格鲁尔关着的门，太阳井小蓝龙的光球……</p>
<p>其他职业嘛，除了牛头男德莱尼，卡拉赞后面有个小洞也可以去到卡拉赞的正下方进门。。。</p>
<h4 id="u5999_u7528_u6697_u8A00_u672F_uFF1A_u706D"><a href="#u5999_u7528_u6697_u8A00_u672F_uFF1A_u706D" class="headerlink" title="妙用暗言术：灭"></a>妙用暗言术：灭</h4><p>假设一个场景，竞技场里面对方一个法师正在羊你，沉默CD徽章CD怎么办？看到他的施法条快读完了的时候，给他个灭。你被变羊之后的2秒你就会给自己的灭打醒，就这样。</p>
<h4 id="u8BA9_u5C38_u4F53_u5728_u5929_u7A7A_u98DE_u7FD4_u5427_uFF01_uFF01"><a href="#u8BA9_u5C38_u4F53_u5728_u5929_u7A7A_u98DE_u7FD4_u5427_uFF01_uFF01" class="headerlink" title="让尸体在天空飞翔吧！！"></a>让尸体在天空飞翔吧！！</h4><p>好吧，这个是这样的。举个例子，你只有40级，在加吉森的狮鹫管理员旁边被对方70千伤强力术士上了<br>个诅咒增幅的痛苦诅咒，等你脱离战斗的瞬间你上了飞机飞去，比方说奥伯丁，然后当飞机起飞的瞬间Alt+F4，然后上线。自己看吧。。。。</p>
<p>给2个目标都上大地之盾（是这个技能吧，被击中之后加血的）？<br>假设你要给路人甲上大地之盾，ok和他决斗，倒数321的时候给他个大地之盾，然后在决斗中给自己上个大地之盾。打/认输。2个人2个盾。</p>
<h4 id="u5999_u7528_u7EF7_u5E26_u5EF6_u957F10_u79D2_u8131_u79BB_u6218_u6597_u8BA1_u65F6"><a href="#u5999_u7528_u7EF7_u5E26_u5EF6_u957F10_u79D2_u8131_u79BB_u6218_u6597_u8BA1_u65F6" class="headerlink" title="妙用绷带延长10秒脱离战斗计时"></a>妙用绷带延长10秒脱离战斗计时</h4><p>不知道怎么说好，也是举例，一个似乎很牛X的潜行者在你身上捣鼓了一阵之后想给你上减速毒跑开并脱离战斗。ok，等到你感觉快到10秒脱离战斗时给自己上绷带，good，那潜行者又需要再等个10秒才能脱离战斗隐身。</p>
<h4 id="u4FDD_u6301_u67AD_u9996_u5F62_u6001_u4E0A_u5750_u9A91_uFF1F_u94C1_u7532_u865A_u7A7A_u9F99_u4E0A_u7684_u9E4C_u9E51_uFF01_uFF1F"><a href="#u4FDD_u6301_u67AD_u9996_u5F62_u6001_u4E0A_u5750_u9A91_uFF1F_u94C1_u7532_u865A_u7A7A_u9F99_u4E0A_u7684_u9E4C_u9E51_uFF01_uFF1F" class="headerlink" title="保持枭首形态上坐骑？铁甲虚空龙上的鹌鹑！？"></a>保持枭首形态上坐骑？铁甲虚空龙上的鹌鹑！？</h4><p>ok，联盟部落都可以，只需要德鲁伊到湿地的地图东面，沉船残骸附近，船上面有些亡灵，保持人形态让他们攻击你，此时他们给你上个“眼之诅咒”把你变成一个亡灵。这时候转换成枭首形态，上马，或者炉石回外域之后上鸟。在坐骑上面等待debuff自己消失。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="u4F60_u6240_u53EF_u80FD_u4E0D_u77E5_u9053_u7684_u9B54_u517D_u4E16_u754C_u5C0F_u6280_u5DE7_uFF08_u6709_u771F_u7684_uFF0C_u4E5F_u6709_u5FFD_u60A0_u7684_uFF0C_u81EA_u5DF1_u8FDB_u6E38_u620F_u5BFB_u627E_uFF09"><a href="#u4F60_u6240_u53EF_u80FD_u4E0D_u77E5_u9053_u7684_u9B54_u517D_u4E16_u754C_u5C0F_u6280_u5DE7_uFF08_u6709_u771F_u7684_uFF0C_u4E5F_u6709_u5FFD_u60A0_u7684_uFF0C_u81EA_u5DF1_u8FDB_u6E38_u620F_u5BFB_u627E_uFF09" class="headerlink" title="你所可能不知道的魔兽世界小技巧（有真的，也有忽悠的，自己进游戏寻找）"></a>你所可能不知道的魔兽世界小技巧（有真的，也有忽悠的，自己进游戏寻找）</h4><p>以下所有内容未经亲自测试，仅仅从外国网站上搬运过来。如有小白鼠认证，实属感谢。<br>]]>
    
    </summary>
    
      <category term="WOW" scheme="http://yimouleng.com/tags/WOW/"/>
    
      <category term="二三事" scheme="http://yimouleng.com/categories/%E4%BA%8C%E4%B8%89%E4%BA%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS开发 - 圆角]]></title>
    <link href="http://yimouleng.com/2014/07/20/ios-yuanjiao/"/>
    <id>http://yimouleng.com/2014/07/20/ios-yuanjiao/</id>
    <published>2014-07-19T16:00:00.000Z</published>
    <updated>2015-12-09T11:24:51.000Z</updated>
    <content type="html"><![CDATA[<p>iOS开发中各种圆角也随处可见,最简单给控件添加圆角的方式就是给视图的layer设置corner属性了:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span><span class="variable">.blueView</span><span class="variable">.layer</span><span class="variable">.cornerRadius</span> = <span class="number">5.</span>f;  </span><br><span class="line"><span class="keyword">self</span><span class="variable">.blueView</span><span class="variable">.layer</span><span class="variable">.masksToBounds</span> = <span class="literal">YES</span>;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>这种方式会带来两个问题: </p>
<ul>
<li><p>当图片数量比较多的时候,这种添加圆角方式特别消耗性能,比如在UITableViewCell添加过多圆角的话,甚至会带来视觉可见的卡顿. </p>
</li>
<li><p>无法配置圆角数量(只能添加view的四个角全为圆角),无法配置某个圆角大小.</p>
</li>
</ul>
<p>第一个问题实际上是由于数量太多的情况下,系统会频繁的调用GPU的离屏渲染(Offscreen Rendering)机制,导致内存损耗严重.更多关于离屏渲染的详解,可以看这里,本文不多赘述.</p>
<p>第二个问题,我们可以使用<code>UIBezierPath</code>来完美解决.以下是示例代码:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIBezierPath</span> *maskPath = [<span class="built_in">UIBezierPath</span> bezierPathWithRoundedRect:<span class="keyword">self</span><span class="variable">.blueView</span><span class="variable">.bounds</span> byRoundingCorners:<span class="built_in">UIRectCornerTopLeft</span> | <span class="built_in">UIRectCornerBottomLeft</span> cornerRadii:<span class="built_in">CGSizeMake</span>(<span class="number">20</span>, <span class="number">0</span>)];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CAShapeLayer</span> *maskLayer = [[<span class="built_in">CAShapeLayer</span> alloc] init];</span><br><span class="line"></span><br><span class="line">    maskLayer<span class="variable">.frame</span> = <span class="keyword">self</span><span class="variable">.blueView</span><span class="variable">.bounds</span>;</span><br><span class="line"></span><br><span class="line">    maskLayer<span class="variable">.path</span> = maskPath<span class="variable">.CGPath</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.blueView</span><span class="variable">.layer</span><span class="variable">.mask</span> = maskLayer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.blueView</span><span class="variable">.layer</span><span class="variable">.cornerRadius</span> = <span class="number">5.</span>f;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.blueView</span><span class="variable">.layer</span><span class="variable">.masksToBounds</span> = <span class="literal">YES</span>;</span><br></pre></td></tr></table></figure>
<p>想要配置某个角为圆角的话,只需要指定对应的<code>UIRectCorner</code>即可 </p>
<p><img src="/image/yuanjiao1.jpeg" alt=""></p>
<p>以下是显示效果: </p>
<p><img src="/image/yuanjiao2.jpg" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>iOS开发中各种圆角也随处可见,最简单给控件添加圆角的方式就是给视图的layer设置corner属性了:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span><span class="variable">.blueView</span><span class="variable">.layer</span><span class="variable">.cornerRadius</span> = <span class="number">5.</span>f;  </span><br><span class="line"><span class="keyword">self</span><span class="variable">.blueView</span><span class="variable">.layer</span><span class="variable">.masksToBounds</span> = <span class="literal">YES</span>;</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="UIBezierPath" scheme="http://yimouleng.com/tags/UIBezierPath/"/>
    
      <category term="iOS" scheme="http://yimouleng.com/tags/iOS/"/>
    
      <category term="iOS开发" scheme="http://yimouleng.com/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
</feed>
